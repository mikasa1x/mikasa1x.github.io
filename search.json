[{"title":"11.21碎片问题补充C++相关计算机基础相关","url":"/2023/11/21/11-21%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%E8%A1%A5%E5%85%85C-%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3/","content":"\n\n\n\n\n11.21碎片问题\n\n11.21碎片问题\n&nbsp;\n使用C++创建单例模式\n之前用多了C#轮椅以为自己就是单例模式懂哥了，结果却抛弃了C++原有的底层知识\n\n#include &lt;iostream&gt;\n\nclass Singleton &#123;public:    &#x2F;&#x2F; 获取单例实例的静态方法    static Singleton&amp; getInstance() &#123;        &#x2F;&#x2F; 使用局部静态变量确保线程安全的初始化        static Singleton instance;        return instance;    &#125;\n// 删除拷贝构造函数和赋值运算符重载，确保单例不会被复制\nSingleton(const Singleton&amp;amp;) = delete;\nvoid operator=(const Singleton&amp;amp;) = delete;\n\nvoid doSomething() &#123;\n    std::cout &amp;lt;&amp;lt; &amp;quot;Singleton is doing something.&amp;quot; &amp;lt;&amp;lt; std::endl;\n&#125;\n\nprivate:    &#x2F;&#x2F; 私有构造函数，确保外部无法直接实例化    Singleton() {        &#x2F;&#x2F; 进行初始化工作    }};\nint main() {    &#x2F;&#x2F; 获取单例实例    Singleton&amp; singleton &#x3D; Singleton::getInstance();    &#x2F;&#x2F; 使用单例实例    singleton.doSomething();\nreturn 0;\n\n}\n&nbsp;\ndelete this\n什么情况下要用到呢\n\n对象自毁：在对象的成员函数中，如果确定对象在某个条件下需要自毁，可以使用 delete this。但是需要确保在 delete this 之后不再访问对象的任何成员。\n对象池：在一些特殊的对象池设计中，当对象不再需要时，可以通过调用自身的成员函数来删除自己。\n异步操作：在一些异步操作中，可能需要在回调函数中删除对象自身。\n\n\n&nbsp;\noperator new与placement new\noperator new就是常见的new用法，在堆上分配内存空间并利用对象的构造函数来创建对象，如：\nMyClass* obj = new MyClass;\nplacement new是一个特殊的new，区别时在已经有的空间上创建对象，如\nMyClass* obj = new(ptr) MyClass; \n就是在ptr指定的内存段上创建对象，不会分配新的内存空间\n&nbsp;\nstatic关键字的全面解析，extern关键字的全面解析\n&nbsp;\nstatic\n对于C、C++、C#中的static的含义其实是大部分一致的，不同的地方取决与语言自身功能性的不同，比如纯C语言不带有的成员函数，那么static在这一方面就不存在意义。\n局部变量\n普通的局部变量生命周期和其作用域一致，但加上static关键字后该局部变量由栈内存转移到静态存储区，在整个程序的生命周期中都存在，但是对于其他函数来说是不可见的。\n全局变量\n定义在函数体外部的全局变量整个工程都可见，其他文件使用extern后可直接使用。所以说两个文件不能定义同名的全局变量，除非使用static。\n增加static后，该全局变量的作用域就会限制在该文件之内。\n函数\n在同一个工程中的不同文件中的函数可以直接相互调用，因为在链接的时候会被统一编译链接。对于static则和全局变量一样，使用static的函数只能在定义其的文件中可见。\n数据成员\n静态数据成员不隶属于任何对象，所有的对象都拥有同一份静态成员，在没用类对象的时候也可以进行操作，也遵顼public等访问规则。\n在访问静态数据成员时，访问方式如：\nobj.a=1或者MyClass::a=1\nobj为对象，MyClass为类类型\n\n相对于全局变量来说，静态成员不存在于其他全局名字冲突的可能性（显然类名已经做了区分）；同时，静态成员变量可以用private隐藏，而全局变量不能。\n成员函数\n静态成员函数同样不隶属于对象而是隶属于类，其特性是没有this指针（想想就明白了）\nC#中的新static\nC#中类也可以static，但是静态类的所有成员都必须也是静态的。\n&nbsp;\nextern\n如上，如果两个文件（同一工程）想互通全局变量，那么访问文件的使用全局变量需要加上extern关键字。\n有一个推荐的方法是文件A正常定义全局变量，然后在文件A中的h文件里加上extern该全局变量的声明，于是其他文件想使用就直接include就可以了——要知道include就是将代码“备份”进去。\nextern “C”\n它告诉编译器C++按照C方法进行函数名的处理，主要是因为C++支持函数重载而C不支持。\n例如C++中\nvoid A(int a);\nvoid A(int a,int b);\n这两个函数名相同，但在C++编译器中编译后函数名其实会变化，用来区分两个参数列表不同的重载函数。但C语言中没有这个机制，也就是说在处理这方面两种编译器的措施是不同的，所以在C++中使用C文件函数时要用extern{}来声明:\nextern{void A(int a);}\n假如A没有重载\n\n确保链接的时候不会发生错误。\n&nbsp;\n纯C语言实现面向对象\n纯C函数没有类说法，也没有对象说法，但其实也可以通过一些手段来模拟实现。\n\n结构体--&gt;模拟类。\n函数指针--&gt;在结构体中声明函数指针模拟类方法。\n封装--&gt;前两者实现封装，也就是数据和相关操作绑定在一起。\n继承--&gt;结构体中包含指向父类结构体的指针。\n多态--&gt;函数指针动态绑定来实现（在使用时变化函数指针的指向）。\n\n\n看起来太笨拙了不是吗？但你就说是不是面向对象嘛\n\n\n","categories":["做题笔记"]},{"title":"AVL树","url":"/2023/05/26/AVL%E6%A0%91/","content":"\n\n\n\n\n\n\n\nAVL树转化规则\n定义：\n平衡因子BF=Hl-Hr的值绝对值不超过1  \n\n\n高度差越高，查找所需要的平均查找长度就越长，所以要尽量避免高度差  \n\n\n在定义中加入高度属性    \n\nclass AVLNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;\n    private T data;\n    //左节点\n    private AVLNode&lt;T&gt; left;\n    //右节点\n    private AVLNode&lt;T&gt; right;\n    //当前节点的高度\n    private int height;\n&#125;\n\n\n计算高度  \n\nint height(AVLNode&lt;T&gt; node)&#123;\n    if (Objects.isNull(node)) &#123;\n        return 0;\n    &#125;\n    int rHeight = height(node.getRight());\n    int lHeight = height(node.getLeft());\n    return Math.max(rHeight, lHeight) + 1;\n&#125;\n\n\n\n即节点左右子树高度的最大值+1为树的高度  \n\n\n平衡调整\n插入分为以下四类：\n* ADF路径（RR插入）  \n* GDB路径（LL插入）\n* ADB路径（RL插入）\n* GDF路径（LR插入）  \n\nADF路径和GDB路径\n当插入节点与父节点的属性相同时  \n\n\n其实就是将中间节点提起来平衡  \n\nAVLNode&lt;T&gt; singleRightRotation(AVLNode&lt;T&gt; node) &#123;\n    AVLNode&lt;T&gt; result = node.getRight();\n    AVLNode&lt;T&gt; left = result.getLeft();\n    node.setRight(left);\n    result.setLeft(node);\n    return result;\n&#125;  \n\nAVLNode&lt;T&gt; singleLeftRotation(AVLNode&lt;T&gt; node) &#123;    AVLNode&lt;T&gt; result &#x3D; node.getLeft();    AVLNode&lt;T&gt; right &#x3D; result.getRight();    node.setLeft(right);    result.setRight(node);    return result;&#125;\nADB路径与GDF路径\n当插入节点与父节点的属性相反时\n先将插入节点放入父节点的父路径上，形成ll或者rr后再运用相应转化方法\n其实不是懒得放图  \n\nAVLNode&lt;T&gt; doubleRightLeftRotation(AVLNode&lt;T&gt; node)&#123;\n    AVLNode&lt;T&gt; right = singleLeftRotatio(node.getRight());\n    node.setRight(right);\n    return singleRightRotation(node);\n&#125;  \n\nAVLNode&lt;T&gt; doubleLeftRightRotation(AVLNode&lt;T&gt; node) &#123;    AVLNode&lt;T&gt; left &#x3D; singleRightRotation(node.getLeft());    node.setLeft(left);    return singleLeftRotation(node);&#125;\n删除节点时的平衡调整\n其实和二叉搜索树大同小异\n* 叶子节点直接删除\n* 包含一个子节点，将子节点替换到父节点\n* 包含两个，使用后继节点替换被删除节点，删除后续节点\n//代码和详细原理在数据结构复习中补//  \n\n\n参考： \n微信公众号——javascript艺术\n\n\n","categories":["数据结构与算法"]},{"title":"Booom2023复盘","url":"/2023/10/18/Booom2023%E5%A4%8D%E7%9B%98/","content":"\n\n\n\n\nBooom2023复盘\n\nBooom2023复盘\n首先是一些最基础的代码诀窍，这些方法几乎在任何游戏中都能使用，可以说是一位工程师“入门”级别的诀窍。\n&nbsp;\nObjectPool\n试想一下短时间内生成100个敌人的无双游戏？又或者是需要在造成伤害后跳出满屏幕的伤害数字？\n这个时候该怎么办，Instantiate预制体几乎是唯一的实现方式，这个时候可能要做的就是——短时间内Instantiate一百甚至一千多个预制体对象。\n但是这对Unity甚至你的电脑是一个毁灭性的打击，文件载入类型的操作要占用大量性能，无所作为地使用这种方式来初始化对象的前提是你的玩家并不在乎几乎永无休止的卡顿。\n对象池思想并不是用了“另一种初始化”的路子，他只是单纯地将对象的初始化全部放在了进入游戏场景的那一瞬间，也就是说把玩家在游玩过程中的卡顿“放”在了载入场景的时候，并将其”失活“，在实际需要的时候再将其“激活”。\n[SerializeField] private GameObject TestEnemy;\n[SerializeField] private int initMinEnemy = 100;//初始化的对象数量\nstatic ObjectPool instance;//一个游戏中的对象池往往只需要一个，所以设置为单例方便引用\nQueue&lt;GameObject&gt; queue = new Queue&lt;GameObject&gt;();//对象池中的对象用队列存起(也可以用栈或者其他)\nvoid Awake()&#123;\n    //Initialize()\n    for (int i = 0; i &lt; initMinEnemy; i++)\n    &#123;\n        GameObject tmp;\n        tmp = Instantiate(instance.TestEnemy);\n        tmp.SetActive(false);\n        queue.Enqueue(tmp);\n    &#125;\n    //\n&#125;\n\npublic static Gameobject GetObject()&#123;    if(instance.queue.Count&gt;0)&#123;        return instance.queue.Dequeue();    &#125;    else&#123;        GameObject tmp;        tmp &#x3D; Instantiate(instance.TestEnemy);        tmp.SetActive(false);    &#125;&#x2F;&#x2F;如果队列中不够，则直接重新初始化&#125;\npublic static void ReturnObject(GameObject deadEnemy)    &#123;        instance.queue.Enqueue(deadEnemy);    &#125;&#x2F;&#x2F;对象销毁的时候切勿销毁，请先归还回去——如果有条件可以多写“如队列满则直接销毁”\n这样一来一个基础的对象池就搭建完成了，当然，可以根据需要进行需求加持，例如需要生成不同种类的敌人时，需要使用不同的队列来进行存储，然后不同的队列又可以通过字典来存储。\n[SerializeField] private GameObject TestEnemy;\n[SerializeField] private GameObject Lost;\n...\nDictionary&lt;string, Queue&lt;GameObject&gt;&gt; poolingDict = new Dictionary&lt;string, Queue&lt;GameObject&gt;&gt;();\nvoid Initialize()&#123;\n...\n    foreach (CharacterData_SO.CharacterType characterType in Enum.GetValues(typeof(CharacterData_SO.CharacterType)))\n        &#123;\n            Queue&lt;GameObject&gt; tmp = new Queue&lt;GameObject&gt;();\n            for (int i = 0; i &lt; initMinEnemy; i++)\n            &#123;\n                tmp.Enqueue(CreateObject(characterType));\n            &#125;\n            poolingDict.Add(characterType.ToString(), tmp);\n        &#125;\n    foreach (BulletData_SO.Type bulletType in Enum.GetValues(typeof(BulletData_SO.Type)))\n        &#123;\n            Queue&lt;GameObject&gt; tmp = new Queue&lt;GameObject&gt;();\n            for (int i = 0; i &lt; initMinBullet; i++)\n            &#123;\n                tmp.Enqueue(CreateObject(bulletType));\n            &#125;\n            poolingDict.Add(bulletType.ToString(), tmp);\n        &#125;\n...\n&#125;\n\nprivate static GameObject CreateObject&lt;T&gt;(T type)&#123;    GameObject tmp;    switch (type)    &#123;        default:        case CharacterData_SO.CharacterType.Monster:            tmp &#x3D; Instantiate(instance.TestEnemy);            break;        case CharacterData_SO.CharacterType.Lost:            tmp &#x3D; Instantiate(instance.Lost);            break;    &#125;    tmp.transform.parent &#x3D; instance.transform;    tmp.SetActive(false);    return tmp;&#125;…\n对象池可容纳的只有敌人吗？掉落在地上的道具、子弹的攻击特效、甚至NPC本身都可以是对象池的容纳品，只要是需要进行“实例化”的操作，都可以放入对象池进行优化，然后统一在加载界面进行归一管理。\n&nbsp;\n异步的加载界面\n前面提到过将所有“实例化”都推到场景加载界面，那么你会如何进行场景加载呢，是类似MC直接将对象一个个实例化摆在玩家面前（实际上MC对象的实例化在加载界面中而地图的加载才是直接进行的）？还是给出一个黑幕不动的图片？\n大部分游戏的解决办法是显示上给出加载界面，后台进行场景的加载，这里我的方案是进行加载场景的加载，然后异步进行“真场景”的加载，以此来进行过渡。\nprivate static SceneManager instance;//建议单独编写场景管理脚本单例\npublic static SceneManager Instance\n&#123;\n    get\n    &#123;\n        if (instance == null)\n        &#123;\n            instance = FindObjectOfType&lt;SceneManager&gt;();\n            if (instance == null)\n            &#123;\n                GameObject manager = new GameObject(&quot;SceneManager&quot;);\n                instance = manager.AddComponent&lt;SceneManager&gt;();\n            &#125;\n        &#125;\n        return instance;\n    &#125;\n&#125;//这一段其实不必理会。。。\n\npublic void LoadScene(string sceneName)&#123;    UnityEngine.SceneManagement.SceneManager.LoadScene(sceneName);&#125;&#x2F;&#x2F;正常的场景切换\npublic float minimumLoadingTime &#x3D; 2f;public string sceneName; &#x2F;&#x2F; 要加载的场景名称\npublic void LoadSceneAsync()&#123;    StartCoroutine(LoadSceneAsyncCoroutine());&#125;\nprivate IEnumerator LoadSceneAsyncCoroutine()&#123;    float startTime &#x3D; Time.time;    &#x2F;&#x2F; 异步加载目标场景    AsyncOperation asyncOperation &#x3D; UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(sceneName);    yield return new WaitForSeconds(minimumLoadingTime);    &#x2F;&#x2F; 等待加载完成   while (!asyncOperation.isDone)   &#123;        yield return null;   &#125;&#125;&#x2F;&#x2F;同时动用了协程，这里之后马上就要讲到\nprivate void Awake()&#123;   if (instance &#x3D;&#x3D; null)   &#123;       instance &#x3D; this;       DontDestroyOnLoad(gameObject);   &#125;   else   &#123;       Destroy(gameObject);   &#125;&#125;&#x2F;&#x2F;场景管理器不要随着场景变换而消失，这一点比对象池更严格\n&nbsp;\n\n场景管理器打包了异步变化场景的所有方法，在其他任何地方可以直接调用函数来进行场景切换\n\n\n在其他任何想要进行场景切换的地方如下编写：\nSceneManager.Instance.LoadScene(&quot;Pass&quot;);//“Pass”为过渡场景的名字\nSceneManager.Instance.sceneName = &quot;main&quot;;//“main”改为目的真场景\nSceneManager.Instance.LoadSceneAsync();\n\n当然可以根据个人码风进行合理魔改。\n\nminimumLoadingTime设置了最低加载时间，特别是小体量的场景，异步的真场景会被瞬间加载完成\n\n\n这也是使用协程的目的之一，试想游戏加载过程中会不会出现先加载好的角色可以移动，但加载动画还在进行、加载太快导致加载动画一瞬间就结束了。\nyield return new WaitForSeconds(minimumLoadingTime);暂停协程，给玩家一个加载过程的展示时间\n\n&nbsp;\n协程\nUnity为了降低门槛，设计之初就是单线程工作。所以Unity并没有为多线程操作提供过多的API。\n与之相反，Unity提供了协程来模仿多线程以实现异步操作，本质上其实还是单线程。\n也不是不能用多线程，但是使用多线程已经和unity关系不大，这里的多线程已经是C#的本质特性了。\n和本次booom关系更不大，但是协程的应用场景还是非常多的。\n&nbsp;\nIEnumerator\n协程是通过迭代器来实现的，IEnumerator用来定义一个迭代方法。\nStartCoroutine（string methodName）//无参数的情况\nStartCoroutine（IEnumerator routine）//通过方法形式调用\nStartCoroutine（string methodName，object values)//带参数的通过方法名进行调用\nStopCoroutine（string methodName）//通过方法名（字符串）来进行\nStopCoroutine（IEnumerator routine）//通过方法形式来调用\nStopCoroutine（Coroutine routine）//通过指定的协程来关闭\n\n&nbsp;\nyield\n一个语法糖，也是Unity生命周期的一些执行方法。\nyield return null; //暂停协程等待下一帧继续执行\nyield return 0//或其他数字; //暂停协程等待下一帧继续执行\nyield return new WairForSeconds(时间); //等待规定时间后继续执行\nyield return StartCoroutine(&quot;协程方法名&quot;);//开启一个协程（嵌套协程)\n\n以上执行顺序位于Update与LateUpdate之间\nyield return GameObject; //当游戏对象被获取到之后执行\nyield return new WaitForFixedUpdate();//等到下一个固定帧数更新\nyield return new WaitForEndOfFrame();//等到所有相机画面被渲染完毕后更新\nyield break; //跳出协程对应方法，其后面的代码不会被执行\n\n&nbsp;\n协程用简单的话说，就是“将这一帧来不及完成的任务，交给下一帧进行”，例如下面的代码：\npublic List&lt;int&gt;nums = new List&lt;int&gt;&#123;1,2,3,4,5&#125;;\nprivate void Start()\n&#123;\n    StartCoroutine(PrintNum(nums));\n&#125;\n//通过协程分帧处理\nIEnumerator PrintNum(List&lt;int&gt; nums)\n&#123;\n    foreach(int i in nums)\n    &#123;\n        Debug.Log(i);\n        yield return null;         \n    &#125;\n&#125;\n\n\nyield return null的目的就是读取完一个数之后缓一帧\n\n\n&nbsp;\n这样一来，理解上面的异步加载场景就十分简单了，协程最主要的作用，其实就是控制“场景在加载完之前不进行跳转”，而且更方便设置“最小加载时间”。\n&nbsp;\n协程实现的文字淡入淡出\n协程一般用于优化进程，减少卡顿协助处理，这里的淡入淡出功能也可以单纯使用计数器来完成，但使用协程更方便些。\npublic class TextFade : MonoBehaviour\n&#123;\n    [SerializeField] private HunterWhatSay _say;\n    public Text textComponent;\n    public float fadeInDuration = 1f;\n    public float fadeOutDuration = 1f;\n    public void StartText()\n    &#123;\n        RandomArr(_say._str);\n        textComponent.text = _say._str[0];\n        textComponent.gameObject.SetActive(true);\n        StartCoroutine(FadeInAndOut());\n    &#125;\n\npublic void EndText()\n&#123;\n    StopCoroutine(FadeInAndOut());\n    textComponent.gameObject.SetActive(false);\n&#125;\n\npublic void Endtext()\n&#123;\n    textComponent.gameObject.SetActive(false);\n&#125;\n\nprivate System.Collections.IEnumerator FadeInAndOut()\n&#123;\n    Color originalColor = textComponent.color;\n    Color transparentColor = new Color(originalColor.r, originalColor.g, originalColor.b, 0f);\n    //淡入\n    float t = 0f;\n    while (t &amp;lt; fadeInDuration)\n    &#123;\n        t += Time.deltaTime;\n        float normalizedTime = t / fadeInDuration;\n        textComponent.color = Color.Lerp(transparentColor, originalColor, normalizedTime);\n        yield return null;\n    &#125;\n\n    yield return new WaitForSeconds(2f);\n    //淡出\n    t = 0f;\n    while (t &amp;lt; fadeOutDuration)\n    &#123;\n        t += Time.deltaTime;\n        float normalizedTime = t / fadeOutDuration;\n        textComponent.color = Color.Lerp(originalColor, transparentColor, normalizedTime);\n        yield return null;\n    &#125;\n\n    textComponent.gameObject.SetActive(false);\n&#125;\n\nstatic void RandomArr&amp;lt;T&amp;gt;(T[] arr)\n&#123;\n    System.Random r = new System.Random();\n    for (int i = 0; i &amp;lt; arr.Length; i++)\n    &#123;\n        int index = r.Next(arr.Length);\n        T temp = arr[i];\n        arr[i] = arr[index];\n        arr[index] = temp;\n    &#125;\n&#125;\n\n}\n\n可以看出协程很方便地完成了“在一定时间内淡入”、“静止一定时间后开始淡出”、“在一定时间内淡出”三个功能，而且这些功能不影响主线程的工作。\n\n\n&nbsp;\n跟随Object的文字\n总所周知Unity的UGUI与世界用的不是一套坐标系。\n所以理论上UGUI中的所有组件在世界中都无法展示。\n唯一实现动态文字跟随的办法就是在UI中打出文字，并让他强行跟随世界坐标人物。\n用我们的眼睛看很简单，但在程序中略微麻烦，需要进行一套坐标转换。可以直接使用下面的脚本：\nusing UnityEngine;\nusing System.Collections;\npublic class HandUI : MonoBehaviour\n&#123;\n    public Transform Hand;//文字对应的物体\n    private void Update()\n    &#123;\n        Vector3 pos = new Vector3();\n        pos = Camera.main.WorldToScreenPoint(Hand.position);\n        transform.position = pos;\n    &#125;\n&#125;\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n","tags":["Unity基础概念"]},{"title":"C++STL","url":"/2023/12/14/C-STL/","content":"\n\n\n\nC++STL\n\n\n之前初见C++的时候总结的string就是C++STL（标准模板库）中的一种容器，现在在有从string的基础上继续深入了解其他STL。\nSTL的六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器\n&nbsp;\n容器\n基础数据结构：数组(array) , 链表(list), 树(tree)，栈(stack), 队列(queue), 集合(set),映射表(map)\n延申数据结构：字符串(string)，向量(vector)，可重复集合(multiset)，可重复映射表(multiset)、非自动排列集合(unordered_set)、非自动排列映射表(unordered_map)……\n也可以按这样分类：序列式容器、关联式容器、无序关联式容器、容器适配器\n&nbsp;\n序列式容器\n指按照元素插入的顺序进行存储和访问，可以保持元素的插入顺序并按照顺序进行迭代访问\n注意这个和迭代器没有关系，array、vector、deque都是使用随机访问迭代器，可以实现随机访问，而list是使用双向迭代器，forward_list是使用单向迭代器\n\n&nbsp;\narray\n其实就是C++的普通数组，不过添加了一些成员函数和全局函数，比普通数组更安全\n对于array的操作，可以沿用C中数组的操作\nstd::array&lt;double,10&gt; value &#123;0.5,1.0,1.5,2.0&#125;;\nC中常规数组初始化，剩下的元素为0，可见array元素在初始化的时候已经固定了（官话：元素中未初始化的值不确定）\n\n当然也可以\nstd::array&lt;double,10&gt; values &#123;&#125;\n所有元素初始化为0或者和默认元素类型等效的值\n\n&nbsp;\narray和一般的STL一样配备了一系列迭代器与成员函数，其中at(n)成员函数返回函数元素值引用，n是下值，此外会检查是否在有效返回内，错误抛出异常，所以说array比普通数组更安全。\n一些操作：\nmax_size()返回容器可容纳的元素最大值，在array中一般和size()一致，不过在vector中会变成一个非常大的值\nfront()返回第一个值引用\nback()返回最后一个值引用\ndata()返回一个指向容器的指针\nfill(val)让容器每个值都变成val\n&nbsp;\nvector\n可以理解成大小可变的数组，数组的变化采用特定的成员函数\n\nvector v1\tv1 是一个元素类型为 T 的空 vector\nvector v2(v1)\t使用 v2 中所有元素初始化 v1\nvector v2 = v1\t同上\nvector v3(n, val)\tv3 中包含了 n 个值为 val 的元素\nvector v4(n)\tv3 中包含了 n 个默认值初始化的元素\nvector v5{a, b, c...}\t使用 a, b, c... 初始化 v5\nvector v1\t同上\nvector&lt;vector&gt; matrix(M,vector(N));\n&nbsp;\nv.push_back(val)往尾端添加val\nv.emplace_back(val)往尾端添加val\n使用大型对象或者代价较高的构造函数时使用emplace_back()因为这个函数不需要拷贝临时对象，他是直接借助参数的值，在容器中直接创建新对象\n\nv.pop_back()删除尾部元素\n常用以迭代器方式插入、替换、删除类似string\n\nv.sort()以升序排序\nsort(v.begin(),v.end())\n\nunique()将容器相邻的重复元素消除并返回不重复值范围末尾的迭代器\nunique(v.begin(),v.end())不会改变原容器大小，消除之后尾部多出来空间不会被删除，所以要手动删除\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n \nint main(void)&#123;    vector&lt;int&gt; a&#123;2, 0, 2, 2, 0, 3, 0, 9&#125;;    sort(a.begin(), a.end());  &#x2F;&#x2F; 先排序    for(int i:a)   cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#x2F;&#x2F; 输出    cout &lt;&lt; endl;    auto end_unique &#x3D; unique(a.begin(), a.end());  &#x2F;&#x2F;将输入序列相邻的重复项“消除”，返回一个指向不重复值范围末尾的迭代器    a.erase(end_unique, a.end()); &#x2F;&#x2F; 删除末尾元素    for(int i:a)   cout &lt;&lt; i &lt;&lt; &quot; &quot;; &#x2F;&#x2F; 输出    return 0;&#125;&#x2F;&#x2F; 运行结果 &#x2F;&#x2F;0 0 0 2 2 2 3 90 2 3 9\n来自CSDN@地球被支点撬走啦\n\n\nresize(n,t)改变容器大小并赋值为t（新添加）\n\n\nVector的扩容\n\n完全放弃原有的容器空间\n创建新的更大的容器空间\n将原有空间中的数据迁移到新空间\n将旧空间释放\n\n\n一般会扩容capasity&gt;=size，在vs中为1.5倍，在linux中为2倍。\n空间大小有什么讲究呢？首先不能太大，可能造成空间浪费，也不能太小，太小会导致扩容频繁。\n总而言之扩容总是不好的，容易造成运行效率低下，所以避免扩容的方式就是在构造的时候直接进行预估个数大小，或者在插入之前直接进行reserve。\nQ1：为什么成倍数扩容？\nA1：指定大小扩容时间复杂度为O(n)，倍数大小扩容时间复杂度近似O(1)。例如大小10扩容到100，如果指定每次扩容10大小，那么要扩容9次；如果以2倍倍数扩容，则第一次扩容扩到20，第二次扩到40，也就是说扩容之后的算法是以指数形式增长的。\nQ2：为什么要是1.5倍？\nA2：为了每次扩容的时候能用上原本被释放的空间。vector每次扩容时的机制是找到新的符合要求的内存，还会将原本的空间释放，这个时候如果在多次扩容的时候能用上原本的空间是最好的。例如1空间进行多次扩容，那么会找1.5的新空间，第二次会找2.25的新空间，第三次会找3.375新空间，第四次是5.0625，这个时候会已经释放的空间加起来有4.75，于是再进行几次扩容就可以重复利用之前的空间。如果是两倍则永远都用不上。\n&nbsp;\nlist（forward_list为单向链表）\n与我们常用的手写链表不同，这是一个双向链表容器\n\n用法和vector差不太多，但底层实现逻辑是双向链表而不是数组\n区别和C语言中的链表数组区别差不太多：\n\n存储空间连续与不连续\n\n查找方便与不方便（支不支持随机访问）\n\n添加删除方便与不方便\n\n（额外）可以说vector扩容的时候会拷贝数据，而list不会。\n&nbsp;\n\n\n\ndeque\n双端队列，基础创建方式仍然和vector类似，顺序性容器\n\n在首部与尾部增添或者删除元素，可以根据需要修改自身的容量和大小，但是不能保证所有的元素都存储在连续的内存空间中。\ndeque与vector一样支持随机访问，但与vector不同的是存储的内存是分块的，每次新增内存会新增内存块，同样维护了指向这些内存块的指针（第一个和最后一个与当前活跃的）。\n\nlist与deque新增push_front()\n\n\ndeque的扩容\ndeque的底层包含map映射区与数据区，首先数据区就是要存数据的数组，其次这个map和后面要说的”关联式容器map“并不是一个东西，虽然名字都是映射。\n数据区和vector中的数据区虽然是一个东西，但不一样的是deque中的数据区一般固定为512个字节，这一块”初始“数据区的地址就映射在映射区上，如果需要扩容，就会直接new/malloc新的数据区出来，然后在map上增加地址数据。\ndeque中含有pfront和ptail两个指针分别指向头和尾，而在初始阶段这两个指针默认指向数据区中心，然后向两边移动。\n除此之外，map映射区也得遵循这样的规定，毕竟双端队列deque虽然存储空间有可能不连续，但寻址逻辑一定要是连续的，大致是这样的：\n\n如图map就相当于寻址的”地图“，把不连续的内存段连起来。\n那么具体的扩容是怎样扩容的呢？首先deque的扩容不仅是数据段的扩容，还包括map的扩容。\n\n当两个指针达到他们当前数据段的极限时，比如pfront到达还要往前第0位，那么就触发扩容，这个时候新增一段数据区是必然的。\n然后再看map映射区，会先检查映射区里面有没有空间存数据区的地址，比如如果当然数据区地址再映射区是第1位，那么往前就是存进第0位。\n如果往前没有找到，那么pfront会直接跳到map的尾部，也就是1以及之后的区寻找有没有空间。如果找到了空间，那么整个数据区存在map区的地址就会整体往后移动一个映射区单位，这样第0区就空出来了。这一点对于ptail也是一样的，如果尾部没有就会往前找，总之会先优先寻找已有的空间。\n如果往前往后都找不到空的map坑位了，这个时候就会触发map映射区的扩容，这个时候map区的扩容是以2倍数扩容的，扩容后01变成0123，并且地址会往中心移动，也就是说现在变成了12位存有地址。\n\n\n&nbsp;\n关联式容器\n指带有键值的容器，底层由黑红树实现，会根据键值来自动按照某种规矩排序，不能由程序员来改变。\n如果说vector封装了数组，list封装了链表，那么关联式容器里运用最广泛的set和map就是封装了二叉树。\nQ：为什么说关联式容器插入删除效率比用其他序列容器高？\nA：因为关联容器只涉及指针变动，不涉及内存拷贝或者内存移动；此外黑红树的查找效率非常高，这点比顺序性容器中的list优势很多。\nQ：关联性容器的数据增添效率问题？\nA：这个考虑黑红树树高就能想到了。\n初识黑红树 | Coding中。。。 (jiuriri.com)\n&nbsp;\nset\n即集合，常见关联式容器中不带Value值的\n\n元素插入时不可重复插入，即集合互异性，并默认按照升序排序。\nset的设计目的是唯一性和有序性，其键值不能修改，因为黑红树根据键来排序，如果可以随意更改，那么该元素在黑红树中的位置就会不稳定。\n常见的做法是先删除，再添加。\n&nbsp;\nmutliset\n多重集合，可以存储相同的集合数据，并且相同的数据数量做Value值\n\n除了可以重复插入，其他性质和set一致。\n此外还有unordered_set做无序的集合\n&nbsp;\nunordered_map\n无序映射，也就是哈希表的一种实现方式，在算法中常用（也就是说有序映射就是是map，排序规则和set一样）\n\nunordered_map一次性存两个值，一个是key，一个是value，可以通过key来以O(1)的速度查询value，原理是用把key当作哈希函数参数，然后计算出来的地址就是要找的地址，如果发生哈希冲突，则可以通过链地址法或者开放地址法来找新的地址。当然，各种寻找新地址的算法也是一门学问。从效果上看，相当于将普通数组中的（1、2、3...）替换成key值。\n另外，使用迭代器时，it-&gt;first表示key，it-&gt;secend表示value\n可以使用std::pair来进行键值插入，也可以使用C++11新引入的花括号进行插入，不过我最常用的还是直接使用下标进行插入。\n#include &lt;iostream&gt;\n#include &lt;map&gt;\nint main() &#123;\n    std::map&lt;int, std::string&gt; myMap;\n    // 使用 std::pair 插入元素\n    myMap.insert(std::pair&lt;int, std::string&gt;(1, &quot;one&quot;));\n    // 使用花括号初始化列表插入元素\n    myMap.insert(&#123;2, &quot;two&quot;&#125;);\n    //下标插入\n    myMap[3]=&quot;three&quot;;\n    // 打印 map 中的元素\n    for (const auto&amp; elem : myMap) &#123;\n        std::cout &lt;&lt; elem.first &lt;&lt; &quot;: &quot; &lt;&lt; elem.second &lt;&lt; std::endl;\n    &#125;\n    //C++17中的结构化绑定\n    for (auto [x,y] : myMap) &#123;\n        std::cout &lt;&lt; x &lt;&lt; &quot;: &quot; &lt;&lt; y &lt;&lt; std::endl;\n    &#125;\n    return 0;\n&#125;\n\n注意multimap由于可以多重关键字，所以不允许用下标访问\n\n&nbsp;\n容器适配器\n对底层容器进行封装，以完成一些特定的需要的功能，比如常见的堆栈队列。\n\nstack——栈（底层可以是任何迭代器，但默认是deque）\n\n\nstack&lt;string, vector&gt;这样子就变成vector了\n\n\nqueue——队列（底层默认也为deque）\npirority_queue——堆（优先队列，底层默认为vector）\n\n\n堆基础 | Coding中。。。 (jiuriri.com)\n由于使用的实在太多，就不进行详细介绍了，接下来进行知识补充。\n&nbsp;\n队列和双端队列\n众所周知队列和栈都是不能遍历的，但双端队列却可以用迭代器遍历，虽然效率很低。\n我的理解是队列和栈作为容器适配器是一种规定，如果要遍历，就不要使用他们，或者直接一个个将所有元素pop再重新push进去。而双端队列偏底层，所以一般的操作都是可以的。\n&nbsp;\n迭代器失效问题\n除了容器适配器，其他容器都是配置了迭代器的，例如顺序性容器除list之外都是随机访问迭代器，而list本身和关联性容器是双向迭代器。如果在迭代过程中发生了结构变化，那么也就是说这个迭代器过期了，这个迭代器只适用于旧容器。过期的迭代器有可能发生迭代器失效，这样很容易访问到不确定的内容。\n迭代器失效的问题大致可以分为以下几类：\n\n插入导致失效\n删除导致失效\n容器重新分配内存导致失效\n容器的修改导致失效\n\n\n所以可以推断在vector中，如果对某结点erase，则当前结点以及之后结点的迭代器失效，因为vector容器位置是相邻的，删除一个元素后面的会挤上来。push_back一个元素，首先end()失效，然后如果没有进行空间分配，则push之前的元素迭代器还有效，如果进行了空间分配，则所有的迭代器都失效。\ninsert和erase的返回值可以返回下一个迭代器，所以返回给迭代器就行。\nvector&lt;int&gt; cont;\nfor (auto iter = cont.begin(); iter != cont.end();)\n&#123;\n   (*it)-&gt;doSomething();\n   if (shouldDelete(*iter))\n      iter = cont.erase(iter);  //erase删除元素，返回下一个迭代器\n   else\n      ++iter;\n&#125;\n\ndeque迭代器首位之外的位置进行插入删除操作就会导致所有迭代器失效，而在首尾进行操作则只会使这两个地方的迭代器失效。\nlist这种容器只会使被删除的迭代器失效，不会影响其他迭代器，解决方法同样是返回有效迭代器就行。\n关联式容器的迭代器原理和list一样，但是区别是erase只会返回void，所以要使用erase(it++)进行迭代，或者直接记录要被删除的结点，在删除之前将迭代器自然迭代在将其删除。\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++11知识点","url":"/2025/03/11/C-11%E7%9F%A5%E8%AF%86%E7%82%B9/","content":"\n\n\n\n\nC++11知识点\n\nC++11知识点\nconst和constexpr\n前者修饰常量，后者修饰常量表达式\n区别在于前者只是表达只读语义，保证运行时不被修改，但是其修饰的遍历本身仍然可能是个动态变量，而后者所修饰的是真正的常量，会保证在编译期间就计算出来。\n\n\n特性constconstexpr\n计算阶段运行时编译时初始化要求可运行时初始化必须编译期确定函数修饰不能修饰函数可修饰函数内存分配可能需要存储空间可能仅存在于编译期符号表\n\nconstexpr修饰函数：只能修饰单语句return的函数，相当于修饰其返回值，这类函数在被调用的时候其返回值会尽可能在编译期确定\n#include&lt;iostream&gt;\nusing namespace std;\n\nconstexpr int func(int i) &#123;    return i + 1;&#125;\nint main() &#123;    int i &#x3D; 2;    func(i);&#x2F;&#x2F; 普通函数    func(2);&#x2F;&#x2F; 编译期间就会被计算出来&#125;\n\n&nbsp;\nfunction类与反射实现\nfunction\n顾名思义，std::function就是用来存储函数的，专业名词称为“多态函数包装器”，可以复制和存储任意可调用的目标：函数、lambda表达式、绑定表达式、指向成员函数和指向数据成员的指针等等。\t\n用法：class function&lt;R(Args...)&gt;\nR为函数返回类型、Args为调用函数的形参。\nC++简单反射实现：\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;functional&gt;\nclass Reflector&#123;\npublic:\n    template&lt;typename Function&gt;\n    static void registerFunc(const std::string&amp; name,Function func)&#123;\n        getRegistery()[name] = func;\n    &#125;\n    static bool invoke(const str::string&amp; name)&#123;\n        auto&amp; registry = getRegistry();\n        if(registry.find(name)!=registry.end())&#123;\n            registry[name]();\n            return true;\n        &#125;\n        return false;\n    &#125;\nprivate:\n    //全局注册表，用static做线程安全单例\n    static auto&amp; getRegistry()&#123;\n        static std::unordere_map&lt;std::string,std::function&lt;void()&gt;&gt; registry;\n        return registry;\n    &#125;\n&#125;\n\nvoid solve() &#123;&#125;\nint main()&#123;    Reflector::registerFunc(&quot;solve&quot;,solve);    Reflector::invoke(&quot;solve&quot;);&#125;\n函数对象，即仿函数\n\n&nbsp;\nexplicit\n用于修饰有参构造函数，表明此构造函数是显式而非隐式的\n\n禁止对象间的隐式转换\n禁止隐式调用拷贝构造函数\n\n\n例如：\nclass Obj&#123;\n    Obj()&#123;&#125;\n    explicit Obj(int val):_val(val)&#123;&#125;\nprivate:\n    int _val;    \n&#125;\n\nint main()&#123;    Obj obj1(1);    Obj obj2 &#x3D; 1;&#x2F;&#x2F;这种方法在有参构造函数被explicit修饰后会报错，因为其中涉及到构造临时对象1、拷贝临时对象到对象obj2两步骤&#125;\n&nbsp;\ndelete\n//略\n&nbsp;\ndefault\n显式声明默认构造函数\n&nbsp;\nfinal &amp; override\nfinal用于修饰一个类，表示该类禁止进一步派生\noverride用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果用override声明了函数但是父类没有对应虚函数则报错。\n&nbsp;\nnullptr\n//略\n&nbsp;\n继承构造函数\n即子类继承父类的构造函数。\nstruct Base &#123;\n    Base() &#123;&#125;\n    Base(int a) &#123; a_ = a; &#125;\n    Base(int a, int b) : Base(a) &#123; b_ = b; &#125;\n    Base(int a, int b, int c) : Base(a, b) &#123; c_ = c; &#125;\n\nint a_;\nint b_;\nint c_;\n\n};\nstruct Derived : Base {    using Base::Base;};\n&nbsp;\n委托构造函数\n同一个类中一个构造函数调用另一个构造函数：\nstruct A &#123;\n    A()&#123;&#125;\n    A(int a) &#123; a_ = a; &#125;\n    A(int a, int b) : A(a) &#123; b_ = b; &#125;\n    A(int a, int b, int c) : A(a, b) &#123; c_ = c; &#125;\n    \nint a_;\nint b_;\nint c_;\n\n};\n&nbsp;\n并发\n//略\n&nbsp;\nbind\nbind返回一个函数对象，可以放进Funtion类对象中\n//以下两种分别代表了bind的两种重载（函数和成员函数）\n\ndouble callableFunc (double x, double y) &#123;return x&#x2F;y;&#125;auto NewCallable &#x3D; std::bind (callableFunc, std::placeholders::_1,2);  \n&#x2F;&#x2F;\nclass Base&#123;public:    void display_sum(int a1, int a2)    &#123;        std::cout &lt;&lt; a1 + a2 &lt;&lt; &#39;\\n&#39;;    &#125;\nint m_data = 30;\n\n};int main(){    Base base;    auto newiFunc &#x3D; std::bind(&amp;Base::display_sum, &amp;base, 100, std::placeholders::_1);    newiFunc(20); &#x2F;&#x2F; should out put 120.}\n&nbsp;\n列表初始化\n//略\n&nbsp;\n左值右值\n//略\n&nbsp;\nauto &amp; decltype\nauto类型即编译器来编译期就推导出来的类型，用于推导变量类型\ndecltype用于推导表达式类型\nauto a = 10;\nconst int&amp; i = 1;\nint a = 2;\ndecltype(i) b = 2;\n\n&nbsp;\nenum class\n带作用域的枚举。\n原来的枚举是自动转换成整型的，所以不同枚举之间可以进行比较，例如枚举A的第一个值和枚举B的第一个值相等，容易出现隐性bug。\n使用带作用域的枚举，不同枚举之间比较会出现编译错误。而且此枚举可以手动选择底层类型。\n&nbsp;\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++中的多线程","url":"/2023/10/07/C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"\n\n\n\nC++中的多线程\n\n 如果对进程线程了解尚未深刻，那么可以先查看（进程与线程 | Coding中。。。 (jiuriri.com)）并查阅一定的资料后，再一起学习C++11中多线程的新特性\n\n\nC++中的多线程\nstd::thread\nC++11中新标准库多出来的东西，先介绍基础用法\nthread()：默认构造函数创建线程，括号内加函数名与变量表示线程执行的内容\nthread(solve,100)执行solve(100)函数\n\njoin()：等待线程完成并将其内存释放，进行这一语句期间会将主进程堵塞\ndetach()：不等待线程完成，直接将其内存释放\n每一个线程必须绑定join或者detach，不然引发异常 \n#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing namespace std;\nvoid countnumber(int id, unsigned int n) &#123;\n    for (unsigned int i = 1; i &lt;= n; i++);\n    cout &lt;&lt; &quot;Thread &quot; &lt;&lt; id &lt;&lt; &quot; finished!&quot; &lt;&lt; endl;\n&#125;\nint main() &#123;\n    thread th[10];\n    for (int i = 0; i &lt; 10; i++)\n        th[i] = thread(countnumber, i, 100000000);\n    for (int i = 0; i &lt; 10; i++)\n        th[i].join();\n    return 0;\n&#125;\n\n参考：C++11 多线程（std::thread）详解_c++ 线程-CSDN博客\n\n程序创建了十个线程，加入了for (unsigned int i = 1; i &lt;= n; i++);这样一个空循环，这样一个长空循环远远拉大了每一个线程的执行时间（不然结果会因为线程异步而变得十分混乱），异步操作执行时不一定会按照一定的顺序。\n多线程的进行必定具有多线程数据操作的效果，也就是说thread从结果上看是传引用而不是传参数，从源代码上看就是如此。\ntemplate &lt;class Fn, class... Args&gt;\nexplicit thread(Fn&amp;&amp; fn, Args&amp;&amp;... args)\n使用右值引用使得不同线程在同时操作一个数据的时候会实时更新数据，而不是纯粹对传过去的数据副本进行操作，所以说以下程序会报错：\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing namespace std;\ntemplate&lt;class T&gt; void changevalue(T &amp;x, T val) &#123;\n    x = val;\n&#125;\nint main() &#123;\n    thread th[100];\n    int nums[100];\n    for (int i = 0; i &lt; 100; i++)\n        th[i] = thread(changevalue&lt;int&gt;, nums[i], i+1);\n    for (int i = 0; i &lt; 100; i++) &#123;\n        th[i].join();\n        cout &lt;&lt; nums[i] &lt;&lt; endl;\n    &#125;\n    return 0;\n&#125;\n\n\n将th[i] = thread(changevalue&lt;int&gt;, nums[i], i+1);\n改为th[i] = thread(changevalue&lt;int&gt;, ref(nums[i]), i+1);问题解决\n&nbsp;\nstd::atomic和std::mutex\n尽管用到了右值引用，但多个线程同时操作同一个数据的结果并不理想，如下：\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\nusing namespace std;\nint n = 0;\nvoid count10000() &#123;\n    for (int i = 1; i &lt;= 10000; i++)\n        n++;\n&#125;\nint main() &#123;\n    thread th[100];\n    for (thread &amp;x : th)\n        x = thread(count10000);\n    for (thread &amp;x : th)\n        x.join();\n    cout &lt;&lt; n &lt;&lt; endl;\n    return 0;\n&#125;\n\n理想状态下，100个线程n++10000次的结果应该是1000000，但结果总是缺斤少两。\n具体原理并不追究，总之多线程同时进行操作总会出现一些操作丢失的问题。\nstd::mutex是 C++11 中最基本的互斥量，一个线程将mutex锁住时，其它的线程就不能操作mutex，直到这个线程将mutex解锁。\nmutex mtx;\nvoid count10000() &#123;\n    for (int i = 1; i &lt;= 10000; i++) &#123;\n        mtx.lock();\n        n++;\n        mtx.unlock();\n    &#125;\n&#125;\n\n但是这样的处理方式有点慢，就好比地铁站的安检口，增加安全性的同时减缓了乘客步伐。\nstd::atomic在多线程重点 用法一般是将操作对象设置为atomic的操作对象，而atomic是原子操作，也就是说atomic必须被同步操作，这样的话借助原子操作可以避免反复进行上锁开锁操作，相当于安检口还是那个安检口，但这次乘客自觉安检而不需要安保人员干预，效率当然快很多\n&nbsp;\nstd::async\n定义在future头文件中\n\n是一个函数而不是类，用于更加方便地创建进程\nasync(solve,100)即在新的线程中运行solve(100)\nasync(launch::async,solve,100)表示异步启动线程，如果参数换为launch::deferred则与future::get,future::wait同步启动，如果是launch::async | launch::defereed则根据操作系统定（默认也是这个）\n&nbsp;\nstd::future\n创建的线程函数有时候存在返回值，这个时候用future类将其捕获\n#include &lt;iostream&gt;\n// #include &lt;thread&gt; // 这里我们用async创建线程\n#include &lt;future&gt; // std::async std::future\nusing namespace std;\n\ntemplate&lt;class … Args&gt; decltype(auto) sum(Args&amp;&amp;… args) &#123;    &#x2F;&#x2F; C++17折叠表达式    &#x2F;&#x2F; &quot;0 +&quot;避免空参数包错误    return (0 + … + args);&#125;\nint main() &#123;    &#x2F;&#x2F; 注：这里不能只写函数名sum，必须带模板参数    future&lt;int&gt; val &#x3D; async(launch::async, sum&lt;int, int, int&gt;, 1, 10, 100);    &#x2F;&#x2F; future::get() 阻塞等待线程结束并获得返回值    cout &lt;&lt; val.get() &lt;&lt; endl;    return 0;&#125;\n\nget()等待线程结束并获取返回值\nwait()等待线程结束\n\n\n据说哪怕返回值是void也最好使用future，因为future还可以检测线程是否已经结束、阻塞等待。\n从别人那偷的测定应用程序加载时间的代码\n// Compiler: MSVC 19.29.30038.1\n// C++ Standard: C++17\n#include &lt;iostream&gt;\n#include &lt;future&gt;\nusing namespace std;\nvoid count_big_number() &#123;\n    // C++14标准中，可以在数字中间加上单\n    // 引号 &#39; 来分隔数字，使其可读性更强\n    for (int i = 0; i &lt;= 10&#39;0000&#39;0000; i++);\n&#125;\nint main() &#123;\n    future&lt;void&gt; fut = async(launch::async, count_big_number);\n    cout &lt;&lt; &quot;Please wait&quot; &lt;&lt; flush;\n    // 每次等待1秒\n    while (fut.wait_for(chrono::seconds(1)) != future_status::ready)\n        cout &lt;&lt; &#39;.&#39; &lt;&lt; flush;\n    cout &lt;&lt; endl &lt;&lt; &quot;Finished!&quot; &lt;&lt; endl;\n    return 0;\n&#125;\n\n&nbsp;\nstd::promise\nthread创造出来的线程是获取不了返回值的，甚至join()都是void类型，只能通过传递引用的方式来获取返回值。\n这个很像一个函数需要获取多个返回值的情况，那么就用引用或者指针。\n解释如下：其作用是在一个线程t1中保存一个类型typename T的值，可供相绑定的std::future对象在另一线程t2中获取。\n#include &lt;iostream&gt;\n#include &lt;future&gt;\n#include &lt;chrono&gt;\n \nvoid Thread_Fun1(std::promise&lt;int&gt; &amp;p)&#123;    std::this_thread::sleep_for(std::chrono::seconds(5));    int iVal &#x3D; 233;    std::cout &lt;&lt; &quot;传入数据(int)：&quot; &lt;&lt; iVal &lt;&lt; std::endl;    p.set_value(iVal);&#125;\nvoid Thread_Fun2(std::future&lt;int&gt; &amp;f)&#123;    auto iVal &#x3D; f.get();\t\t&#x2F;&#x2F;iVal &#x3D; 233    std::cout &lt;&lt; &quot;收到数据(int)：&quot; &lt;&lt; iVal &lt;&lt; std::endl;&#125;\nint main()&#123;    std::promise&lt;int&gt; pr1;    std::future&lt;int&gt; fu1 &#x3D; pr1.get_future();    std::thread t1(Thread_Fun1, std::ref(pr1));    std::thread t2(Thread_Fun2, std::ref(fu1));    t1.join();    t2.join();    return 1;&#125;\niVal在线程一中被创建并赋值，用引用的方式传入线程2内\n\n&nbsp;\nstd::this_thread\n一个名字空间，其中包括各种函数，用于实现对线程自己控制\n例如\nthis_thread::get_id()获取当前进程id\nthis_thread::sleep_for(//时间//)等待一段时间\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++使用建议","url":"/2024/10/01/C-%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE/","content":"\n\n\n\n\nC++使用建议\n\n\n模板声明和定义\n编译器编译阶段就要掌握模板的定义，所以模板头文件必须既包含声明也包含定义。\n\n虚函数补充\n\n构造函数析构函数内也可以调用虚函数，但是这个调用不具有多态性，和当前构造/析构函数所处理的类型一致，比如基类构造函数被调用时子类对象还不存在，所以只能调用基类的。基类析构函数调用的时候子类对象已经析构完成，所以基类析构函数仍然只能调用基类的虚函数。  \n重写的虚函数不能更改原虚函数的默认实参，这个是C++标准定义的未定义行为\n\n\n\n严格弱序三条原则\n\n两个关键字不能同时“严格弱序”对方\na严格弱序b，b严格弱序c，那么a必须严格弱序c\n如果两个关键字任何一个都不“严格弱序”对方，则两个关键字相等\n比如“&lt;”符号，符合上序规则，而“&lt;=”符号不符合。\n所有的自定义比较函数都必须遵循严格弱序。\n例如sort函数，在sort函数内，弱元素个数大于_S_threshold，则使用快速排序，弱快速排序迭代深度大于__depth_limit则使用堆排序；反之元素个数大于_S_threshold，则使用插入排序。\n其中快速排序的实现：\n\n\n\n\n\nwhile (true)\n&#123;\n    while (__comp(*__first, __pivot))\n        ++__first;\n    --__last;\n    while (__comp(__pivot, *__last))\n        --__last;\n    if (!(__first &lt; __last))\n        return __first;\n    std::iter_swap(__first, __last);\n    ++__first;\n&#125;\n\n对于对比函数__comp，如果不遵循严格弱序，且出现first与pivot一直相等的情况，那么__first就不会被return，会一直自增导致越界。\n原码这样做的原因，是为了节省比较的运算开销，没有进行边界检查。\n\n尽量少使用智能指针的get()来获取裸指针\nget函数直接返回一个对象的裸指针，这个指针是新建的，和原来的智能指针不冲突，所以很容易发生冲突问题。\n\n形参在函数体内的形式一定是左值，哪怕传过来的是右值\n如果确定是右值，那么用std::move进行转换\n如果不确定，那么用std::forward进行完美转发\n\n引用和指针\n经常会被问到指针和引用的适用场景，其实准确讲两者的本质没有差别，对于编译器来说，会利用一个符号表存储引用，而符号表内本身也是存的引用对象的地址，也就是指针，本体没差别。\n不过一般情况下说的都是引用比较值引用，比如函数的形参会将参数复制一次，额外损耗性能，如果直接使用引用可以模拟值引用的情况，节省性能。\n另一种情况就是引用可以模拟指针的传地址，而不用到处都使用解地址符了。\n说一下自己的理解，引用发明出来就是为了方便做“值处理”，也就是实现在函数内也能做到修改原参数变量的功能。原本这个功能利用指针也能解决，但是指针有一个性质就是其指向会被更改，也就是说对指针进行操作的时候可能就不小心更改了其指向了，这是一个很危险的设计，所以在这个层面上尽量使用加了限制还更方便的引用来处理。如果说需要更改指针指向，那么就直接使用指针。\n其次，一句话总结就是如果允许参数为空，那就传指针，其他情况下就传引用。\n\nconst与constexpr尽量使用\n\nconst&amp;作为函数参数\n成员参数符合const条件就用const\n增加泛用性，让编译器进行更高级的优化\n\n\n\nvector中的reserve指预留空间，而不真正创建元素对象；resize指直接改变元素大小并创建对象。\n\n\n\n\n","categories":["从C开始的C++"]},{"title":"C++内存管理","url":"/2023/08/07/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"\n\n\n\n\nC++内存分配方式\n\n内存分配方式\n五大区：栈、堆、自由存储区（内存池）、全局/静态存储区和常量存储区\n以下地址空间由高到低\n\n\n栈：函数局部变量、参数返回值等。使得局部变量生存周期就是申请到释放该段空间。由高到低增长，此外，采用先进后出的数据结构，由系统自行分配释放。\n堆：由new控制的内存块，由delete释放，一般用于动态内存分配。由低到高增长，一般由程序员分配释放，不释放则由系统释放。\n自由存储区（内存池）：由malloc分配的内存块，由free释放。\n全局/静态存储区（数据段）：顾名思义存储全局变量与静态变量的地方，在C语言中，这块地方分为bss段与data段，分别代表未初始化的全局变量与已初始化的全局变量和静态变量。\n常量存储区（text段）：也就是代码段，在内存中是属于“只读”，储存常量的地方。\n\n\n&nbsp;\n区分堆与栈\n先上六大总结：\n\n管理方式不同\n空间大小不同\n能否产生碎片不同\n生长方向不同\n分配方式不同\n分配效率不同\n\n\n管理方式：栈由编译器控制管理；堆手动控制容易内存泄漏\n空间大小：堆内存非常大（几乎无限制）；而栈很小（有限制）\n碎片问题：堆的频繁new/delete操作使得它容易产生大量碎片；而栈由于先入后出的特性而不容易产生碎片\n生长方向：堆向上（向高）增长；栈向下（向低）增长\n分配方式：堆是动态分配；栈既有动态(alloca)也有静态分配，且栈的动态分配由编译器释放\n所有的静态分配都有编译器释放\n\n分配效率：栈效率更高。由于栈有专有的数据结构，有专门的指令进行操控，有专门的寄存器地址；而堆是函数库中的，在调用其空间时甚至需要用到调用算法等。\n//main.cpp\nint a = 0; 全局初始化区\nchar *p1; 全局未初始化区\nmain()\n&#123;\n    int b; 栈\n    char s[] = &quot;abc&quot;; 栈\n    char *p2; 栈\n    char *p3 = &quot;123456&quot;; 123456\\0在常量区，p3在栈上。\n    static int c =0； 全局（静态）初始化区\n    p1 = (char *)malloc(10);\n    p2 = (char *)malloc(20);\n    分配得来得10和20字节的区域就在堆区。\n    strcpy(p1, &quot;123456&quot;); 123456\\0放在常量区，编译器可能会将它与p3所指向的&quot;123456&quot;优化成一个地方。\n&#125;\n\n指针与数组\n实际上，指针与数组是两种截然不同的概念，但指针与数组在使用过程中相似的地方却经常会被弄混淆。\n数组是一块内存的表现形式，而数组名则对应着一块内存（指向数组首地址），内容是可改变的。\n指针是用于指向任意类型内存块的，经常用指针来操作动态内存，和数组“变内容”的特性不同，指针是“变指向”的。\n\ne.g1：\nchar a[] = “hello”;\na[0] = &#39;X’;\ncout &lt;&lt; a &lt;&lt; endl;\nchar *p = “world”; // 注意p指向常量字符串\np[0] = &#39;X’; // 编译器不能发现该错误\ncout &lt;&lt; p &lt;&lt; endl;\n\n字符数组a的内容是hello，而a[0]的内容理所应当就是‘h’，由于数组可变内容，所以可以直接用a[0]=&#39;X&#39;来变化内容\n指针p指向的是常量字符串world，字符串的特征是变指向，此时p[0]也理所应当表示‘w’，p[0]=&#39;X&#39;对于编译器来说是没问题的，但是常量字符串不能改变内容（world就是world），所以这个操作其实是错误的\n\ne.g2:\nchar a[] = &quot;hello world&quot;;\nchar *p = a;\ncout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节\ncout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节\n\n可以直接使用sizeof来计算出数组的容量，而C++没办法得知指针所指的内存容量，所以最终得出的是指针变量的字节数\n此外，使用函数传递数组后，数组的实质就变成同类型指针了\nvoid Func(char a[100])\n&#123;\n　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节\n&#125;\n\n\n&nbsp;\n指针，函数参数与内存\n在学C语言指针的时候认识到\n# include &lt;stdio.h&gt;\nvoid Swap(int *p, int *q);  //函数声明\nint main(void)\n&#123;\n    int i = 3, j = 5;\n    Swap(&amp;i, &amp;j);\n    printf(&quot;i = %d, j = %d\\n&quot;, i, j);\n    return 0;\n&#125;\nvoid Swap(int *p, int *q)\n&#123;\n    int buf;\n    buf = *p;\n    *p = *q;\n    *q = buf;\n    return;\n&#125;\n\n函数内指针是直接对内存单元进行操控的，传递了数据的地址，再顺藤摸瓜对本体进行操作。\n但是当这种效应利用在申请动态内存中时，比如说需要用函数建立链表结点之类，需要在函数内申请动态内存。\nvoid GetMemory(char *p, int num)\n&#123;\n　p = (char *)malloc(sizeof(char) * num);\n&#125;\n\nvoid Test(void)&#123;　char *str &#x3D; NULL;　GetMemory(str, 100); &#x2F;&#x2F; str 仍然为 NULL　strcpy(str, &quot;hello&quot;); &#x2F;&#x2F; 运行错误&#125;\n在前面的例子中，传入函数的指针其实传递的是地址，在函数内用过取缔值*直接操作本体，而这个例子中在函数内是改变了参数本身的地址的，也就是说”p“传入函数中，即将”NULL“地址传入函数，但动态申请内存导致指针p所指向的地址发生改变了，所以实质就不是在操作str了，而是在操作p。\n除非用指向指针的指针来进行操作，这样一来相当于传入”指针的地址“（注意不是“指针所指的地址”），在函数体中对”指针的地址“取蒂值然后操作，就变成了直接对指针进行操作了。\nvoid GetMemory2(char **p, int num)\n&#123;\n　*p = (char *)malloc(sizeof(char) * num);\n&#125;\n\nvoid Test2(void)&#123;　char *str &#x3D; NULL;　GetMemory2(&amp;str, 100); &#x2F;&#x2F; 注意参数是 &amp;str，而不是str　strcpy(str, &quot;hello&quot;);　cout&lt;&lt; str &lt;&lt; endl;　free(str);&#125;\n有一个更好的方法，那就是设置函数返回值类型为指针，然后返回函数指针。\nchar *GetMemory3(int num)\n&#123;\n　char *p = (char *)malloc(sizeof(char) * num);\n　return p;\n&#125;\n\nvoid Test3(void)&#123;　char *str &#x3D; NULL;　str &#x3D; GetMemory3(100);　strcpy(str, &quot;hello&quot;);　cout&lt;&lt; str &lt;&lt; endl;　free(str);&#125;\n这样一来p所指地址发生改变，但是这个改变的地址又传回了str，所以str指向的地址一致。\n上文提到栈内存在函数消亡时自动消亡，所以最好不要这样返回：\nchar *GetString(void)\n&#123;\n　char p[] = &quot;hello world&quot;;\n　return p; // 编译器将提出警告\n&#125;\n\nvoid Test4(void)&#123;　char *str &#x3D; NULL;　str &#x3D; GetString(); &#x2F;&#x2F; str 的内容是垃圾　cout&lt;&lt; str &lt;&lt; endl;&#125;\np是局部变量，是储存在栈区内的，如果返回p的正常值，则正常返回；如果是局部变量的地址或者引用，则返回不出东西，因为返回出地址后变量值已经失效。\n上面的动态分配是储存在堆区内的，不手动free或者delete是释放不了内存的，所以函数结束时能保存内容。\n\n看了其他博主的解释，发现了个有点意思的代码（注意注释）\n#include&lt;iostream&gt;\nusing namespace std;\n \nint * func()&#123;    int a &#x3D; 10;    return &amp;a;&#125;\nint main()&#123;    int *p &#x3D; func();    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;第一次正常返回，因为编译器操碎了心，给数据做了一个保留    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;第二次结果错误，因为a的内存已经释放    cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;结果仍然错误\t    return 0; &#125;\n为什么上面字符串值不保留呢，很神必\n\n&nbsp;\n小心野指针\n\n最”常见“的野指针\n\n\nchar *p;\nchar *str;\n\nchar *p = NULL;\nchar *str = (char *) malloc(100);\n\n为初始化的指针会随便乱指，小心它撒野！\n\n最“暗淡“的野指针\n\n\n指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。\n\n最”忽视”的野指针\n\n\nclass A\n&#123;\n　public:\n　　void Func(void)&#123; cout &lt;&lt; “Func of class A” &lt;&lt; endl; &#125;\n&#125;;\n\nvoid Test(void)&#123;　A *p;　&#123;　　A a;　　p &#x3D; &amp;a; &#x2F;&#x2F; 注意 a 的生命期　&#125;　p-&gt;Func(); &#x2F;&#x2F; p是“野指针”&#125;\n&nbsp;\n以上，就是C++内存管理的肤浅、初步、入门探索，健壮指针、资源管理is coming。。。。。。\n\n&nbsp;\n内存泄漏\n最接地气的解释就是：你用了malloc，用了new，结果没有free也没有delete掉，那么这段存在堆中的内存就被”孤立“了，就相当于拨款被”赃“了，导致了系统内存浪费使得程序运行效率降低。\n如何避免内存泄漏呢\n教科书式方法必然就是什么”良好编码习惯“”及时释放内存“云云。\n有几种情况其实简介避免了内存泄漏\n\n标准容器\n\n\n举这么一个例子：\n#include&lt;vector&gt;\n#include&lt;string&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nint main() // small program messing around with strings\n&#123;\n　cout &lt;&lt; &quot;enter some whitespace-separated words:&quot;n&quot;;\n　vector&lt;string&gt; v;\n　string s;\n　while (cin&gt;&gt;s) v.push_back(s);\n　sort(v.begin(),v.end());\n　string cat;\n　typedef vector&lt;string&gt;::const_iterator Iter;\n　for (Iter p = v.begin(); p!=v.end(); ++p) cat += *p+&quot;+&quot;;\n　cout &lt;&lt; cat &lt;&lt; ’&quot;n’;\n&#125;\n\n假如没有vector和string这么个好东西，我们手动去malloc去分配去free，想象一下是一件多么恐怖的事情。\n这些容器不需要程序员去对装载内存进行操作，内存管理操作被它们隐藏在了库函数代码背后，这就避免了很多令人头疼的场面。\n在自己的程序当中，把所有相关内存管理都打包在相关资源控制库当中，也就是专人专事，避免在正常开发模式中去考虑这些歪瓜裂枣。\n\n资源句柄//太深入了了解就好//\n智能指针\n\n\n\nstd::unique_ptr&lt;T&gt; ：独占资源所有权的指针。\nstd::shared_ptr&lt;T&gt; ：共享资源所有权的指针。\nstd::weak_ptr&lt;T&gt; ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。\n\n\n\n简单用例：\n&#123;\n    int* p = new int(100);\n    // ...\n    delete p;  // 要记得释放内存\n&#125;\n\n&#123;\n    std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);\n    //...\n    // 离开 uptr 的作用域的时候自动释放内存\n&#125;\n\n\n内存泄漏检测器等\n\n\n据说Smart Pointer技术比较成熟，但其实C++中应用一直不广泛，这点要和java学学\n&nbsp;\n内存对齐\n直接上例子：\n//32位系统\n#include&lt;stdio.h&gt;\nstruct&#123;\n    int x;\n    char y;\n&#125;s;\n\nint main()&#123;    printf(&quot;%d\\n&quot;,sizeof(s);  &#x2F;&#x2F; 输出8    return 0;&#125;\nint类型大小为4byte，char类型大小为1byte，但作为结构体加一块变成了8byte。\n处理器一般会以某个数的倍数（2、4、8...）来取内存，内存对齐的意义就是方便计算机自个儿。\n字节对齐规则\n老规矩，编译器的活可以手动改的\n#pragma pack(n) n取啥，啥就是编译器的对齐系数（VSC）\n但是最终的有效对齐值是选择对齐系数与结构体中最大那个成员大小中的最小值胜任\n\n__attribute__（GCC）\n具体规则：\n\n结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。\n结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。\n\n\n这两个规则分别阐述了内存对齐的操作位置，分别为结构体成员间，与结构体最后一成员后。\n下面用一系列struct例子保证给你解释清楚\nstruct&#123;\n    int i;\n    char c1;\n    char c2;\n&#125;x1;//sizeof(x1)=8\n\nstruct&#123;    char c1;    int i;    char c2;&#125;x2;&#x2F;&#x2F;sizeof(x2)&#x3D;12\nstruct&#123;    char c1;    char c2;    int i;&#125;x3;&#x2F;&#x2F;sizeof(x3)&#x3D;8\n\n结构体x1\n\n首先看规则一\n限制不了第一个成员，因为第一个成员offset就是0，从第二个成员开始根据char（1）或者有效对齐值（4）中最小为1，而偏移地址4可以除断1，所以可以直接存入，后面一个成员也是同样的道理，不需要空间对齐。\n再看规则二\n算出来struct大小为6，不是4的倍数，所以编译器在最后填充了两个空间凑成8（虚线部分）\n&nbsp;\n\n结构体x2\n\n首先看规则一\n老规矩第一个成员不管，直接从第二个开始，很容易得知int（4）最小只能选4，那么int成员从内存地址1开始往后推只能到4满足规则一，所以编译器从中补充3字节大小。\n再看规则二\n后续计算出9字节，不符合，于是填充到12字节\n&nbsp;\n以上的例子只是初步了解了内存对齐的大致机制，而后的例子深挖细节与易错点\n\n首先是数组，如果结构体中带数组，则按照数组类型来进行内存对齐，即char a[3]等同于char a写三个。\nstruct str2 &#123;\n    short c1[3];\n    char c2[5];\n    char c3[6];\n&#125;str2;//sizeof()结果为18\n\n&nbsp;\n数组细则\nstruct str3 &#123;\n    int c;\n    double t;\n    char c1[3];\n&#125;str3;//sizeof()结果为24\n\nstruct str4 &#123;    double t;    char c1[3];    int c;&#125;str4;&#x2F;&#x2F;sizeof()结果为16\n以上两个结构体只是将顺序改变了一下，但是最终结果却天差地别。\n罪魁祸首在不同位置的偏移数与最终空间补齐上。\nstr3首成员大小为4，在为第二个成员腾位置的时候要从第八个位置放（规则一），于是编译器补充了4字节，最终计算出的结果为19字节，但由于按照对齐有效值来看必须是8的倍数，所以结果为24。\nstr4除了char后面要补充一个字节，全程几乎畅通无阻，最后算出来也是16。\n不过，如果在程序前加上#pragma pack(4)则两者的结果都会变回16。\n&nbsp;\n空数组\nstruct str&#123;\n    char p;\n    int a;\n    int b[0];\n&#125;//sizeof = 8\n\nstruct str&#123;    int b[0];&#125;&#x2F;&#x2F;sizeof &#x3D; 4\nstruct str&#123;\n&#125;&#x2F;&#x2F;sizeof &#x3D; 1\n空数组在程序定义是非法的，只能在类或者结构体中定义，本身是不占空间的，只是一个指针指向一个位置。\n至于为什么中间那个结构体大小为4，我认为是编译器检测到空数组的类型为int，所以在结尾给他补充了四个字节大小，而不是空数组本身带给他的空间。\n最后一个存在一个大小为1字节，因为编译器至少需要一个空间来将不同结构体“认出来”，这个记住就好，而且这个值和编译器本身有关。\n如果在空结构体中编入虚函数，则由于会生成虚函数表，所以会比1大一点\n\n&nbsp;\n结构体对齐\n如果有结构体嵌套结构体的情况，那么内部被嵌套的结构体计算对齐大小时按照它本身最大那个成员大小来计算\nstruct pa\n&#123;\n   char a;\n   node b;\n&#125;\nsizeof(pa)=12\n//b的起始位置要是4的整倍数，因此要在a后补位，\n//b占8字节\n\n&nbsp;\n结构体(struct)和共同体(union)\n结构体struct：把不同类型的数据组合成一个整体。struct里每个成员都有自己独立的地址。sizeof(struct)是内存对齐后所有成员长度的加和。（引申出内存对齐的问题）\n共同体union：各成员共享一段内存空间, 一个union变量的长度等于各成员中最长的长度，以达到节省空间的目的。所谓的共享不是指把多个成员同时装入一个union变量内, 而是指该union变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值。sizeof(union)是最长的数据成员的长度。\n总结： struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。\n\n&nbsp;\n&nbsp;\nmalloc与new\nmalloc实现原理\nmalloc函数是将可用内存块都链接成一个空闲链表，然后在调用的时候寻找一个满足用户条件或者接近满足用户条件的块，将这个块一分为二（一部分给用户，一部分剩下的链接回链表）。如果没找着那就动用sbrk()函数在堆里头划分新内存出来。\n可见所谓”可用内存块“其实就是上文所提到的”自由储存区“，这个区靠近堆且性质和堆很像，动用sbrk()的时候就动用了栈区了\n\n另外，在空闲链表中寻找内存块的算法和操作系统中分区分配算法如出一辙\n如首次分配，下一次分配，最佳适配等。\n具体性质见//操作系统分区分配//\n操作要点\n原型函数：\nvoid * malloc(size_t size);\n\n用malloc申请一块长度为length的整数类型的内存：\nint *p = (int *) malloc(sizeof(int) * length);\n\n这里可以发现malloc的返回值其实是void*，所以要显式转换到我们需要的类型。\n后面的具体大小其实只看字节数的，不过为了防止出错，我们一般都用sizeof加类型这样的形式。\n&nbsp;\nnew实现原理\nnew，包括delete，其实最终都是调用malloc和free的。\n数据类型分为简单类型与复杂类型\n如果是简单类型（基本数据类型和不需要构造函数的类型），则调用operator new函数，核心如下：\n while ((p = malloc(size)) == 0)\n            if (_callnewh(size) == 0)\n            &#123;       // report no memory\n                    _THROW_NCEE(_XSTD bad_alloc, );\n            &#125;\n\nmalloc()调用失败则调用_callnewh()，再失败则返回bad_alloc异常。\n这里是new和malloc区别之一，如果malloc异常则直接返回NULL\n\n如果是复杂类型，先调用 operator new()函数，然后在分配的内存上调用构造函数。\n操作要点\nint *p1 = (int *)malloc(sizeof(int) * length);\nint *p2 = new int[length];\n\nnew内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。\n创建对象数组\nObj *objects = new Obj[100]; // 创建100个动态对象\nObj *objects = new Obj[100](1);// **这样是错误的**创建100个动态对象的同时赋初值1\n\ndelete\ndelete []objects; // 正确的用法\ndelete objects; // 错误的用法\n\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++刷题8.11","url":"/2023/08/15/C-%E5%88%B7%E9%A2%988-11/","content":"\n\n\n\n\nC++8.11\n\n常量指针\n下面指针所指向的内存，可以修改的是（）\nA const int* a\nB int const* b\nC int* const c\nD const int* const d\nA 和 B 是等价的。const int* a 和 int const* b 都表示一个指向常量整数的指针。你可以改变这个指针所指向的地址，但不能通过这个指针来改变地址处的值。\nD const int* const d 表示一个指向常量整数的常量指针。你既不能改变这个指针所指向的地址，也不能通过这个指针来改变地址处的值。\nC int* const c 表示一个指向整数的常量指针。这个指针的值（即它指向的地址）不能改变，但是你可以改变这个地址处的值。\n&nbsp;\ndefine宏定义\n宏定义只是替换\n\n下面程序输出的是:\n#define f(x) x*x\nmain ()&#123; \n    int a=5,b=2,c;\n    c=f(a)/f(b);\n    printf(&quot;%d&quot;,c);\n&#125;\n\n这题注意乘除法，/不要代入数学里的分号了，是按顺序算的。\n所以答案是24\n&nbsp;\n地址相减\n原来我一直以为地址值本身不能做到相减这个操作的，但其实是可以的，不过结果的差值要除以sizeof(类型)\n参考指针的++或者--运算，都是指针的步长乘以一个移动的步长，再除以一个指针的步长\n\nint a[3];\na[0] = 0;\na[1] = 1;\na[2] = 2;\nint *p, *q;\np = a;\nq = &amp;a[2];\n\n答案是2\n\n&nbsp;\nstrlen()\n坑！全是坑，题做的有高考一轮复习内味了\n\nint main() &#123; \n  char a[7] = &quot;a0\\0a0\\0&quot;;\n  int i, j;\n  i = sizeof(a); \n  j = strlen(a);\n  printf(&quot;%d %d\\n&quot;,i, j);\n&#125;\n\nstrlen()到\\0会停下，你就坑吧！\n7 2\n\n&nbsp;\n加法操作符重载\n如果表达式++a中的&quot;++&quot;是作为成员函数重载的运算符，若运用运算符函数调用格式，则可表示为（）\nA a.operator++(1)\nB operator++(a)\nC operator++(a，1)\nD a.operator++()\n答案是D\n乱七八糟的解析：\n当运算符重载为类的成员函数时，函数的参数个数比原来的操作数要少一个（后置单目运算符除外），这是因为成员函数用this指针隐式地访问了类的一个对象，它充当了运算符函数最左边的操作数。因此： \n  (1) 双目运算符重载为类的成员函数时，函数只显式说明一个参数，该形参是运算符的右操作数。 \n  (2) 前置单目运算符重载为类的成员函数时，不需要显式说明参数，即函数没有形参。 \n  (3) 后置单目运算符重载为类的成员函数时，函数要带有一个整型形参。 \n&nbsp;\n不如先直接记：重载前缀:a.operator++(); 重载后缀:a.operator++(1)    \n&nbsp;\n运算符重载\n下面运算符不能被重载的是（）\nA 做用域运算符“::”\nB 对象成员运算符“.”\nC 指针成员运算符“-&gt;”\nD 三目运算符“? :”\n答案：ABD\n似乎有方法说“带点的都不能重载”\n不过还是看图吧\n\n\n&nbsp;\n数组、指针与函数\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nvoid fun(int *p1, int *p2, int *s) &#123;\n    s = (int *)malloc(sizeof(int));\n    *s = *p1 + *(p2++);\n&#125;\nint main() &#123;\n    int a[2] = &#123;1, 2&#125;, b[2] = &#123;10, 20&#125;, *s = a;\n    fun(a, b, s);\n    printf(&quot;%d \\n&quot;, *s);\n&#125;\n\n这个题对于我这个唐b来说很有价值,因为它包含了非常多有关指针的操作。\n首先是函数传递\nfun()函数定义了局部变量p1与p2与s，如果这个局部变量是指针，那么他们会和上一级函数中的对应变量指针指向同一位置，就像这里p1与s，在上一级中s已经指向了数组a的第一个位置，所以说p1、s指向的都是一个位置，这是第一个给我给我蒙住的地方。\n然后是自增\nfun()函数内p2的自增是后缀，先赋值再自增，尽管这个是我为数不多已经知道的点，但面对这么一个大体量题目还是给我晃倒了。\n再者是malloc函数的返回值\nmalloc函数返回的是新内存地址的指针，所以在fun()函数内部，经过malloc的“洗礼”之后地址遭到改变，s指向也变了，于是乎函数内部的这个“s”和上一级函数中s的指向就变得不一样了，也就不能对之前指向的目标进行操作了，所以程序输出的仍是1\n所以如果注释掉malloc，结果就是11了\n\n&nbsp;\n逗号表达式\n这个就多少带点离谱了\n\na=3*5 , a *4;(空格是防止markdown语句)\n这样一行表达式，a肯定最终为15\n但如果b=(a=3*5,a *4)\n那么最终b的值就是60\n逗号表达式，依次计算，整体的值为最后结果\n&nbsp;\n&nbsp;\n\n","categories":["做题笔记"]},{"title":"C++右值引用相关","url":"/2023/09/28/C-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9B%B8%E5%85%B3/","content":"\n\n\n\n\nC++左值与右值\n\nC++左值与右值\n首先普及一下学习多年C++没注意记忆的概念\n左值：可以取地址、位于赋值符号左边的值，就记住，左值是表达式结束（不一定是赋值表达式）后依然存在的对象。左值也是一个关联了名称的内存位置，允许程序的其他部分来访问它的值。\n有以下特征：\n\n可通过取地址运算符获取其地址\n可修改的左值可用来赋值\n可以用来初始化左值引用\n\n\n那些是左值？\n\n变量名、函数名以及数据成员名\n返回左值引用的函数调用\n由赋值运算符或复合赋值运算符连接的表达式，如(a=b, a-=b等)\n解引用表达式*ptr\n前置自增和自减表达式(++a, ++b)\n成员访问（点）运算符的结果\n由指针访问成员（ -&gt; ）运算符的结果\n下标运算符的结果([])\n字符串字面值(&quot;abc&quot;)\n\n\n&nbsp;\n右值：指那些可以提供数据值的表达式（不一定可以寻址，例如存储于寄存器中的数据）。右值有可能在内存中也有可能在寄存器中。一般来说就是活不过一行就会消失的值。\n那些是右值？\n\n字面值(字符串字面值除外)，例如1，&#39;a&#39;, true等\n返回值为非引用的函数调用或操作符重载，例如：str.substr(1, 2), str1 + str2, or it++\n后置自增和自减表达式(a++, a--)\n算术表达式（x + y;）\n逻辑表达式\n比较表达式\n取地址表达式\nlambda表达式auto f = []&#123;return 5;&#125;;\n\n\n简单讲右值不能取地址，左值能\n\n&nbsp;\n纯右值与将亡值：右值的分类。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关的表达式，比如，将要被移动的对象、T&amp;&amp;函数返回值、std::move返回值和转换为T&amp;&amp;的类型的转换函数的返回值等。\nC++11中所有的值，都是左值、纯右值、将亡值其中一种\n\n&nbsp;\n具名：顾名思义就是“有名字的”，比如变量、函数、类、名字空间等。\n比较标准的解释就是：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址\n其特点如下：\n\n标识符：每个具名实体都有独特的标识符，该标识符由字母、数字和下划线组成，以字母或下划线开头。\n作用域：规定了具名实体在程序中的不同部分中的可见性和访问性。\n类型：具名实体具有特定的类型。\n存储位置：一旦具名，程序会为实体分配存储空间，可以是栈、堆或者静态存储区。\n\n\n&nbsp;\n可被移动：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式。\n&nbsp;\n临时对象：又称“无名对象”用于存储中间结果的实参，在求值结束后立即被销毁。一个最简单的例子——\nint result = 2 * (3 + 4); \n2*（3+4）这个表达式的结果就是用临时对象来存储的，然后临时对象再赋值给result\nif(2*(3+4))这样理解是不是更清晰一些呢，if括号内没有什么result，但还是隐式有一个什么东西储存括号内的计算结果，然后根据这个结果来判断。\n临时对象在任何表达式求值类中出现（其实单个int值之类也算表达式），所以说函数返回值，传入实参等都有可能出现。\n由于临时对象在发挥作用后立即被销毁，所以要避免临时对象的悬空引用\n\n&nbsp;\n右值引用：我们都知道左值引用，int&amp; p = q;就是左值引用\n而形如T&amp;&amp; k = getVar();就是右值引用（T为类型）\n右值引用一个最明显的表现，就是将右值的生命周期延长到和引用本身一样了。（这样就要避免导致前文提到的问题）。\n左值引用其实也可以接受右值，不过非常量左值引用只能接受左值。\nconst A&amp; a = GetA();和右值引用一样，在C++11之前也可以用于性能优化。\n&nbsp;\n对象的拷贝控制\nC++11之前：拷贝构造函数、拷贝赋值运算符、析构函数\nC++11之后+：移动构造函数、移动赋值运算符\n\n拷贝构造函数：只有一个参数，就说本类的引用——最好加const，因为可以以常量对象为参数。\n编译器会自动生成默认复制构造函数，这个默认复制构造函数会在启用时将被拷贝对象中的所有信息都打包（涉及浅拷贝，可见本章节对象和类部分）。\n如果自行编写复制构造函数，默认复制构造函数会失效，这个时候起作用的复制构造函数可以做一些其他的事，比如将复制过去值+1，不过要谨慎对待因为自定义的复制构造函数只会进行自定义的语句。\n#include&lt;iostream&gt;\nusing namespace std;\nclass A &#123;\npublic:\n    int a1;\n    A() &#123;&#125;;\n    A(const A&amp; a) &#123;\n        //a1 = a.a1;\n        //如果这一句被注释，那么对象b继承不了t.a1的数据，打印出来的将是一个未初始化的混乱数据，从这一点可以看出来自定义的复制构造函数只会运行自定义的语句（当然111也会被打印出来）；如果这一句没被注释，那么数据a1会追寻形式参数实际参数追到对象t，于是在类外初始化的a1被复制，打印出正常的2；如果a1的初始发生在类里面，那么复制构造函数内如果没有对a1的特殊处理语句，就会直接将类内的数据默认初始化；如果这一个复制构造函数未被写出，那么编译器生成的默认复制构造函数会将对象所有数据复制，也就是会打印出2\n        cout &lt;&lt; &quot;111&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\nint main() &#123;\n    A t;\n    t.a1 = 2;//a1的初始化在类外进行\n    A b(t);//对象b初始化的时候调用复制构造函数，用t的信息复制给b\n    cout &lt;&lt; b.a1 &lt;&lt; endl;\n    return 0;\n&#125;\n\n&nbsp;\n复制构造函数的调用：1.当用一个对象去初始化同类的另一个对象时；2.作为形参的对象，是用复制构造函数初始化的；3.作为函数返回值的对象是用复制构造函数初始化 的\nA b(t);\nA b = t;//这两句等价\n\nA b;A t;b &#x3D; t;&#x2F;&#x2F;这是直接赋值语句，和上面的不同，这一句不会调用复制构造函数，而是直接用b去给t赋值。\n注意复制构造函数重点有”复制“和”构造“两个\n\n&nbsp;\nvoid solve(A a)&#123;&#125;\n\nint main()&#123;    A a;    solve(a);&#x2F;&#x2F;这个实参a传入函数时会调用复制构造函数，所以说如果复制构造函数像上文提到的那样发生了自定义改变，那么这个实参a与传进solve函数内的形参a可能值就不一样了    return 0;&#125;\n这个时候问题解决来了，如果将自定义复制构造函数的形参设置为const，那么函数内就无法对形参进行改变，任何发生改变的行为都会报错\n\nclass A &#123;\npublic:\n    int a1 = 1;\n    A() &#123;&#125;;\n    A(const A&amp; a) &#123;\n        a1 = Fun(a.a1);//有意思的是使用成员函数就不会报错\n        cout &lt;&lt; &quot;111&quot; &lt;&lt; endl;\n    &#125;\n    int Fun(int a1) &#123;\n        return a1 + 1;\n    &#125;\n&#125;;\n\nconst的水还是很深啊。。\n\n&nbsp;\n第三点不给例子了，毕竟有的编译器甚至会将其优化掉，所以就不追究了\n参考：C语言中文网\n\n&nbsp;\n拷贝赋值运算符\n上面提到过的用=进行初始化的操作中的=就算拷贝赋值运算符，但是注意这里所说的”拷贝赋值运算符“起作用的点不是这个，如果是用来初始化，那么=调用的是复制构造函数；如果是用来赋值，那么起作用的便是”拷贝赋值运算符“，也就是上文提到了那个”错误例子“\n\nclass A &#123;\npublic:\n    int a1 = 1;\n    A() &#123;&#125;;\n    A(const A&amp; a) &#123;\n        //a1 = Fun(a.a1);\n        cout &lt;&lt; &quot;111&quot; &lt;&lt; endl;\n    &#125;\n    A&amp; operator=(A&amp; a)&#123;\n        //a1 = Fun(a.a1);输出为1\n        //如果没有这个注释，那么下面的输出就是6，道理和自定义复制构造函数是一样的，这里不做赘述\n        return *this;\n    &#125;\n    int Fun(int a1) &#123;\n        return a1 + 1;\n    &#125;\n&#125;;\nint main() &#123;\n    A a;\n    a.a1 = 5;\n    A b;\n    b = a;\n    cout &lt;&lt; b.a1 &lt;&lt; endl;\n    return 0;\n&#125;\n\n说了这么多”自定义“的拷贝与赋值，那么什么情况下比较合适”自定义“呢，那就是我们要实现深拷贝的时候。\n\n在类的拷贝构造函数中进行深拷贝：\n\n分配新的内存空间，以保存要拷贝的对象的数据。\n将原始对象的数据复制到新分配的内存空间中。\n如果对象包含指针成员变量，还需要对指针指向的资源进行拷贝。\n\n\n\n在类的赋值运算符（operator=）重载函数中进行深拷贝：\n\n首先释放目标对象（即赋值运算符左侧的对象）已有的资源，以避免内存泄漏。\n分配新的内存空间，以保存要拷贝的对象的数据。\n将原始对象的数据复制到新分配的内存空间中。\n如果对象包含指针成员变量，还需要对指针指向的资源进行拷贝。\n\n\n\n\n\n需要注意的是，如果类包含动态分配的资源（如堆上的内存、文件句柄等），则必须在深拷贝过程中进行适当的资源管理，以确保在对象的生命周期结束时正确释放这些资源，避免内存泄漏。\n#include &lt;cstring&gt; // For memcpy\n\nclass MyClass &#123;private:    int* data;    int size;\npublic:    &#x2F;&#x2F; 拷贝构造函数    MyClass(const MyClass&amp; other) &#123;        size &#x3D; other.size;        data &#x3D; new int[size];        memcpy(data, other.data, size * sizeof(int));    &#125;\n// 赋值运算符重载\nMyClass&amp;amp; operator=(const MyClass&amp;amp; other) &#123;\n    if (this != &amp;amp;other) &#123;\n        delete[] data; // 释放已有资源\n        //为什么？想想初始化拷贝与赋值的区别\n        size = other.size;\n        data = new int[size];\n        memcpy(data, other.data, size * sizeof(int));\n    &#125;\n    return *this;\n&#125;\n\n// 析构函数\n~MyClass() &#123;\n    delete[] data; // 释放资源\n&#125;\n\n};\n&nbsp;\n在介绍移动构造函数之前，先浅入一下move函数\nmove函数\nmove函数简单地讲 ，就是将左值强制转换为右值引用，这个和一个强制转换是等同的——static_cast&lt;T&amp;&amp;&gt;(lvalue)。\nmove函数是一个“做不了实事”的函数，从结果上看它实现的”移动语义“和其他数值转移函数大差不差，只是全然用于性能优化。\n上面我们聊过深拷贝的实现，可以发现其实非常复杂，而且对程序的性能影响非常大。如果在一些场合下，我们可以直接将被拷贝的对象资源直接移动到目标对象上，从而避免了资源的大量浪费。\n深拷贝中，我们往往需要先建立一块内存区域，然后用这块内存区域存储数据。不过大部分情况下，我们不需要原对象的内存，这个时候使用移动语义更加合适，它直接将被拷贝对象的数据包括内存直接移动给目标对象，从而避免了新内存区域的建立\n\n&nbsp;\n移动构造函数\n上面说的move实际上并不能移动任何东西，他只是强制将一个左值变为右值引用。对于对象之间的“移动”，就是由”移动构造函数“去具体实现的，而移动构造函数本身就是由右值引用而触发的，这样就形成了一个闭环，最终满足的结果就是让”对象“有了右值的性质。\n对于基本类型，move的意义并不大，使用后仍然会发生拷贝（因为没有移动构造函数）。\n下面请看这个例子\n别看注释，gpt胡言乱语\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass A&#123;public:    A() :m_ptr(new int(0)) &#123; cout &lt;&lt; &quot;construct&quot; &lt;&lt; endl; &#125;    &#x2F;A(const A&amp; a) :m_ptr(new int(a.m_ptr)) &#x2F;&#x2F;深拷贝的拷贝构造函数    &#123;        cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;    &#125;&#x2F;    ~A() &#123; delete m_ptr; &#125;private:    int m_ptr;&#125;;A GetA()&#123;    return A();&#125;int main() &#123;    A a;    a &#x3D; GetA();    return 0;&#125;\n运行函数时发生了一个难绷的事\n\n\n\n\na = GetA()GetA()本身是临时变量，在结束时自动销毁，调用了析构函数将指针内存释放，但由于是浅拷贝，在main函数结束的时候再次遭到释放，就发生了如此……好吧其实没发生，因为我的编译器自动优化了代码，使GetA返回值临时对象省略掉了，但读者还是最好默认会发生错误（得亏我试了好长时间想方设法让编译器出错）\n这是一个没做深拷贝的典型例子，如果类内含栈内存数据，那很容易会发生这样的情况。但都说过了深拷贝很费计算机，而且还会影响性能，那咋办嘛。更何况堆内存很大很大的情况（这个反而经常发生），拷贝代价会异常之大，那有什么解决办法吗？\n下面看这个例子\nclass A\n&#123;\npublic:\n    A() :m_ptr(new int(0))&#123;&#125;\n    A(const A&amp; a):m_ptr(new int(*a.m_ptr)) //深拷贝的拷贝构造函数\n    &#123;\n        cout &lt;&lt; &quot;copy construct&quot; &lt;&lt; endl;\n    &#125;\n    A(A&amp;&amp; a) :m_ptr(a.m_ptr)\n    &#123;\n        a.m_ptr = nullptr;\n        cout &lt;&lt; &quot;move construct&quot; &lt;&lt; endl;\n    &#125;\n    ~A()&#123; delete m_ptr;&#125;\nprivate:\n    int* m_ptr;\n&#125;;\nA GetA()\n&#123;\n    return A();\n&#125;\nint main()&#123;\n    A a = GetA(); \n&#125; \n\n哎不想跑了，编译器总是把代码给优化了看不到效果\n\n反正就是程序并没有调用拷贝构造函数，它利用移动语义直接将指针的所有者转移到了另外一个对象，避免了深拷贝的发生\nTODO：模板函数的完美转发\nTODO：lambda表达式\n\n","categories":["从C开始的C++"]},{"title":"C++元编程","url":"/2024/01/18/C-%E5%85%83%E7%BC%96%E7%A8%8B/","content":"\n\n\n\n\nC++模板元编程\n\nC++模板、元编程、反射\n我喜欢把这一篇叫做——C++与UE的缝合线\n&nbsp;\nC++模板（C++11之后）\n即允许将“类型”作为变量传递\nint solve(int a)&#123;\n    return a*2;\n&#125;\n\nfloat solve(float a)&#123;    return a*2;&#125;\ndouble solve(double a)&#123;    return a*2;&#125;\nint main()&#123;    int a&#x3D;1;    float b&#x3D;1.1f;    double c&#x3D;1.111;    cout&lt;&lt;solve(a)&lt;&lt;endl;    cout&lt;&lt;solve(b)&lt;&lt;endl;    cout&lt;&lt;solve(c)&lt;&lt;endl;&#125;\n不同参数列表或者返回值的函数使用函数重载函数进行定义，十分麻烦。\ntemplate&lt;class T&gt;//也可以template&lt;typename T&gt;\nT solve\nT solve(T a)&#123;\n    return a*2;\n&#125;\n\nint main()&#123;    int a&#x3D;1;    cout&lt;&lt;solve(a)&lt;&lt;endl;    return 0;&#125;\n模板T可以自动判断参数类型来推导出自己是什么类型。\n&nbsp;\n放在C++98或者之前（也许？的版本中，泛型编程的形式是这样的：\n#define solve(T) _SOLVE_##T\n#define SOLVE(T) (T a)     \\\nT _SOLVE_##T(T a)&#123;         \\\n    return a*2;\t\t\t   \\\n&#125;\t\t\t\t\t\t   \n\nSOLVE(int);SOLVE(float);\nint main()&#123;    solve(int)(1);    solve(float)(1.0f);&#125;\n最大的特点就是还没看呢，就被乱七八糟的符号糊脸。\n其中宏定义中的T在预处理阶段就被替换，##表示连接两边的标识符，因为_SOLVE_和T本身就属于需要替换的标志。\n无论是定义阶段还是使用阶段都需要直接进行宏替换，这样明显不安全，没法调试，可读性差，而且本身就不省力。\n&nbsp;\ntemplate&lt;class T&gt;\n\n然后就是这个神奇的模板关键字，本质上只是单纯“通知”编译器要进行模板编程了，不要报错。\n&nbsp;\nSFINAE\n在编译时，当编译器遇到一个实例化的模板时，比如上面的solve(a)，会将a的类型进行推导，然后将得到的类型于可能的模板集中进行一个一个匹配，若匹配成功会将模板定义中的T类型替换为a的数据类型，若遇到第二个示例，则为为其单独生成一份针对a类型的模板代码。\n所以理论上模板的缺点就是有可能导致代码膨胀冗余，也就是和内联函数一个道理，占用代码段内存过多，不过模板的优点倒是远远大于这些潜在问题。\n单个匹配失败的情况下为Failure\n所有匹配失败的情况下为Error——报错\n&nbsp;\n模板特例\n编译器在编译的时候偏向于调用普通函数而不是模板函数，所以有需要的情况下要把优先级高的类型单独写出，比如：\nstring solve(string a)&#123;\n    return a+a;\n&#125;//string类型只能+\n\n显式调用\nsolve&lt;int&gt;(1);\n\n整数参数\n这个还是C#lbj老师随口提到的一点，我摆出天际了还给我89分，点赞\n\n比如template &lt;typename T, int Size&gt;\n其实就是定义了一个常数，用于模板中常数使用。\n总所周知模板匹配是在编译时完成的，所以模板中的任何内容都不能和运行时相关，而运行时相关编程形式作为学生思维的我们一般会直接联想到虚函数，但其实运行时的用户操作也属于很大一环。。。\n比如int data[Size]\n&nbsp;\n模板约束\n在C++20之前使用SFINAE（替换失败不是错误）技术\ntemplate &lt;typename T&gt;\ntypename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type\nmyFunction(T value) &#123;\n    // 函数实现\n&#125;\n\n看着就怕。\nC++20之后使用require或者consepts。\ntemplate &lt;typename T&gt;\nrequires std::is_integral_v&lt;T&gt;\nvoid myFunction(T value) &#123;\n    // 函数实现\n&#125;\n\ntemplate &lt;typename T&gt;\nconcept Integral = std::is_integral_v&lt;T&gt;;\n\ntemplate &lt;Integral T&gt;void myFunction(T value) &#123;    &#x2F;&#x2F; 函数实现&#125;\n模板的惰性\n就像上面所说的，编译器在处理模板函数的时候是编译阶段处理实例的时候再进行模板定义的实例化（说人话就是模板函数本身在编译时不会直接进行编译，而是等编译到main调用的时候再进行编译）。那么问题来了，如果模板定义和示例分文件进行编写，比如.h与.cpp文件，那么cpp文件中的调用会找不到h中的库模板（因为h中的代码还没有被编译，h模板中的内容还不知道是什么），于是出现报错。\n&nbsp;\n模板编程典型例子\n模板编程最典型的例子就是求阶乘。\n阶乘n!正常思路就是n(n-1)(n-2)...1，也就是说写一个递归函数，维护一个结果值，每递归一次都拿n-1的值去乘以它。\nint factorialRecursive(int n) &#123;\n    if (n == 0 || n == 1) &#123;\n        return 1;\n    &#125; else &#123;\n        return n * factorialRecursive(n - 1);\n    &#125;\n&#125;\n\n总所周知递归调用涉及栈帧创建销毁，还会涉及内存占用等运行时开销。\n最简单粗暴的方法便是提前知道n的值，然后手动一个一个在函数内写出来。\n比如：\nint factorialRecursive() &#123;\n        return 5 * 4 * 3 * 2 * 1;\n&#125;//假如已知n为5\n\n可以说这段代码对于用户来说是毫无意义的。。。（省略了函数调用，你就说快不快嘛）\n所以有没有一种方法让程序自动生成形如n(n-1)(n-2)...1的代码段呢？\n我们可以让模板递归直接为我们生成出来\n// 模板递归方式计算阶乘\ntemplate &lt;int N&gt;\nstruct Factorial &#123;\n    static const int value = N * Factorial&lt;N - 1&gt;::value;\n&#125;;\n\n&#x2F;&#x2F; 模板特化，定义0的阶乘为1template &lt;&gt;struct Factorial&lt;0&gt; &#123;    static const int value &#x3D; 1;&#125;;\n最后展开大概是这个样子（假如n为5）：\n// 展开 Factorial&lt;5&gt;\nstruct Factorial_5 &#123;\n    static const int value = 5 * Factorial_4::value;\n&#125;;\n\n&#x2F;&#x2F; 展开 Factorial&lt;4&gt;struct Factorial_4 &#123;    static const int value &#x3D; 4 * Factorial_3::value;&#125;;\n&#x2F;&#x2F; 展开 Factorial&lt;3&gt;struct Factorial_3 &#123;    static const int value &#x3D; 3 * Factorial_2::value;&#125;;\n&#x2F;&#x2F; 展开 Factorial&lt;2&gt;struct Factorial_2 &#123;    static const int value &#x3D; 2 * Factorial_1::value;&#125;;\n&#x2F;&#x2F; 展开 Factorial&lt;1&gt;struct Factorial_1 &#123;    static const int value &#x3D; 1 * Factorial_0::value;&#125;;\n&#x2F;&#x2F; 模板特化 Factorial&lt;0&gt;struct Factorial_0 &#123;    static const int value &#x3D; 1;&#125;;\nint main() &#123;    &#x2F;&#x2F; 使用展开后的值    std::cout &lt;&lt; &quot;Factorial of 5: &quot; &lt;&lt; Factorial_5::value &lt;&lt; std::endl;    return 0;&#125;\n&nbsp;\n元编程\n元编程，即生成代码的代码。\n和多态相似，元编程分为编译时元编程（静态多态），运行时元编程（动态多态）。\n上文中说到的模板生成代码和宏生成代码，其实就是属于编译时元编程，我们聊元编程也许大多是聊编译时的元编程，因为只有编译时的元编程才充分展现了它自身的意义（为了性能）。\n运行时元编程可能一般不会用“元编程”这个title去称呼它，而是直接说他自身的特点名字，比如“反射”、“动态加载库”等。当然，数据库编程经常用到的字符串形式代码生成也可以叫运行时元编程，除此以外用其他类型代码生成代码也属于运行时元编程，比如常用的python生成C++，lua生成C++。\n&nbsp;\n反射\n反射是一种在运行时获取和操作程序结构信息的机制，例如类的成员、方法、属性等。\n\n得知这个定义时我的第一反应一直是visual studio中的debugger：\n\n其实不是！！！\n虽然debugger同时满足了“运行时”和“获取信息”两个条件，但其实他和反射几乎搭不上边。调试器的主要作用是允许程序员在程序运行时逐行执行代码，观察变量的值，检查调用堆栈，设置断点等。虽然调试器提供了一些运行时的信息，但它通常不提供对类型结构的直接访问和操作，这与反射的目标有所不同。\n反射的目标往往能够在程序运行时直接进行更改，也就是“变量的获取”，比如这样：\n\n或者说（也可以说本文的最终目的）这样：\n\n拿细节面板出来举例的原因主要是这个东西对于初学者来说（比如我）是最明显能体现反射功能的，当你第一次打开UE引擎，创建某个Actor对象或某个蓝图时，它的细节面板能够显示对象所有属性。当这个细节面板被打开的那一瞬间其实就已经在不知不觉中放肆地在运用UE中的反射功能了，只是大多数初学者可能意识不到（比如我），毕竟“反射”这个词其实挺云里雾里的。\n除了细节面板，UE反射机制还广泛运用在以下方面：\n\n序列化：反射可以帮助保存和加载游戏状态，包括游戏进度、配置设置等。\n垃圾回收：UE的垃圾回收系统可以通过反射来跟踪哪些对象正在被使用，哪些对象可以安全地删除。\n网络复制：在网络游戏中，反射被用来同步不同玩家的游戏状态。\n蓝图/C++通信和相互调用：反射允许蓝图（UE的视觉脚本系统）和C++代码相互通信和调用。\n\n\n&nbsp;\n“反射”功能具体是如何实现的呢，这个和UE使用的一个叫“UE4 Reflection System”的系统相关，使用UCLASS、UFUNCTION、UPROPERTY等宏标记对需要进行反射的数据进行标记，被标记了的数据才会被反射系统“注意”到，然后系统会将其暴露给蓝图系统或者其他功能。\n&nbsp;\n上述所说的宏标记，就包含相应的元数据，这些元数据用于实现反射功能，允许在运行时动态对类信息进行获取。-----------待续\n\n","categories":["从C开始的C++"]},{"title":"C++基础唐题学习8.10","url":"/2023/08/10/C-%E5%9F%BA%E7%A1%80%E5%94%90%E9%A2%98%E5%AD%A6%E4%B9%A08-10/","content":"\n\n\n\n\nC++唐题学习（8.10）\n\nC++处理异常机制\n检查、抛出和捕获（try，throw，catch）\n\n该函数参数为1时返回值为（）\nint GetResult(int a)&#123;\n  int b = 0;\n      __try&#123;\n          if ( a != 0 )&#123;\n             b++;\n          &#125;\n          return b;\n      &#125;\n    __finally&#123;\n        --b;\n        &#125;\n    return b;\n&#125;\n\n在函数体_ try内，return语句将变量b的值暂存，然后跳转到_ finally块，_ finally块中若无return，则再返回到_ try块中返回暂存值；\n&nbsp;\n不同类型计算\nint main() &#123;\n    int m = 7, n = 4;\n    float a = 38.4, b = 6.4, x;\n    x = m/2 + n*a/b + 1/2;\n    printf(&quot;%f\\n&quot;, x);  \n    return 0;\n&#125;\n\n\n    答案\n    27.000000\n\n先是以各自类型进行计算，然后转为float\n\n&nbsp;\n模板类\n\n可用来创建动态增长和减小的数据结构\n它是类型无关的，因此具有很高的可复用性。 \n它在编译时而不是运行时检查数据类型，保证了类型安全\n它是平台无关的，可移植性 \n可用于基本数据类型\n\n\n\n&nbsp;\n指针与数组与指针\n哪家企业这么写代码的？我避个雷\n\n下述程序的输出是__。\n#include&lt;stdio.h&gt;\nint main()&#123;\n    static char *s[] = &#123;&quot;black&quot;, &quot;white&quot;, &quot;pink&quot;, &quot;violet&quot;&#125;;\n    char **ptr[] = &#123;s+3, s+2, s+1, s&#125;, ***p;\n    p = ptr;\n    ++p;  \n    printf(&quot;%s&quot;, **p+1);\n    return 0;\n&#125;\n\n你自己猜一下答案吧。\n&nbsp;\n&nbsp;\n\n\n","categories":["做题笔记"]},{"title":"C++基础唐题学习8.9","url":"/2023/08/10/C-%E5%9F%BA%E7%A1%80%E5%94%90%E9%A2%98%E5%AD%A6%E4%B9%A08-9/","content":"\n\n\n\n\nC++基础唐题学习（8.9）\n\n算法的特性\n\n有穷性\n\n\n一个算法必须保证有限步之后结束\n\n\n确定性\n\n\n算法中每一条指令必须有确切的含义\n\n\n可行性\n\n\n算法中所有操作都必须通过已经实现的操作进行运算\n\n\n输入\n\n\n一个算法有0个或多个输入\n\n\n输出\n\n\n一个算法有一个或多个输出\n\n&nbsp;\n定义空类自动生成函数\n定义以下类：\nclass Empty&#123;&#125;\n\n《Effective C++》条款05 \n  声明一个空类之后，编译器就会自动的为他声明一个copy构造函数，一个copy assignment操作符和一个析构函数。  \n  此外如果没有声明任何构造函数，编译器也会自动声明一个default构造函数。所有这些函数都是public且inline的。 \n\nclass Empty  \n&#123;  \n  public:  \n    Empty();                            //缺省构造函数  \n    Empty(const Empty &amp;rhs);            //拷贝构造函数  \n    ~Empty();                           //析构函数   \n    Empty&amp; operator=(const Empty &amp;rhs); //赋值运算符  \n    Empty* operator&amp;();                 //取址运算符  \n    const Empty* operator&amp;() const;     //取址运算符(const版本)  \n&#125;;  \n\n&nbsp;\n指针函数\n啥啊学编程两年就听说过一次的东西也能成题\n\ndata_types (*func_pointer)( data_types arg1, data_types arg2, ...,data_types argn);\n\n原题如下：\n#include &lt;iostream&gt;\nusing namespace std;\n_______________________\nvoid One(float one)\n&#123;\n  cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;   \n&#125;\nvoid Two(float two)\n&#123;\n  cout&lt;&lt;&quot;2&quot;&lt;&lt;endl;\n&#125;\nvoid Three(float three)\n&#123;\n  cout&lt;&lt;&quot;3&quot;&lt;&lt;endl;\n&#125;\nint `ain() \n&#123;  \n  float i=1,j=2,k=3;\n  function = One;\n  function(i);\n  function= Two;\n  function(j);\n  function = Three;\n  function(k);\n&#125;\n\n请为横线处选择合适的程序使得程序的运行结果是123  （    ）\nA    void *function();\nB    void *function(float);\nC\tvoid (*function)();\nD\tvoid (*function)(float);\n\n变量需要内存存放，函数本身也是需要的，存放在代码段中，而函数名字就是函数的地址（和数组类似）\n这个题function = 函数名的语句肯定就是考察函数指针了，所以直接选D，只有它符合函数指针的形式（B为指针函数）\n&nbsp;\n大小端\n 大端意味着高字节在前，小端意味着低字节在前\n\n具体表达就是，假如说unsigned int a=0x12345678\n如果是大端Big-Endian，那么它在内存中是这么存的 12 34 56 78\n如果是小端Little-Endian，那么它是这么存的 78 56 34 12\n计算机最小寻址单元字节(byte)，由8个二进制位(bit)构成，也就是说上述16进制变量是两两一个字节，两两一个位置的，所以如果是小端，那么就是78 56 34 12\n判读本机大小端：\nint i=0x12345678;   \nchar *p=(char *)&amp;i;   \nif(*p == 0x78)     \n    printf(&quot;小端模式&quot;); \nelse // (*p == 0x12)\n    printf(&quot;大端模式&quot;); \n\n为什么呢，因为char类型是一字节大小，int类型的地址被强制转换成char*类型指针，解引用后地址大小就变成char的大小了。int是四个字节，char是一个字节，所以解引用后会得到i的最低字节，如果是0x78，那就说明最低有效字节储存在最低位置处，是小端序，反而是大端序。\n现在看题目：\n已知 int 占 4 个字节，bool 占 1 个字节。对于下面代码：\n#include &lt;iostream&gt;\nusing namespace std;\nint main(int argc, char** argv) &#123;\n    unsigned int value = 1024;\n    bool condition = *((bool*)(&amp;value));\n    if (condition) value += 1; condition = *((bool*)(&amp;value));\n    if (condition) value += 1; condition = *((bool*)(&amp;value));\n    &#125;\n\nvalue, condition 的结果为（）\n\n注意语句bool condition = *((bool*)(&amp;value));\n其实和前文大小端判断的代码类似，将某类型值地址强制转换再解引用，转换后的类型会保存前几个位置的内容，1024转换成十六进制为0x00000400，bool类型占一个字节，无论大端小端，赋值给了condition的都是0，那么两个if就都不执行了。\n&nbsp;\n类继承\nclass默认为private，struct默认为public\n\n下列程序编译时会出现错误，请根据行号选择错误位置( )\n#include &lt;iostream&gt;\nusing namespace std;\nclass A&#123;\n    int a1;\nprotected: \n    int a2;\npublic: \n    int a3;\n&#125;;\nclass B: public A&#123;\n    int b1；\nprotected:\n    int b2;\npublic: \n    int b3;\n&#125;;\nclass C:private B&#123;\n    int c1;\nprotected:\n    int c2;\npublic: \n    int c3;\n&#125;;\nint main()&#123;\n    B obb;\n    C obc;\n    cout&lt;&lt;obb.a1;//1\n    cout&lt;&lt;obb.a2;//2\n    cout&lt;&lt;obb.a3;//3\n    cout&lt;&lt;obc.b1;//4\n    cout&lt;&lt;obc.b2;//5\n    cout&lt;&lt;obc.b3;//6\n    cout&lt;&lt;obc.c3;//7\n    return 0;\n&#125;\n\n\na1没有被设置为public，无法被类外引用——1错\na2设为protected，允许被子类以及本类的成员函数访问，但类外仍然不能访问——2错\na3设为public，理应能访问——3对\nC继承B的继承方式是private，所以都没法引用——4，5，6都错\nc3不用说正常的——7对\n\n\n再附上一张从牛客“偷”来的图\n\n&nbsp;\n\n","categories":["做题笔记"]},{"title":"C#委托与事件","url":"/2023/10/27/C-%E5%A7%94%E6%89%98%E4%B8%8E%E4%BA%8B%E4%BB%B6/","content":"\n\n\n\n\nC#委托\n\nC#委托\n类似与C中的函数指针\n\n&nbsp;\n函数指针\ntypedef int (*FUN)(int a,int b);  // 定义函数指针类型\nint max(int x,int y)\n&#123; return x&gt;y?x:y;&#125;\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\t\n     FUN fun;\n    fun=(FUN)max;\n    int c=fun(3,5); // 或者c=(*fun)(3,5);通过指针调用函数\n    printf(&quot;c is %d \\n&quot;,c);\n        return 0;\n&#125;\n\n或者当作函数的参数：\ntypedef int (*FUN)(int a,int b);\nint max(int x,int y)&#123; return x&gt;y?x:y;&#125;\nint min(int x,int y)&#123; return x&lt;y?x:y;&#125;\nint add(int x,int y)&#123;return x+y;&#125;\nint process(int x,int y, FUN fun)&#123; return (*fun)(x,y);&#125;\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\nint c=process(3,5,max);//函数指针作为函数的参数\nprintf(&quot;max is %d \\n&quot;,c);\nc=process(3,5,min);\nprintf(&quot;min is %d \\n&quot;,c);\nc=process(3,5,add);\nprintf(&quot;add is %d \\n&quot;,c);\n……&#125;\n\n函数指针是非类型安全的：\nint m(int a,int b,int r)  &#123;return r+1;&#125;\nfun=(FUN)m;  //无意义的转换\nc=fun(3,5);\nprintf(“c is %d \\n”,c); //c返回一个随机值\n\n委托\n访问修饰符 delegate 返回值类型 委托名字（委托参数）\npublic delegate int DEL(int a,int b);\n可以在名字空间下定义也可以在类中定义。\n定义一个委托等价于定义了一个指针类型。使用之前先实例化委托。实例化时指定此委托所代表的函数，函数可以是类的静态成员函数，或者是普通的成员函数。\ndelegate int DEL(int a,int b);\n    class Class1\n    &#123; int max(int a,int b)\n      &#123;return a&gt;b?a:b;&#125;\n    static  int smax(int a,int b)\n        &#123;return a&gt;b?a:b;&#125;\n    [STAThread]static void Main(string[] args)\n    &#123;\n         DEL del=new DEL (new Class1().max );//实例化\n        DEL del2=new DEL (smax);//实例化\n          int c=del(3,5); //通过委托来调用函数\n        c=del2(6,8);\n        &#125;\n    &#125;\n\n\n委托是类型安全的：\ndelegate int TDEL (int a,int b,int c);\n Static int m(int a,int b,int c) &#123;return c+1;&#125;\n DEL del=new DEL(m); //实例化委托时,函数签名与委托签名必须匹配,\nTDEL tdel=new TDEL (m);//必须匹配才可实例化\nDEL  del=(DEL)tdel;    //编译器也会阻止不匹配的转换。\n\n&nbsp;\n为什么要使用委托呢？\n首先大部分委托（包括接下来的事件）都是C#设计模式的一种思想，委托并不是独有一定“特定”功能，而是规范程序运行流程，或者说规范代码编写结构，可读性更强。委托能办到的事情，使用其他的基本方法都能办到，就相当于公司老板可以直接安排员工工作，也可以先“委托”小组组长来让小组组长给下级员工安排工作，这个时候老板是不管具体是安排的谁的，老板只需要知道事情被安排出去了。\n这种机制用一个不同类型函数参数的函数重载来举例，例如如下冒泡排序：\npublic class Bubble\n&#123;        // 整数数组冒泡排序\n        static public void sort(int [] sortarr)\n        &#123;for(int i=0;i&lt;sortarr.Length ;i++)\n            &#123;for (int j=0;j&lt;i;j++)\n                &#123;if(sortarr[i]&lt;sortarr[j])\n                    &#123;\tint temp=sortarr[i];\n                        sortarr[i]=sortarr[j];\n                        sortarr[j]=temp;&#125;\t\n                &#125;&#125;&#125;\n    &#125;\n\n这个时候会发现，这个冒泡排序只合适int类型的排序，如果这个时候想复用这个函数来进行其他类型的排序时，可以使用函数重载，也可以使用模板类和操作符重载来完成。\n这个时候可以直接使用委托，因为我们发现让函数可以比较多种类型，只需要更改函数的比较方式就可以。\n比如int用大于小于符号来比较，而字符串用compare函数来比较。\n我们直接用object来打包参数，用委托来打包方法。\npublic delegate bool Compare(object rh,object lh);//\n\npublic class Bubble    &#123;static public void sort(object[] sortarr,Compare cmp)        &#123;\tfor(int i&#x3D;0;i&lt;sortarr.Length ;i++)            &#123;\tfor (int j&#x3D;0;j&lt;i;j++)                &#123;\tif(cmp(sortarr[i],sortarr[j]))&#x2F;&#x2F;                    &#123;\tobject temp&#x3D;sortarr[i];                        sortarr[i]&#x3D;sortarr[j];                 \t\tsortarr[j]&#x3D;temp;&#125;\t\t\t\t                &#125;&#125;&#125;    &#125;\n\n此时可以说sort是“小组长”了，对于sort来说它的职责已经从“接收boss指令，执行boss指令”变成“接收boss的指令，根据需求来安排不同的员工（cmp）来执行指令”。当然，这个时候其实是对象自己来决定用什么方法进行比较的。\n在真正要进行比较的对象中，只需要具体安排一下适合于对象自己的比较方法就行：\npublic class employee&#123;\n    private float salary;\n    public employee(float sal)&#123;salary=sal;&#125;\n    public static bool RhLessThanLh(object lh,object rh)\n    &#123;return (((employee)lh).salary&lt;((employee)rh).salary)\n             ?true:false;&#125;//定义一个与委托兼容的函数\n \npublic static Compare empcmp=new Compare (RhLessThanLh); //定义一个静态的委托实例，以类的静态函数去初始化它。\n    &#125;\n\n\n在main函数中：\nemployee[] employees=\n     &#123;new employee (100),\n        new employee (80),\n        new employee (120)&#125;;\nBubble.sort(employees,employee.empcmp );&#125;\n\n&nbsp;\n多重委托\n委托也可以同时包含多个方法。\ndelegate void DEL(int a,int b);\n    class Class1\n    &#123;\tstatic void max(int a,int b)  &#123;Console.WriteLine (a&gt;b?a:b);&#125;\n        static void min(int a,int b)  &#123;Console.WriteLine (a&lt;b?a:b);&#125;\n        [STAThread]\tstatic void Main(string[] args)\n        &#123;\tDEL maxdel=new DEL (max);\n            DEL mindel=new DEL (min);\n            DEL dels=new DEL (max);\n            dels+=mindel;dels(3,5);\n//顺序调用max和min函数，如果函数有返回值,则只得到最后一个函数的返回值.\n            dels-=maxdel;\n            dels(3,5); //只调用min函数.\n        &#125;\n    &#125;\t\t\n\n&nbsp;\nC#事件\nGUI应用程序的机制——事件驱动\n\n\n消息传播伪代码：\ntypedef struct tagMSG &#123; \nHWND hwnd;            // 消息要发送到的窗口的句柄。\nUINT message;        //消息的唯一标识，在windows头文件中定义，以WM_为前缀\nWPARAM wParam; // 32位的消息参数，确切意义取决于消息本身\nLPARAM lParam;   //32位的消息参数，确切意义取决于消息本身\nDWORD time;        //消息放入队列的时间，windows使用其来保持消息的顺序\nPOINT pt;      // 消息放入消息队列时的鼠标坐标。\n&#125; MSG, *PMSG;\n\nLRESULT CALLBACK WndProc(HWND hWnd,           &#x2F;&#x2F; 窗口句柄UINT message,        &#x2F;&#x2F; 消息标识符WPARAM wParam, &#x2F;&#x2F; 消息参数1LPARAM lParam)    &#x2F;&#x2F; 消息参数2\n从窗口句柄中可以得到消息的发送目的地。\n从消息参数中可以提取消息的发送主体。\n\n可以直接让编译器来生成代码框架，而不是手动用SDK来一点点搭建GUI.\nvs.net -&gt;C++ windows\n&nbsp;\n相关的GUI模型\n\nMFC（MVC）\nVCL\n\n\n&nbsp;\nC#将以上事件（消息循环）进行面向对象封装，C#对象可以发布（publish）一组事件供其他类订阅（subscribe）。\n例如用鼠标点击图形化界面的某个按钮，这就是事件之一，不过事件不仅仅用于图形化界面，事件定义为“对象发送某种事情向类客户提供通知的一种方法”。\n&nbsp;\n事件参数类\nEventArgs是包含事件数据类的基类——不包含事件数据\n\n如果需要储存状态信息，则需要从此类派生出类来保存数据\n事件参数类是对Windows消息的封装与推广\n\n\n\n&nbsp;\n事件处理器\n处理事件的函数\n\nn事件发生后，处理该事件的函数称为事件处理器（event handler）。.net 规定这个函数具有如下形式：\nvoid SecondChangeHandler(object sender, TimeInfoEventArgs fe);//事件的发送者，任何对象都派生于object。//事件参数\n事件处理器具有如上的原型，因此可以使用delegate来定义之：\npublic delegate void SecondChangeHandler (object clock,    TimeInfoEventArgs timeInformation);\n事件处理器类比于窗口过程。（Windows Procedure）\n&nbsp;\nevent关键字\n发布事件的类以event关键字来表名此类有一个处理某种事件的处理器函数，即某delegate的实例。\nevent SecondChangeHandler OnSecondChange;\n&nbsp;\n发布事件类\npublic class Clock\n  &#123; private int hour;\n    private int minute;\n    private int second;\n     // 定义一个委托\n    public delegate void SecondChangeHandler\n      (object clock,TimeInfoEventArgs timeInformation);\n    // 定义一个事件,即以上委托的实例,由订阅者添加内容.\n    public event SecondChangeHandler OnSecondChange;\n  &#125;\npublic void Run()\n&#123;for(;;) //无限循环\n    &#123;Thread.Sleep(10); // sleep 10 milliseconds\n         System.DateTime dt = System.DateTime.Now;\n         if (dt.Second != second) //秒改变，通知订阅者\n             &#123;TimeInfoEventArgs timeInformation = new   \n             TimeInfoEventArgs( dt.Hour,dt.Minute,dt.Second);\n             if (OnSecondChange != null)\n             OnSecondChange( this,timeInformation); \n                //通知订阅者。\n             this.second = dt.Second;\n             this.minute = dt.Minute;\n             this.hour = dt.Hour; \n          &#125;\n      &#125;\n  &#125;\n\n\n订阅事件类\n决定事件到达后如何处理（事件处理器），必须与对应的delegate保持一致\n\npublic void TimeHasChanged(object theClock, TimeInfoEventArgs ti)\n其次，订阅事件类必须通过某种途径告知发布事件类，自己对发布事件类感兴趣,而且将对事件的到来采取何种动作：\npublic void Subscribe(Clock theClock)\n&#123;      theClock.OnSecondChange +=\n       new  Clock.SecondChangeHandler(TimeHasChanged);\n         //订阅事件类的其他方法\n       //新建一个发布事件类所定义的委托，初始化为自己的处理器，并赋值给发布事件类的事件。\n        //事件类的事件中可能存放有不同的订阅类的处理器,这是一个多重委托,事件发生时会按照订阅次序逐个通知他们.\n &#125;\n\n\n卢老师给的示例：\npublic class DisplayClock\n  &#123;public void Subscribe(Clock theClock)\n    &#123;      theClock.OnSecondChange +=\n    new Clock.SecondChangeHandler(TimeHasChanged);\n    &#125;  //也可以在订阅类的构造函数中实现。\npublic void TimeHasChanged(\n      object theClock, TimeInfoEventArgs ti)\n    &#123;   Console.WriteLine(&quot;Current Time: &#123;0&#125;:&#123;1&#125;:&#123;2&#125;&quot;,\n        ti.hour.ToString(), \n        ti.minute.ToString(), \n        ti.second.ToString());\n    &#125;\n  &#125;\n\npublic class LogCurrentTime\n  &#123;    public void Subscribe(Clock theClock)\n    &#123;   theClock.OnSecondChange +=\n        new Clock.SecondChangeHandler(WriteLogEntry);\n    &#125;\npublic void WriteLogEntry(\n      object theClock, TimeInfoEventArgs ti)\n    &#123;   Console.WriteLine(&quot;Logging to file: &#123;0&#125;:&#123;1&#125;:&#123;2&#125;&quot;,\n        ti.hour.ToString(), \n        ti.minute.ToString(), \n        ti.second.ToString());\n    &#125;\n  &#125;\n\n\npublic class Test\n   &#123;      public static void Main()\n      &#123;   Clock theClock = new Clock(); //发布事件类\n          DisplayClock dc = new DisplayClock();//订阅类\n         dc.Subscribe( theClock );//订阅\n          LogCurrentTime lct = new LogCurrentTime(); //另一订阅类\n         lct.Subscribe( theClock );//订阅\n         theClock.Run();\n      &#125;\n   &#125;\n\n\n","categories":["从C++开始的C#"]},{"title":"C++异常处理","url":"/2023/08/10/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"\n\n\n\n\nC++异常处理\n\n概述\n除数不能为0、索引数组元素不能为空、指针不能过界……\n最典型的异常处理方式是用if树做分支处理，剔除错误的路线\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;    int number1,number2;    if(number2!&#x3D;0)&#123;        cout&lt;&lt;(number1&#x2F;number2)&lt;&lt;endl;    &#125;    else&#123;        cout&lt;&lt;&quot;Divisor cannot be zero&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\nC++引入了异常处理机制。基本思想是：函数 A 在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给 A 的调用者，假定为函数 B。\n即“创建、抛出、获取和处理 ”一个异常。\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()&#123;    int number1,number2;    try&#123;        if(number2&#x3D;&#x3D;0)            throw number1;        cout&lt;&lt;(number1&#x2F;number2)&lt;&lt;endl;    &#125;    catch(int ex)&#123;        cout&lt;&lt;ex&lt;&lt;&quot;Divisor cannot be zero&quot;&lt;&lt;endl;    &#125;    return 0;&#125;\n\n正常情况下，try 块是应该运行的代码\nthrow就是异常信号，出现了这个就说明出现异常了，那么就带着“异常”抛出\n“异常”被catch接收，当出现异常时执行catch块，执行过后执行catch块的下一个语句；不出现时不执行catch块\n\n\n可以满足多个catch块，抛出的异常需要满足相对应catch块的接收类型才可执行，若接收不到相应类型，也就是说异常得不到处理，那么程序就立即中止\n\n可以捕获任何异常的块：catch(...){}\n\n如果对异常参数不感兴趣，也可以不写catch块参数\n\n&nbsp;\n异常抛出机制\n如果一个函数在执行过程中拋出的异常在本函数内就被 catch 块捕获并处理，那么该异常就不会拋给这个函数的调用者（也称为“上一层的函数”）；如果异常在本函数中没有被处理，则它就会被拋给上一层的函数。\n#include &lt;iostream&gt;\nusing namespace std;\n\nint quotient(int number1,int number2)&#123;    if(number2&#x3D;&#x3D;0)        throw number1;    return number1&#x2F;number2;&#125;\nint main&#123;    int number1,number2;    cin&gt;&gt;number1&gt;&gt;number2;\ntry&#123;\n    int result=quotient(number1,number2);\n    cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;\n&#125;\ncatch(int ex)&#123;\n    cout&amp;lt;&amp;lt;ex&amp;lt;&amp;lt;endl;\n&#125;\nreturn 0;\n\n}\n可见函数quotient抛出了异常，但函数本身并没有能接收的catch。但主函数中有。如果本函数没找到相应catch，那么就会返回上一级调用函数。\n这样的话处理异常就会非常方便，大程序中层层调用的小函数往往没有自己处理异常的能力（尤其是库函数），这个能力交给大函数统一处理更加方便\n\n如果拋出的异常是派生类的对象，而 catch 块的异常类型是基类，那么这两者也能够匹配，因为派生类对象也是基类对象。\n\nthrow写在catch内，这个叫做“重抛出异常”，这个时候异常被抛给调用者，用于无法处理异常或者想通知调用者发生了这么一个异常的情况\n\n\ntips:\n函数的异常声明列表\nvoid func() throw (int, double, A, B, C);\nvoid func() throw (int, double, A, B, C)&#123;...&#125;\n\n只是为了增强可读性，编译器一般也不会管他\n\n&nbsp;\n&nbsp;\n异常类\n一个异常其实往往需要抛出更多需要的信息，一个int类肯定远远不止。C++预定了很多可用于创建异常对象的类。\n\n\nexception根类包含一个虚函数what()，返回一个异常对象的错误信息\nruntime_error类是多个描述运行错误的标准异常类的基类，类overflow_error描述算数太大溢出，类underflow_error描述太小溢出\nlogic_error类是多个描述逻辑错误的标准异常类的基类，类length_error描述对象大小超过最大允许长度的错误，类out_of_range描述值超出允许范围的错误\nbad_alloc,bad_cast,bad_typeid和bad_exception类描述C++运算符抛出的异常。其中bad_alloc对应new运算符无法分配内存，bad_cast对应dynamic_cast在转换引用类型发生错误时的溢出，bad_typeid对应typeid在运算对象为空指针时抛出，bad_exception描述了从未遇到的异常\n\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nint quotient(int number1,int number2)&#123;    if(number2&#x3D;&#x3D;0)        throw runtime_error(&quot;Divisor cannot be zero&quot;);    return number1&#x2F;number2;&#125;\nint main&#123;    int number1,number2;    cin&gt;&gt;number1&gt;&gt;number2;\ntry&#123;\n    int result=quotient(number1,number2);\n    cout&amp;lt;&amp;lt;result&amp;lt;&amp;lt;endl;\n&#125;\ncatch(runtime_error&amp;amp; ex)&#123;\n    cout&amp;lt;&amp;lt;ex.what()&amp;lt;&amp;lt;endl;\n&#125;\nreturn 0;\n\n}\n//太深入的自定义类再学就消化不良了，先留个todo\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++指针","url":"/2023/08/14/C-%E6%8C%87%E9%92%88/","content":"\n\n\n\n常量指针\n\n前言\nC++指针有很多地方和C语言共通的，所以会忽略很多C指针基础知识，这篇最好有C指针基础再来批判\n\nint* p1,p2;看起来像声明了两个指针，其实不是，和int *p1,p2;等价\n\n可以用typedef语句避免这个错误，例如typedef int* intPointer，然后intPointer p1,p2;就声明了两个指针\n\n可以对指使用比较运算符来确定指针的先后次序\n\n&nbsp;\n常量指针\n这个点见8.11号的做题，涉及到了\n\n可以用const关键字声明一个常量，同样也可以用这个关键字声明指针，用于“固定”指向的位置。\ndouble radius = 5;\ndouble* const p = &amp;radius;\n\n\np是常量，但p指向的数据不是常量，是可以改变的\n\n\n如果把const放在数据类型之前\nconst double* p = &amp;radius\n\n那么指向的就是常量了\n当然如果两边都放\nconst double* const pValue = &amp;radius\n\n就是一个常量指针指向常量了\n&nbsp;\n数组与指针\n这一方面在C中已经很成熟了，那么就写一些容易混淆的\n\nlist[i]与*(list+i)等价，解引用比+优先，所以*(list+i)与*list+i情况不同\nC++中数组名的实质是一个常量指针，是不能改变的\n*p++值为arr[0]但是运行完后指向arr[1]，*++p是p先加一，再解引用，++*p是先解引用再加一\n\n\n&nbsp;\n函数内传指针与返回指针\n对于\nvoid f(int* p1,int* &amp;p2)&#123;&#125;//函数\n    \nf(q1,q2);&#x2F;&#x2F;调用，q1,q2为指针\n结果为：\n\nq1传值给p1，使得指向的内容都一致，再函数内直接更改内容，使得外部内容同样遭到更改。但若更改p1的指向，那么函数外的q1其实不受影响\nq2传引用给p2，所以q2是p2的别名，那么无论什么修改就会共同影响\n\n\n&nbsp;\n函数返回指针：\n这是一个用于反转数组的一个函数\nint* reverse(int* list,int size)&#123;\n    for(int i = 0;j=size - 1;i&lt;j;i++,j--)&#123;\n        int temp=list[j];\n        list[j]=list[i];\n        list[i]=temp;\n    &#125;\n    return list;\n&#125;\n\n&nbsp;\n数组函数API\n\nmin_element，max_element返回数组中最小、最大元素的指针\n\n\ne.g. min_element(list,list+6)返回数组中list[0],list[5]之间最小元素的指针\n\n\nsort对数组进行排序\nrandom_shuffle随机安排数组元素排序\nfind寻找匹配元素指针\n\n\n&nbsp;\nthis指针\nthis只能出现在类的内部，通过this可以访问类的所有成员，包括private内的。在对象创建后才有意义\n\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Student&#123;public:    void setname(char *name);    void setage(int age);    void setscore(float score);    void show();private:    char *name;    int age;    float score;&#125;;\nvoid Student::setname(char *name)&#123;    this-&gt;name &#x3D; name;&#125;void Student::setage(int age)&#123;    this-&gt;age &#x3D; age;&#125;void Student::setscore(float score)&#123;    this-&gt;score &#x3D; score;&#125;void Student::show()&#123;    cout&lt;&lt;this-&gt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;this-&gt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;this-&gt;score&lt;&lt;endl;&#125;\nint main()&#123;    Student *pstu &#x3D; new Student;    pstu -&gt; setname(&quot;李华&quot;);    pstu -&gt; setage(16);    pstu -&gt; setscore(96.5);    pstu -&gt; show();\nreturn 0;\n\n}\n其中发现，类中函数的形参与类中参数重名，这就是一种不得不使用this的情况\n&nbsp;\n拷贝构造函数\n拷贝构造函数可以用来创造一个对象，并用另一个对象的数据初始化新建对象\n\nClassName(const ClassName&amp;)\n和构造函数一样，C++会隐式提供一个缺省的拷贝构造函数（没有主动定义的情况下）。\n如果新建一个新对象，将所有参数一个个复制过去，这个思路是和拷贝构造函数是一致的，不过拷贝构造函数会自动新建对象。\n\n浅拷贝：上述两种拷贝方式都叫浅拷贝\n\n\n对于指针参数来说，浅拷贝会将指针地址也拷贝过去，所以两个对象中的指针就同时指向一个地址了，这不是我们想要的\n\n\n深拷贝：可以在拷贝构造函数中自定义\n\n\n\n","categories":["从C开始的C++"]},{"title":"2D角色控制器","url":"/2023/07/30/2D%E8%A7%92%E8%89%B2%E6%8E%A7%E5%88%B6%E5%99%A8/","content":"\n\n\n\n\n注！！！！这个Unity角色控制器是自定义的物理组件制作的（不存在刚体和碰撞体）\n\n解析的开始，先附上源码：https://github.com/Matthew-J-Spencer/Ultimate-2D-Controller\n额外付费部分：https://www.patreon.com/tarodev\nb站转载：【Unity】好手感从何而来？一款免费的2D角色控制器，附源码哔哩哔哩bilibili\n前言\n\n开篇之前我想先聊一聊\n这篇文章用于讲述类笔记\n在写它之前我对控制器原理其实一无所知\n是在学习的过程中当成学习笔记写得的\n所以说，如果真有缘有人能对我这篇文章感兴趣\n理论上哪怕你是真小白，对unity一窍不通\n也是能看懂的\n因为只要是我不明白的地方我都会对其解释\n哪怕是最基础对象操作或者属性性质等知识\n学习效率非常低，而且全靠自学，唯一有帮助的就是Chatgpt辅助调查\n前前后后也解析了近半个月时间\n希望读者能轻喷\n\n&nbsp;\n注！！！！这个Unity角色控制器是自定义的物理组件制作的（不存在刚体和碰撞体）\n为了玩家手感它甚至抛弃了Unity自带的物理系统逻辑方式！\n所以除了该作者本身定义出的交互方式，无法使用Unity自带组件的几乎任何交换方式！\n所以这篇文章的目的，就是记录我重构这个控制器的过程，使他在可能降低手感的前提下，提高对Unity物理系统的适应性（人家好不容易弄好的你给还原回去了是吧）\n当然，做这个的主要是出于 学习目的!\n\n&nbsp;\n代码总览（Update（）函数）\nprivate void Update() &#123;\n        if(!_active) return;\n        // Calculate velocity\n        Velocity = (transform.position - _lastPosition) / Time.deltaTime;\n        _lastPosition = transform.position;\n\n    GatherInput();\n    RunCollisionChecks();\n\n    CalculateWalk(); // Horizontal movement\n    CalculateJumpApex(); // Affects fall speed, so calculate before gravity\n    CalculateGravity(); // Vertical movement\n    CalculateJump(); // Possibly overrides vertical\n\n    MoveCharacter(); // Actually perform the axis movement\n&#125;\n\n\n&nbsp;\n以下是原作者@Tarodev对该组件的教学描述\n&nbsp;\n首先是把所有对应模块一块块区分开来，化整为零，逐个击破，最后也方便形成框架\n&nbsp;\n提前跳跃释放模块\n\n这个主要用来控制跳跃高度，比如提前释放跳跃键，这是作者当成特色介绍的模块\n这里先介绍一个2D游戏常用跳跃技巧：郊狼跳（coyote）\n\n\n玩家在玩游戏的时候，会经常遇到很多和人脑直觉相对的东西\n例如fps游戏中，使用狙击枪打击一个超远距离的敌人有时候并不是一个很明智的选择，因为超低的命中率和巨大的枪声很容易暴露自己的位置、浪费资源，最后往往造成形势的逆转。\n但作为一款电子游戏，狙击枪的存在就是为了给予狙击枪玩家一种 超远距离击杀敌人的快感，所以提高玩家玩狙击枪的命中率，将玩家”伺候“得好好的成了众多fps游戏程序员的一门必修课\n玩过《APEX传奇》中的传奇“万蒂奇”肯定会有更深的体会\n\n图片来源bilibili@是千智哥啊\n\n在《APEX传奇》中狙击枪在打击远距离敌人时，子弹会随飞行时间增大碰撞体积，这样就能专门针对“远距离打击”的情况来增加命中率而且看起来不“bug”，这对“万蒂奇”的大招技能会体现得更明显一点，这就是一个游戏面对玩家更加“宽容”的一个典型的例子\n回到2D跳跃游戏里，“郊狼跳”的具体形式就是当系统检测到玩家脱离平台下落时，会设置一个短计时器让玩家在这个短时间内也能做出跳跃动作，这样就能有效避免玩家认为还没走出平台，结果系统检测已经走出平台开始下落，然后无法做出跳跃动作的情况\n\n同样也是一个“宽容”的很好方式，为玩家增添手感\n参考知乎@斯锅特\n\n\n如下为源代码中全部的跳跃模块（其中涉及到一些重力控制模块，后面会解释）\n#region Jump\n\n[Header(&amp;quot;JUMPING&amp;quot;)] [SerializeField] private float _jumpHeight = 30;\n[SerializeField] private float _jumpApexThreshold = 10f;\n[SerializeField] private float _coyoteTimeThreshold = 0.1f;\n[SerializeField] private float _jumpBuffer = 0.1f;\n[SerializeField] private float _jumpEndEarlyGravityModifier = 3;\nprivate bool _coyoteUsable;\nprivate bool _endedJumpEarly = true;\nprivate float _apexPoint; // Becomes 1 at the apex of a jump\nprivate float _lastJumpPressed;\nprivate bool CanUseCoyote =&amp;gt; _coyoteUsable &amp;amp;&amp;amp; !_colDown &amp;amp;&amp;amp; _timeLeftGrounded + _coyoteTimeThreshold &amp;gt; Time.time;\nprivate bool HasBufferedJump =&amp;gt; _colDown &amp;amp;&amp;amp; _lastJumpPressed + _jumpBuffer &amp;gt; Time.time;\n\nprivate void CalculateJumpApex() &#123;\n    if (!_colDown) &#123;\n        // Gets stronger the closer to the top of the jump\n        _apexPoint = Mathf.InverseLerp(_jumpApexThreshold, 0, Mathf.Abs(Velocity.y));\n        _fallSpeed = Mathf.Lerp(_minFallSpeed, _maxFallSpeed, _apexPoint);\n    &#125;\n    else &#123;\n        _apexPoint = 0;\n    &#125;\n&#125;\n\nprivate void CalculateJump() &#123;\n    // Jump if: grounded or within coyote threshold || sufficient jump buffer\n    if (Input.JumpDown &amp;amp;&amp;amp; CanUseCoyote || HasBufferedJump) &#123;\n        _currentVerticalSpeed = _jumpHeight;\n        _endedJumpEarly = false;\n        _coyoteUsable = false;\n        _timeLeftGrounded = float.MinValue;\n        JumpingThisFrame = true;\n    &#125;\n    else &#123;\n        JumpingThisFrame = false;\n    &#125;\n\n    // End the jump early if button released\n    if (!_colDown &amp;amp;&amp;amp; Input.JumpUp &amp;amp;&amp;amp; !_endedJumpEarly &amp;amp;&amp;amp; Velocity.y &amp;gt; 0) &#123;\n        // _currentVerticalSpeed = 0;\n        _endedJumpEarly = true;\n    &#125;\n\n    if (_colUp) &#123;\n        if (_currentVerticalSpeed &amp;gt; 0) _currentVerticalSpeed = 0;\n    &#125;\n&#125;\n\n#endregion\n\n\n首先直接看方法CalculateJumpApex()与CalculateJump()\n\n可从之前的定义中得知_colDown是一个布尔值，意思为“对象下界是否与平台产生碰撞”，这个变量还涉及一层又一层的检测函数的和变量改动，不过单这个模块可以先理解到这里。\n\nMathf.Lerp是一个脚本API，输入三个float值a、b、t（t为0~1），当t为0是返回a，当t为1时返回b，当t为0.5时返回中间点，常用于创造出更平滑的动画效果等。\n通常情况下，我们把设置的当前速度为a，设置最大速度为b，然后设置用加速度与上一帧时间相乘计算出来的插值因子t来返回物体当前速度，来形成一种带最大速度的平滑加速的效果，如果你能细细品味我这一段话，会发现这个函数会趋向于这样\n\nVn为新速度，t为时间变量，Vm为固定的最大速度，V为当前速度\n这个公式会随帧率不断计算，由于V不断趋向于Vm，导致时间变量造成的影响越来越小，所以越接近Vm变化越慢，这是几乎所有与速度相关的插件都会用到的方式，与直接用加速度比起来的优势：\n\n公式是逐帧计算的，物体不会因为帧率的改变导致做出与游戏逻辑不符的变化\n在没达到最大需求时变化会非常快，快达到时变化会非常小，能达到平滑的效果\n\n\n\n在这个脚本中，Mathf.Lerp的使用其实没有我说的这么麻烦，他单纯地规定了最大下落速度与最小下落速度，然后通过顶点值来计算当前速度，有趣的是_apexPoint值。\n这个值是通过物体垂直的速度绝对值来计算的，当速度接近_jumpApexThreshold时，_apexPoint的值会接近于0，说明远远未到达顶点，到达顶点时，则应该为0\n//这个地方一直有点不太明白\n当然，顶点值会限制在0~1之间以方便作为t值使用。\n\nMathf.InverseLerp()与前者相反，目的是计算出value在a与b之间所成比例的参数，具体算法为（value-a）/（b-a）。\n\n\n\n\n_jumpApexThreshold是一个跳跃顶点函值，用于确定物体在到达顶点之前需要跳多高。\n\n下落速度也一样，使用Lerp保证越接近最高点重力越强，以上可知_apexPoint是一个比例，规定在0~1之间，也就是说作刚体y轴速度配合来计算出者很擅长利用这些Unity中的复杂数学API，用数学函数实现了对象在跳跃过程中在最高点那一瞬间的平滑丝滑感，令人不得不佩服。\n\n\n\n注意这个_apexPoint,之后其他模块中也会涉及\n\n以上规定了对象在跳跃最高点的物理逻辑\n\nTime.time的运用个人理解为保证游戏是在启动是开始判断，属于一个很好的编码习惯。\nHasBufferedJump作者判断为跳转缓冲区，即开始涉及跳转缓冲和郊狼时间了。\n\n\n注意这个，后面也会涉及另一个模块\n\n\n当触发发生郊狼或者缓冲时刻时时触发以下动作：1、垂直速度 _currentVerticalSpeed变为设置的跳跃高度，目的是方便缓冲模块设定。2、_endedJumpEarly赋为假，是一个“提早停止跳跃的标识符”3、_coyoteUsable赋为假，是一个郊狼时间标识符4、_timeLeftGrounded是啥？//5、JumpingThisFrame赋为真，是一个下落动作相关的标识符。6、普通落地时，直接触发动画。\n提早取消跳跃键逻辑解读：!_colDown&amp;&amp;Input.JumpUp&amp;&amp;!_endedJumpEarly&amp;&amp;Velocity.y&gt;0如果触发这个条件，则将_endedJumpEarly关键词赋为真，其实字面意思理解就好\n还有一句如果触顶则停止，这个不用解读了\n由此可见，具体的动作触发大多通过布尔值关键字的改变来运作，这是一个很好的编写习惯，分开的判断与实现更方便代码的维护与更新\n小tips：float.MinValue指浮点值最小的值，即为最负的值，常用于在不初始化变量的情况下让变量能够与某类型比对的情况\n\n\n&nbsp;\n“顶点修改器”\n\n这个一个增强2D游戏角色的一个很好的方式，角色在进行高跳时，系统会给予角色一个很大的助推来保证玩家能很好地控制落点，这是一个夸张的效果：\n\n这个模块参杂在上面的跳跃模块和走路模块中（以下是走路模块）：\n #region Walk\n[Header(&quot;WALKING&quot;)] [SerializeField] private float _acceleration = 90;\n[SerializeField] private float _moveClamp = 13;\n[SerializeField] private float _deAcceleration = 60f;\n[SerializeField] private float _apexBonus = 2;\n\nprivate void CalculateWalk() &#123;    if (Input.X !&#x3D; 0) &#123;        &#x2F;&#x2F; Set horizontal move speed        _currentHorizontalSpeed +&#x3D; Input.X * _acceleration * Time.deltaTime;\n    // clamped by max frame movement\n    _currentHorizontalSpeed = Mathf.Clamp(_currentHorizontalSpeed, -_moveClamp, _moveClamp);\n\n    // Apply bonus at the apex of a jump\n    var apexBonus = Mathf.Sign(Input.X) * _apexBonus * _apexPoint;\n    _currentHorizontalSpeed += apexBonus * Time.deltaTime;\n&#125;\nelse &#123;\n    // No input. Let&amp;#39;s slow the character down\n_currentHorizontalSpeed = Mathf.MoveTowards(_currentHorizontalSpeed, 0, _deAcceleration * Time.deltaTime);\n&#125;\n\nif (_currentHorizontalSpeed &amp;gt; 0 &amp;amp;&amp;amp; _colRight || _currentHorizontalSpeed &amp;lt; 0 &amp;amp;&amp;amp; _colLeft) &#123;\n    // Don&amp;#39;t walk through walls\n    _currentHorizontalSpeed = 0;\n&#125;\n\n}\n#endregion\n\n\n其中核心关键词为_apexBonus,_apexPoint,apexBonus,_currentHorizontalSpeed\n\n_apexBonus为设置的“修改力度”变量，设置越大，则显示更加夸张\n_apexPoint前文中提到过随跳跃高度变化，映射最大高度的值被限制在一定范围内\n最终生成的apexBonus与Time.deltaTime相乘得出最终速度_currentHorizontalSpeed\n\n\n在计算最终速度时乘以一个Time.deltaTime是经常的做法，这个函数返回上一帧的时间间隔，以秒为单位，所以游戏时间逻辑会严格按照游戏帧数运行而不是现实时间，正常情况下当成一个常值即可\n\n&nbsp;\n跳跃缓冲\n\nprivate bool HasBufferedJump =&gt; _colDown &amp;&amp; _lastJumpPressed + _jumpBuffer &gt; Time.time;\n\n在跳跃模块中，这个式子被定义为HasBufferedJump，同时在土狼时间中出现，与土狼时间相或，并执行同样的结果\n在此之前，我们先查看一下用于检测输入的代码块\n#region Gather Input\n\nprivate void GatherInput() &#123;    Input &#x3D; new FrameInput &#123;        JumpDown &#x3D; UnityEngine.Input.GetButtonDown(&quot;Jump&quot;),        JumpUp &#x3D; UnityEngine.Input.GetButtonUp(&quot;Jump&quot;),        X &#x3D; UnityEngine.Input.GetAxisRaw(&quot;Horizontal&quot;)    &#125;;    if (Input.JumpDown) &#123;        _lastJumpPressed &#x3D; Time.time;    &#125;&#125;#endregion\n\nUnityEngine.Input.GetButtonDown(&quot;Jump&quot;)：检测 Jump 虚拟按钮是否在当前帧被按下。\nUnityEngine.Input.GetButtonUp(&quot;Jump&quot;)：检测 Jump 虚拟按钮是否在当前帧被释放。\nUnityEngine.Input.GetAxisRaw(&quot;Horizontal&quot;)：获取水平方向上的输入状态。这个方法返回一个浮点数，表示水平方向上输入设备的状态。如果玩家按下左箭头或 A 键，返回的值为 -1；如果玩家按下右箭头或 D 键，返回的值为 1；如果玩家没有按下任何键，返回的值为 0。\n\n\n在JumpDown按下时，_lastJumpPressed记录按下时的游戏时间，也就是“记住了”按下时这个动作\n因为Input这个类中，所有的检测都是只能检测“按下的瞬间”，在下一个Update函数运行时全部还原，所以要通过一个另外的变量来记录\n回到HasBufferedJump\n\n变量一：_coldowm说明是否在地面上，毕竟只能在地面上才能跳跃\n变量二：Time.time减去_lastJumpPressed，如果结果小于缓冲时间_jumpBuffer，则说明现在的时间还处于缓冲时间内（只有Time.time为变量）\n总结：跳跃缓冲会使角色还在天上的时候如果按下跳跃键，则将跳跃并入“队列”中，当角色落地时自动立刻再次完成一次跳跃，深入地讲，就是玩家在每次按下“跳跃键”时，都会被_lastJumpPressed所记录，如果角色在地面上正常跳跃，则“跳跃时间”加任何一个正数“缓冲时间”肯定大于“当前时间“，因为在地面上的当前时间就是跳跃时间，那么按照这个算法角色完成正常跳跃；如果角色在天上，角色是没办法进行跳跃的，则算法会不断地在缓冲时间内不停地触发“跳跃”动作，直到角色落地正常跳跃\n\n\n\n\n\n&nbsp;\n土狼跳模块\n\nprivate bool CanUseCoyote =&gt; _coyoteUsable &amp;&amp; !_colDown &amp;&amp; _timeLeftGrounded + _coyoteTimeThreshold &gt; Time.time;\n\n源码中的模块表现形式和前者及其相似\n由于已经分析过跳跃缓冲时间的代码，所以这里很容易得出CanUseCoyote为真的条件为_coyoteUsable（土狼时间可用）,!_colDown（角色不在地面上）,当前时间还处于土狼时间函值内\n\n_timeLeftGrounded 字段用于记录角色离地时间，源代码如下：\n\n\nLandingThisFrame = false;\nvar groundedCheck = RunDetection(_raysDown);\nif (_colDown &amp;&amp; !groundedCheck) _timeLeftGrounded = Time.time; // Only trigger when first leaving\nelse if (!_colDown &amp;&amp; groundedCheck) &#123;\n     _coyoteUsable = true; // Only trigger when first touching\n     LandingThisFrame = true;\n&#125;\n_colDown = groundedCheck;\n\n对于向下的射线，如果上一帧玩家与地面接触且当前不再接触地面，则将_timeLeftGrounded设置为当前时间；如果上一帧玩家未接触地面且当前接触地面，则将_coyoteUsable设置为true\n可以说_colDown用于储存上一帧角色是否接触地面，而_raysDown用于检测当前是否接触地面\n\n\n_colDown与groundedCheck的相互交织应用实现了测量“跳出一瞬间”与“接触一瞬间”这两种瞬时情况\n之后，用_coyoteUsable与LandingThisFrame这两个标记来记录情况变化\n\n\n当然，从这里可看出，若再附加一个“二段跳”功能\n&nbsp;\n跳跃速度控制\n\n按原作者的话说，角色下落时有一个最大速度不仅增加了角色的可控性，也能更加方便设计师设计一些下落相关的关卡\n&nbsp;\n边缘检测\n\n这是这个控制器中与移动相关的代码块\n[Header(&quot;MOVE&quot;)] [SerializeField, Tooltip(&quot;Raising this value increases collision accuracy at the cost of performance.&quot;)]\n    private int _freeColliderIterations = 10;\n\n// We cast our bounds before moving to avoid future collisions\nprivate void MoveCharacter() &#123;\n    var pos = transform.position + _characterBounds.center;\n    RawMovement = new Vector3(_currentHorizontalSpeed, _currentVerticalSpeed); // Used externally\n    var move = RawMovement * Time.deltaTime;\n    var furthestPoint = pos + move;\n\n    // check furthest movement. If nothing hit, move and don&amp;#39;t do extra checks\n    var hit = Physics2D.OverlapBox(furthestPoint, _characterBounds.size, 0, _groundLayer);\n    if (!hit) &#123;\n        transform.position += move;\n        return;\n    &#125;\n\n    // otherwise increment away from current pos; see what closest position we can move to\n    var positionToMoveTo = transform.position;\n    for (int i = 1; i &amp;lt; _freeColliderIterations; i++) &#123;\n        // increment to check all but furthestPoint - we did that already\n        var t = (float)i / _freeColliderIterations;\n        var posToTry = Vector2.Lerp(pos, furthestPoint, t);\n\n        if (Physics2D.OverlapBox(posToTry, _characterBounds.size, 0, _groundLayer)) &#123;\n            transform.position = positionToMoveTo;\n\n            // We&amp;#39;ve landed on a corner or hit our head on a ledge. Nudge the player gently\n            if (i == 1) &#123;\n                if (_currentVerticalSpeed &amp;lt; 0) _currentVerticalSpeed = 0;\n                var dir = transform.position - hit.transform.position;\n                transform.position += dir.normalized * move.magnitude;\n            &#125;\n\n            return;\n        &#125;\n\n        positionToMoveTo = posToTry;\n    &#125;\n&#125;\n\n#endregion\n\n\n先易后难，首先是初始化阶段\nvar pos = transform.position + _characterBounds.center\n这一段看起来是将两个坐标相加，初看看不出什么意义，但我们应该提前知道_charactweBounds.center是一个局部坐标，是相对于对象坐标的一个相对坐标，所以说这两个坐标相加后的初始坐标pos就变成了包围盒中心所在的坐标（由于计算碰撞肯定用包围盒）\n&nbsp;\n最终计算出来坐标并没有立即更新给对象，而是赋予给了furthestPoint，然后再将这个坐标参数结合包围盒数据，在目标地点“模拟”出一个“未来”包围盒，再使用Physics2D.OverlapBox函数检测是否碰撞，至此，初始化完成\n\nPhysics2D.OverlapBox详解：四个参数依次为：检测中心，检测物大小，检测物角度，勘探图层。最后返回勘探区域内的所有碰撞体\n大小size用坐标表示，给出长宽深\n\n\n\n\n然后就是两个大结构：\nif(!hit)&#123;\n    //正常更新坐标并返回大函数\n&#125;\n//发现预料碰撞，则从pos递增位置，更新到碰撞那一瞬间\nvar positionToMoveTo = transform.position;\nfor(int i=1;i&lt;_freeColliderIterations;i++)&#123;\n    //在碰撞路程内一次次分段，在每个段中寻找可能路线\n&#125;\n\n这里重点放在对碰撞路径的探索中，也就是分段for循环中\n在这个模块开头其实有要求设置一个数据_freeColliderIterations，这个其实就是决定了这个for循环的次数，而这个for循环的本质是将pos原位置与“未来位置”中间的路段进行分段，然后在一个个分段中寻找，这个参数就是分的段数\n\nposToTry就是此段到达的位置，这个由前文提到 过的Lerp 函数得出，在每次循环最后赋值给positionToMoveTo当中\n\n\n如果分段递增过程中某一段有碰撞，即进入新的条件事件中，首先\ntransform.position = positionToMoveTo\n更新目标位置（这个positionToMoveTo是前一段的位置）\nok，从这里之前的所有代码，其实都是符合unity自带碰撞的物理逻辑，即“遇到碰撞体然后停下”，但是很明显我们是不需要这种逻辑的，我们在更改游戏包容性的过程中，需要舍弃这个逻辑然后自行进行更改\n先查看上下文，发现实际对象改变位置只有这一个地方，而且若没有满足条件，则直接return返回\n所以在发生条件路径之前，程序的结果都是将对象移动到该移动的地方，直到最后碰撞前一瞬间，而且这最后一段移动是不按帧逻辑来的，也就是说\n\n红色数字为帧数，第二帧与第三帧之间发生碰撞，则程序在第二帧瞬间将位置更新到碰撞位置（若分段发生碰撞）\n\n更新位置后必return，也就是说下一次判断发生在下一帧更新，这个时候重新进入该函数，此时i必为1（不设为1则会发生对象未到碰撞地点就触发”边缘检测“动作）\n\n由主函数目录中知，move函数最后计算，在重新开始新的一帧时水平速度与垂直速度都会重新开始计算，这一句if (_currentVerticalSpeed &lt; 0) _currentVerticalSpeed = 0;其实是作用于”对象触顶“的情况，若触顶，按照碰撞逻辑停止，然后return之后先运行重力函数，垂直速度必为负，在这个代码块中重置垂直速度来避免重力对边缘检测的影响（而且若边缘检测发生在平台爬升的阶段，不发生触顶，则不会触发这个条件，也就不会重置\n\n\n\nvar dir = transform.position - hit.transform.position;transform.position += dir.normalized * move.magnitude;使得对象被轻轻推开,就像\n\n\n\n看见那个弯弯折折没\n\n这个原理其实就把所有碰撞体在发生边缘检测时都默认为了圆形（试想一下物体在一堆球中一直前进）\n随后return，进入下一帧计算\n\n&nbsp;\n结语\n&nbsp;\n这个角色控制器只是@Tarodev对角色控制器的第一版，不按照unity本身自带碰撞要求实现的一系列功能，很显然这对游戏开发者来说是很不方便的，但是无论适不适配碰撞，这些改变手感的原理都是一致的，所以这个模板有很大的学习价值（很难受的是受限于精力与能力，这个拆解尚存在太多错误/可能/与疑问未能及时解决）\n在最终完成这篇文章之前，我一直在使用@Tarodev的第二版控制器，这个控制器适配了unity碰撞与刚体，而且加了很多新的功能（冲刺等），如果有时间，我会对第二版进行更完善的拆解\n&nbsp;\n\n","categories":["游戏设计杂谈"]},{"title":"C#操作符重载","url":"/2023/11/06/C-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD/","content":"\n\n\n\n\nC#运算符重载\n\n运算符重载\nC#也是支持运算符重载的\n&nbsp;\nC++与C#\nC++中：\npublic  Complex operator + (Complex a)\n        &#123; \n    return new Complex (real+a.real ,imaginary +a.imaginary );\n&#125;\n\nC#中：\npublic static Complex operator + (Complex a)\n    &#123; \n    return new Complex (real+a.real ,imaginary +a.imaginary );\n&#125;\n\n只能使用public static\n&nbsp;\n相等\n1.值相等——北京的山和上海的山都是山\n2.地址相对——北京的山是北京的山，上海的山是上海的山\n地址相对，肯定值相对；值相等，地址不一定相对\n\n引用类型代表地址，值类型代表遍历本身。\nC#中的指针已经不热衷于使用它了，所以在考虑地址相关的时候要让操作人员更加清晰。\nC#中的相等：\n\n==有的类型定义了，有的类型没有定义，程序员可以重载\nEquals是object类的虚函数，被所有类继承\n\n\npublic class C\n    &#123;\n        public int i;\n        public C(int pi)\n        &#123; this.i = pi; &#125;\n    &#125; \n\npublic struct S    &#123;        public int i;        public S(int pi)        &#123; this.i &#x3D; pi; &#125;    &#125; \nint i &#x3D; 1;int j &#x3D; 1;bool f &#x3D; (i &#x3D;&#x3D; j);&#x2F;&#x2F;truef &#x3D; (i.Equals(j));&#x2F;&#x2F;turestring m &#x3D; &quot;hello&quot;;string n &#x3D; &quot;hello&quot;;f &#x3D; (m &#x3D;&#x3D; n);&#x2F;&#x2F;truef &#x3D; (m.Equals(n));&#x2F;&#x2F;trueobject g &#x3D; m;object h &#x3D; n;f&#x3D;(g &#x3D;&#x3D; h);&#x2F;&#x2F;truef&#x3D;(g.Equals(h));&#x2F;&#x2F;trueS s1&#x3D;new S(1);S s2&#x3D;new S(1);f&#x3D;(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;不支持&#x3D;&#x3D;需要手工重载f&#x3D;(s1.Equals(s2));&#x2F;&#x2F;true,值比较C c1 &#x3D; new C(1);C c2 &#x3D; new C(1);f&#x3D;(c1&#x3D;&#x3D;c2);&#x2F;&#x2F;false，地址不同f&#x3D;(c1.Equals(c2));&#x2F;&#x2F;false，默认用的object的Equals也是比较地址\n\npublic static bool operator&#x3D;&#x3D;(S s1,S s2)&#123;    return s1.i&#x3D;&#x3D;s2.i;&#125;public static bool operator!&#x3D;(S s1,S s2)&#123;    return s1.i!&#x3D;s2.i;&#125;&#x2F;&#x2F;编译器要求同时重载!&#x3D;\npublic override bool Equals(object?obj)&#123;    if(object.ReferenceEquals(this,obj))&#x2F;&#x2F;使用object的静态函数判断地址是否相同        return true;    else&#123;&#x2F;&#x2F;如果不同则比较值        if(other&#x3D;&#x3D;null) return false;        C?other&#x3D;obj as C;&#x2F;&#x2F;将obj类型变量转换成C类型        if(other.i&#x3D;&#x3D;this.i) return true;        else return false;    &#125;&#125;\n&#x2F;&#x2F;对于S，编译器会要求进行\n&nbsp;\nsummary\n\n==对于值类型比较值，对于引用类型比较是否是用一个对象的引用\nEquals总是比较值\nstring是引用类型，但是与值类型类似\n\n\n&nbsp;\n对于自定义class，按理说需要和C#默认的设置相同，但是可以通过这种方式将其改写。（需要同时改写==与!==）\n出现警告CS0661——需要重写GetHashCode()函数\n是有关GetHashCode()\n一般情况下，哈希代码可以被所有对象获取，就是用过虚GetHashCode方法\n如果两个类型相同的对象表示相同的值，则哈希函数必须为两个对象返回相同的常数值，这样的话，hash值相同，对象不一定相等\n直接重写相等运算符，容易发生哈希冲突\n哈希冲突会导致寻找新地址，从而导致运行速度会变慢，性能降低\n如果能自己重写GetHashCode会更好\n\n public override int GetHashCode()\n            &#123;\n                return this.real.GetHashCode();\n            &#125;\n\n讲太快课件版本又不一样这里突然给我干懵逼了😓\n\n&nbsp;\n\n","categories":["从C++开始的C#"]},{"title":"C++新特性","url":"/2024/10/01/C-%E6%96%B0%E7%89%B9%E6%80%A7/","content":"\n\n\n\n\n# C++新特性\n\nC++新特性\n&nbsp;\nemplace_back和push_back，完美转发\n两者都是想stl添加元素。\n前者直接在stl末尾构造对象，后者是先构造一个临时对象，然后再移动甚至拷贝过去。\n当然前一句话只是这两个api的“目的”\n实际使用的时候却不一定会按照意愿来。\n&nbsp;\n\n有关两者对性能上的优化，可以从三个方面入手\n\n\n\t\t——构造，移动，复制\n&nbsp;\n\n根据两者不同的使用环境，也会做出不一样的表现\n——传左值，传右值，传对象，传类型，传引用。。。。。。\n\n\n\n&nbsp;\n\n如果是对象，也会更具对象是否包含各类构造函数产生不同的表现\n\n\n&nbsp;\n一一举例子\nvector&lt;int&gt; vec;\nvec.push_back(1);\nvec.emplace_back(1);\n\n简单类型，两者没有差异，但是内部调用区别却很大。这里循序渐进留到最后说。\n&nbsp;\nA a(1);\nvector&lt;A&gt; vec;\nvec.push_back(a);\nvec.emplace_back(1);\n\nemplace_back不能直接接受对象做参数，因为他要直接接受对象的构造函数参数，然后在容器内直接进行构造。\n\npush_back做的事：\n\n使用拷贝构造函数，通过传递过来的对象a，拷贝出另一个临时对象     +拷贝\n将拷贝出的临时对象插入容器尾部\n\n\n\nemplace_back做的事：\n\n使用构造函数，通过传递过来的参数，直接在容器内构造出一个对象 \t+构造\n\n\n\n\n\n如果涉及深拷贝操作，那么拷贝可能会比构造性能消耗更大。\n这里的主流观点都是emplace_back进行了性能优化。\n因为要注意到的是，虽然单看后面两句，可能还存有到底是拷贝还是构造更消耗性能的争议，但是push_back执行这一语句的前提是已经构造出一个对象了（+构造），所以如果只是有参数，那么用emplace_back肯定会更好点。\n当然也有说法是如果已经存在对象，在无视对象构造的前提下，最好使用push_back，不过我认为具体问题具体分析，根据需求实际测试性能损耗会更好些。\n&nbsp;\nA a(1);\nvector&lt;A&gt; vec;\nvec.push_back(std::move(a)); //move函数将类型转换为右值\nvec.emplace_back(1);\n\npush_back有新重载（C++11之后）：\n//可以看到，里面都是调用的emplace_back函数\nvoid push_back(const _Ty&amp; _Val)\n&#123;\t// insert element at end, provide strong guarantee\n    emplace_back(_Val);\n&#125;\n        \nvoid push_back(_Ty&amp;&amp; _Val)&#123;\t&#x2F;&#x2F; insert by moving into element at end, provide strong guarantee    emplace_back(_STD move(_Val));&#125;\n注意C++11引入右值之后大部分源码发生变化\n\n如果传递的是左值（由于使用常量引用参数进行了修饰则可以被emplace_back传递），他会通过对象的参数类型来重新构造函数。之后emplace_back由于收到的是左值，所以调用的是拷贝构造函数，重新对对象进行构造（+拷贝）。\n如果传递的是右值，则调用移动构造函数进行构造(+移动)，很明显，移动要比重新构造性能上好很多。这里如果原对象没有移动构造函数，则会调用拷贝构造函数，白白浪费性能。\n值得注意的是，使用emplace_back并不会总是执行移动构造，若参数为左值，则拷贝构造，右值则移动构造。\n\n所以说上面的例子，如果更换成右值，那么push_back会被优化成emplace_back：\nA a(1);\nvector&lt;A&gt; vec;\nvec.push_back(a);\nvec.emplace_back(1);\n\nvector&lt;A&gt; vec;vec.push_back(a()); &#x2F;&#x2F;这里push_back本身的调用和emplace_back一致只调用移动构造，但是不能理解成做了性能优化，因为仍然需要进行a()本身的构造。vec.emplace_back(1);\n完美转发\n这里会出现一个问题，函数调用的时候，函数参数很容易会由于参数绑定而成为一个左值（哪怕传递的是右值）。\ntemplate&lt;typename T&gt;\nvoid solve(T &amp;&amp; v)&#123;\n    //v接受任何参数传递\n&#125;\n\n很尴尬的是，哪怕确实传入了右值，在函数内部一旦使用v，v立马就会变为左值。\n以这个例子看，emplace_back传入右值又是如何实现保持类型不变呢。\ntemplate&lt;typename T&gt;\nvoid solve(T &amp;&amp; v)&#123;\n    _solve(v);  //左值\n    _solve(std::forward&lt;T&gt;(v));  //v是什么类型那就是什么类型\n    _solve(std::move(v))   //move强行转换为右值\n&#125;\n\n看看forward函数的原理：\ntemplate &lt;typename T&gt;\nT&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp; param)\n&#123;\n    return static_cast&lt;T&amp;&amp;&gt;(param);\n&#125;\n\ntemplate &lt;typename T&gt;T&amp;&amp; forward(typename std::remove_reference&lt;T&gt;::type&amp;&amp; param)&#123;    return static_cast&lt;T&amp;&amp;&gt;(param);&#125;\nremove_reference意思就是去掉引用的参数类型。\n这里假如T类型是int、int&amp;或int&amp;&amp;类型。最终param本身的类型都会变为int，但会将T原封不动传入。\n如果传入的是左值，也就是调用重载的第一个forward，此时T翻译为int&amp;，最终参数类型转化为int&amp; &amp;&amp;。\n如果传入的是右值，也就是调用重载的第二个forward，此时T翻译为int&amp;&amp;，最终参数类型转换为int&amp;&amp; &amp;&amp;。\n引用折叠规则：\n\nint &amp; &amp; 折叠为 int&amp;\nint &amp; &amp;&amp; 折叠为 int&amp;\nint &amp;&amp; &amp; 折叠为 int&amp;\nint &amp;&amp; &amp;&amp; 折叠为 int &amp;&amp;\n\n\n即对T&amp;&amp;来说左值引用折叠为左值引用，右值引用折叠为右值引用\n\n所以最终，forward会返回对应T的类型，这个就叫完美转发。\nC++ Primer：forward必须通过显式模板实参来调用，不能依赖函数模板参数推导\n要点就是函数传入的右值会变为左值，但是forward函数直接无视参数本体，而是直接将参数类型传入，然后重新和参数本体拼装（强制类型转换）后返回出去。\n使用引用折叠的原因——万能引用：\n如果直接传递右值，则T会直接推导成为非引用类型。非引用类型即可以是左值也可以是右值，这里存在一个二义性，也就是说非引用类型返回出去，具体是左值还是右值可能取决于绑定的对象\n此时加上&amp;&amp;，则非引用类型转换为右值引用，而如果传入的是左值，则通过折叠转换为左值引用。\n其中T&amp;&amp;中的T只是代表”需要被推导的类型“，所以如果是auto&amp;&amp;其实也是可以算万能引用的。\n\n&nbsp;\n回到emplace_back上，无论是外界调用引入参数，还是emplace_back的内部调用，都是可以使用完美转发直接传递左值或者右值。\n&nbsp;\n萃取\n顾名思义，即将迭代器iterator所指向的元素type萃取出来。\n&nbsp;\nconstexpr\n旨在支持编译时常量表达式的计算\n\n被constexpr函数，其值会在编译期确定。\n需要函数体是在编译器能决定的，特别是返回值，需要让他在编译器就能确定好值。\n而且返回值需要是单一返回值。\nconstexpr int Len(int a,int b)&#123;\n    return a + b;\n&#125;\n\nint main()&#123;    constexpr int array[Len(1,2)];&#x2F;&#x2F;不会报错，可以看出1+2必定是编译器能判断出结果的\nreturn 0;\n\n}\n#define不受名字空间限制，编译时整个编译单元都有效，所以可能发生冲突。\n建议使用constexpr或者模板来取代。值得说的是，UE4是将一个模块里的所有cpp都合并成一个编译单元进行编译，导致所有cpp里面的#define都冲突了。另一个解决方式是使用完之后使用#undef来解决问题。\nnoexcept\n在函数后接这个关键字，指函数中不会发生异常，编译器不会捕捉异常，如果真出现直接中断程序。\n只有移动构造函数使用noexcept声明，vector扩容的时候才会采用移动构造\n移动构造函数、析构函数、swap函数、内存释放函数都建议适用noexcept\nauto推导规则\n\n如果初始化表达式是引用，则去除引用语义；\n如果初始化表达式为const或volatile（或者两者兼有），则除去const/volatile语义；\n初始化表达式为数组时，auto关键字推导类型为指针。\n也就是说auto表示不了引用和const，必须手动配合变更：\nauto x，推导时会忽略引用和const/volatile\nauto&amp; x，推导时会保留const/volatile，最终一定是左值引用\nauto* x，推导时会保留const/volatile，最终一定是指针\nauto&amp;&amp; x，万能引用，推导时会保留const/volatile和左值/右值引用特性\n\n\nvariant\n共同体union，其包含的类型都是基本类型，因为union不会调用元素的析构函数构造函数，甚至难以直接得知当前使用的类型是什么。\n这就导致了实际开发中尽量不会使用union，就算使用也不会使用复制对象类型。\nvariant就是C++17之后的模拟union的标准库。\n#include &lt;variant&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main() &#123;    std::variant&lt;int, double, std::string&gt; v;    return 0;&#125;\nv &#x3D; 10; &#x2F;&#x2F; 存储int类型的值v &#x3D; 3.14; &#x2F;&#x2F; 存储double类型的值v &#x3D; &quot;hello&quot;; &#x2F;&#x2F; 存储std::string类型的值\nstd::cout &lt;&lt; std::get&lt;int&gt;(v) &lt;&lt; std::endl; &#x2F;&#x2F; 获取存储的int类型的值std::cout &lt;&lt; std::get&lt;double&gt;(v) &lt;&lt; std::endl; &#x2F;&#x2F; 获取存储的double类型的值std::cout &lt;&lt; std::get&lt;std::string&gt;(v) &lt;&lt; std::endl; &#x2F;&#x2F; 获取存储的std::string类型的值\nstd::visit([](auto&amp;&amp; arg) &#123;    std::cout &lt;&lt; arg &lt;&lt; std::endl;&#125;, v);\n\n与传统union比起来variant更加类型安全\n内置机制来管理“活跃”成员，不需要手动储存额外空间，来记录当前类型\n访问接口get()与visit()\n支持复制与销毁\n\n\ndecltype\n和auto一样作用的新关键字，在编译期自动推导变量类型，和auto不同的是，auto需要等号右边的变量至少已经被初始化了，而decltype不做要求。\ndecltype(exp) varName;\n\n更具exp表达式来判断类型，exp可以是变量，也可以是左值右值，也可以是函数（根据返回值推导），唯独不能是void类型。\n如果exp被括号包围，那么推导类型为exp类型的引用。\n使用场景：\n\n函数返回值\n类的非静态成员（无法使用auto）\n\n\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C#理论基础","url":"/2023/06/09/C-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","content":"\n\n\n\n\n\n\nC#简介\nC#（See Sharp）是一种完全面向对象的语言，需要自己定义类型以及行为  \n可以从与C++的区别入手：\n\n作为C++的后续版，C#能做到的C++都能做到，但C++更为复杂，C#主打的就是一个效率\nC#被研发初就是用来编写.NET平台，.NET是一个十分模糊的概念，它是一个跨平台开源开发人员平台，可用于构建多种应用程序。.NET包含一类库和CLR虚执行系统，过多的不赘述，总之C#所编写的源代码会被编译为符合CLI规范的中间语言IL，IL会在C#程序执行时被CLR编译为本机指令。当然对于C#本身这种涉及的内容太多，略微了解即可，有点类似于C++编译的一系列操作\nC++不允许在一个构造函数中调用另外一个构造函数，而C#允许\n上述只是用于初步了解的部分特点，当然最重要的是C#是完全面向对象的语言，更注重实际应用\n\n\n.NET主要功能\n\n垃圾回收（自动内存管理）\n为应用程序管理内存的分配和释放，意味着对开发人员来说，不必编写执行内存管理任务的代码，可以不用考虑内存管理的经典问题，例如忘记释放对象并导致内存泄漏，或尝试访问已释放对象的内存\n\n\n\n\n代码质量分析\n和visual studio中错误分析类型的东西\n\n\n\n...(待补充)\nHello world\nusing System;\n\nclass Hello&#123;    static void Main()    &#123;        Console.WriteLine(&quot;Hello, World&quot;);    &#125;&#125;\nusing System引用System命名空间，提供了一种用于组织C#程序和库的分层方法。命名空间包含类型和其他命名空间，如System（Console类和IO、Collections命名空间）\n看起来像是C++中using与include的归类版\n\n声明Hello类，其中的成员main用static修饰符进行声明，按约定Main静态函数是C#程序的入口点\nConsole类中的WriteLine函数用于输出，由标准类库提供，默认情况下编译器会自动引用标准类库。\n由于System命名空间的引用，System.Console.WriteLine可直接写为Console.WriteLine\n类型和变量\n类型\n两种类型：值类型和引用类型\n值类型变量包含数据\n引用类型的变量存储对数据/对象的引用\n\n两个变量可以引用同一个对象\n对一个变量执行的运算可能会影响另一个变量引用的对象\n\n\n标识符是变量名称，如果前缀为@，则可能是C#保留字\n一些文档内容：\n\n值类型\n\n简单类型\n\n有符号整型：sbyte、short、int、long\n无符号整型：byte、ushort、uint、ulong\nUnicode 字符：char，表示 UTF-16 代码单元\nIEEE 二进制浮点：float、double\n高精度十进制浮点数：decimal\n布尔值：bool，表示布尔值（true 或 false）\n\n\n\n枚举类型\n\nenum E &#123;...&#125; 格式的用户定义类型。 enum 类型是一种包含已命名常量的独特类型。 每个 enum 类型都有一个基础类型（必须是八种整型类型之一）。 enum 类型的值集与基础类型的值集相同。\n\n\n\n结构类型\n\n格式为 struct S &#123;...&#125; 的用户定义类型\n\n\n\n可以为 null 的值类型\n\n值为 null 的其他所有值类型的扩展\n\n\n\n元组值类型\n\n格式为 (T1, T2, ...) 的用户定义类型\n\n\n\n\n\n\n引用类型\n\n类类型\n\n其他所有类型的最终基类：object\nUnicode 字符串：string，表示 UTF-16 代码单元序列\n格式为 class C &#123;...&#125; 的用户定义类型\n\n\n\n接口类型\n\n格式为 interface I &#123;...&#125; 的用户定义类型\n\n\n\n数组类型\n\n一维、多维和交错。 例如：int[]、int[,] 和 int[][]\n\n\n\n委托类型\n\n格式为 delegate int D(...) 的用户定义类型\n\n\n\n\n\n\n\n\n\n类型声明\n\nclass类型定义包含数据成员（字段）和函数成员的数据结构。支持单元继承和多态\nstruct类型定义包含数据成员和函数成员的结构（类似于class）\n\n\n区别如下：\nstruct为值类型，class为对象类型\nstruct不能被继承，class能被继承\nstruct 默认的访问权限是public,而class 默认的访问权限是private\n......\n值类型适合存储供 C#应用程序操作的数据\n引用类型应该用于定义应用程序的行为\n\n\ninterface类型定义为一组已命名的公共成员。 实现 interface 的 class 或 struct 必须提供接口成员的实现代码。 interface 可以继承自多个基接口，class 和 struct 可以实现多个接口。\ndelegate 类型表示引用包含特定参数列表和返回类型的方法。\n\n\nC# 采用统一的类型系统，因此任意类型的值都可视为 object。 每种 C# 类型都直接或间接地派生自 object 类类型，而 object 是所有类型的最终基类。 只需将值视为类型 object，即可将引用类型的值视为对象。 通过执行装箱和取消装箱操作，可以将值类型的值视为对象。 在以下示例中，int 值被转换成 object，然后又恢复成 int。\nint i = 123;\nobject o = i;    // Boxing\nint j = (int)o;  // Unboxing\n\n&nbsp;\n&nbsp;\n\n","categories":["从C++开始的C#"]},{"title":"C++程序设计阅读笔记面向对象部分","url":"/2023/06/09/C-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%83%A8%E5%88%86/","content":"\n\n\n\n从机器码到高级语言1\n\n\n从机器码到高级语言\n所谓对象，有一句程序员喜欢说的经典的一句话”一切皆对象“，换句话说，生活中处理的几乎一切都是对”对象“来处理的。对于程序来说，这样一个”对象“包含了唯一的身份、状态和行为，在代码中的具体表现就是class类\n一个对象的状态表现为数据域以及当前值，一个对象的行为由一组函数定义\n\n一个程序本身，其实都是调用一个个对象和封装一个个对象的结果。可以肯定的是，对象从不同的视角来看是不一样的。\n\n只要长了眼睛就知道Mk2是由两个风扇和一个操纵杆组成，不过第一次建造时，需要一定的手法、\n\n但如果使用究极手的话，Mk2在林克眼里就是9块左纳尼乌姆\n所以说同样一个对象，在不同视角下是不一样的；用更专业的术语来说，那就是一个对象就是类的一个实例。进一步讲，我们可以创建一个类的多个实例，创建一个实例称为实例化，这样说可能有点抽象，那么我们继续拿Mk2来举例子，class定义Mk2是这么一个东西，我们可以用究极手的蓝图功能将它复刻，而且我们可以用很多个左纳尼乌姆来量产很多台Mk2，这就是对class的实例化。\n不过这样解释还是片面了点，更深入地说，如果class将Mk2定义为“必须要用操纵杆”（这里可以将这个设定比喻成构造函数，不过这一点我们后面再讲），那么理论上如果讲两个小风扇换成大螺旋桨，这个东西和纯粹用究极手复制出来的Mk2不太一样，但也可以说是Mk2的一个“实例”。\n同样的，在原Mk2的基础上，如果我们能加装一个灯，我们就可以用它来探索地底；如果我们能加装几门炮，那么Mk2瞬间变为战斗飞艇。这里可以引申出面向对象的另一个特点，那就是多态，牵扯到父类与子类等，不过这些具体的我们也放在后面讲。\n我们现在聊聊面向对象的语言层面上的内容。\n\n前面提到了对象在不同视角上表现是不同的，那么一个程序对于机器与对于程序员来说也不太一样。\n\n图片出自知乎@herb.dr\n\n汇编语言的机器码是机器认得的语言，所有程序在机器眼里就是这么一串0101代码。直接将机器码初步翻译，比如翻译成mov这个基础转移关键字，这是至少程序员能看懂的语言\n但是汇编语言对于程序员来说还是太麻烦了，一个hello world就能让操作寄存器\nDATA SEGMENT  \n    BUF DB &#39;HELLO WORLD!  THIS IS MY FIRST ASM FILE! $&#39;  \nDATA ENDS  \n\nCODE SEGMENT    ASSUME  CS:CODE,DS:DATASTART:    MOV AX,DATA    MOV DS,AX  \nLEA DX,BUF  \n\nMOV AH,09H\nINT 21H  \n\nMOV AH,4CH  \nINT 21H  \n\nCODE ENDSEND START  \n\n作为一个面向机器的语言，很难从其代码上理解程序设计意图，设计出来的程序不易被移植，所以理所当然的不被广泛使用。当然，作为最“底层”的代码，汇编语言通常在驱动程序、嵌入式操作等有很大应用\n所以，C语言的发明是里程碑式的\n#include &lt;stdio.h&gt;\nint main() \n&#123;\n    printf(&quot;Hello World!&quot;);   \n    return 0;\n&#125;\n\n简化版的helloworld十分符合人的口味儿，不仅编写简单，程序员需要处理的对象也变为了数据与算法。C语言可以看成直接对机器指令的各种调度，比如我们如果要写一个围棋程序，那么我们第一个要做的事情就是首先建立棋盘，可能要先调度图形库画出一个十九路棋盘，然后让玩家1下子，下子后要判断胜负，所以在程序中的这个阶段要引用判断胜负的函数，之后轮到玩家2下子，然后继续判断胜负，由此循环，可能还要建立for循环之类，最终在能判断出一场对局的胜负后结束程序，这就是一个很典型的面向过程的编程方式\n我们需要发明出更符合人口味的编程方式以及编程语言，毕竟很多程序没上面说的这么简单。比如我们要正经写一个围棋游戏，那我们可能得编写账户登录程序，这儿好歹还能继续用面向过程强行编写。和水平相差太大的玩家下没意思，我们可能还需要增加排位机制和匹配机制；高水平的对局很吸引人，所以我们可能需要增加直播机制和录像机制；围棋下累了想娱乐一下，那么我们可能需要增加五子棋模式……这样程序立马就变得十分复杂了，继续使用面向过程方式，程序就会产生各种冲突和bug，屎山代码会越积越多。\nC++与C相比一个最大的特点就是实现面向对象编程，C++可以同时支持面向对象和面向过程编程，而更偏应用化的C#则只支持面向对象编程。\nclass user&#123;\npublic:\n   std::string name;\n   int grade\n   void introduction()&#123;\n      std::cout&lt;&lt;&quot;Hello,Nice to play chess with you&quot;&lt;&lt;std::endl;\n   &#125;\n&#125;;\n\n这是一个简单的账号类，包括名字与段位分数以及“签名”这个简单函数，这个在人的视角中最容易理解的程序，继续拿围棋程序举例，如果使用面向对象编程，我们可以实例化这个类在建立一个个账户，也可以派生在增加账户内功能；同样，我们也可以建立棋盘类，甚至棋子类，规则类等等等等，这样的程序在人眼中是很清晰的。\n可以说面向对象编程就是将数据和算法结合的\n一张图,简明的表达出面向对象的历史渊源\n\n图片来源b站@---杨同学---\n\nUML类图\n设定类和对象的关系的时候，我们可以用UML类图将其标准化\n类图主要作用是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。\n数据域表示如下：\ndataFieldName：dataFieldType\n构造函数表示如下：\nClassName（parameterName：parameterType）\n函数表示如下：\nfunctionName（parameterName：parameterType）：returnType\n\n\n“+”表示public\n“-”表示private\n“#”表示protected\n不带符号表示default\n\n\n若表示抽象类，则名称改为斜体\n\n//接口UML图、包UML图、关系UML图is coming。。。//\n构造函数\n通过调用构造函数来创建对象\n\n构造函数的名字必须与类名相同\n构造函数没有返回类型——即使返回void也不可以\n在创建对象时，构造函数被调用，它的作用就是初始化对象\n\n\n《C++程序设计》中的原话定义\n\n值得一提，构造函数如果给予void等返回值，编译器会报错，或者把它当成一个普通函数。笔者在初学C++面向编程时，经常会因为没想起”构造函数“这个概念而对没有返回值的同名函数感到疑惑。\n我们在创造对象时，一般需要对对象赋初始值，比如写围棋程序时假设需要为双方分别给100个棋子，这是每局比赛必要的条件，在创建对象之后再重新赋值显得十分繁琐，就好像选手上场后，先每人给一个小碟子，然后再每人在小碟子里倒50个棋子，还不如直接每人给一个带有50个棋子的小碟子来地简单。\n这就是构造函数的主要目的，从另一个角度上看，构造函数也是一种对类的宣言。构造函数一旦被定义，意味着所有对象肯定要按照这个条件来，就好像建国需要先立宪法，国家运作要按照宪法来，当然宪法可以后天更改，就好像构造函数作用过后也可以单独为对象单独调用另外的函数来调整数据域。\n作为类成员，直接在声明里初始化是错误的！尽管作为一个函数声明的同时初始化变量看起来是多么正常！\n\n默认构造函数/缺省构造函数（default constructor）\n构造函数是必要的，你甚至可以直接声明一个构造函数但不做任何事！\nCircle()&#123;&#125;\n\n哪怕不声明构造函数，或者说忘记声明构造函数了，编译器也会自动提供默认构造函数\n在《C++程序设计》这本书中，对默认构造函数的描述是：只有当程序员没有在类中显式地声明构造函数时\n根据这个原则，下面2种构造函数都是默认构造函数：\nclass Sample &#123;\npublic:\n    // 默认构造函数。\n    Sample() &#123;\n        // do something\n    &#125;\n&#125;;\n\nclass Sample &#123;public:    &#x2F;&#x2F; 默认构造函数。虽然有形参，但有默认值，调用的时候可以不显示的传入实参。    Sample(int m &#x3D; 10) &#123;        &#x2F;&#x2F; do something    &#125;&#125;;\n书中提到了另一个赋初值的方法：初始化列表法适用于对象的数据域没有无参构造函数时\nClassName(parameterList)\n:datafield1(value1),datafield2(value2)\n{}\n\n//对象的具体使用方法略，这点十分基础简单，实在不行翻翻文档\n不过可以说说一些小细节\n\ncircle2=circle1；实现对象间内容复制，1的数据域内容被复制到2中\n一个对象的大小不看其函数，因为函数存储在类中，对象共享\n如果一个对象只使用一次，则可以用ClassName()语法创建一个匿名对象，带括号的匿名对象满足大部分一般对象的功能（可能我一般用不到，但看别人代码的时候忽视这一点又会很浪费时间）\n\n\n类定义和类实现的分离\n和C程序写函数文件一样，类也会将其实现与定义分开，就像函数的声明的定义，最傻瓜的区分方式就是声明文件直接接;\n二元作用域解析运算符::用于指明类的作用范围\n例如下为例类实现\nCircle::Circle()\n&#123;\n  radius=1;\n&#125;\nCircle::Circle（double newRadius）\n&#123;\n  radius=newRadius；\n&#125;\ndouble Circle::getArea（）\n&#123;\n  return radius*radius*3.14;\n&#125;\n\n\n这种方式可以方便保护软件工作者的知识产权，比如只提供头文件和类，隐藏类的实现就相当于“祖传秘方”\n\n\n\n类定义用于提供给客户程序，如果客户有需求更改条件，则只需更改实现，客户程序不需要更改\n\n\n这种将类定义和实现分开的方式，其实就是类抽象\n抽象后的类的具体实现是隐藏的，这就是类封装\n数据域的封装\n一个非常常用的功能，类数据域的内容通常由类本身的函数来改变，有时候也会由其他类函数改变，也甚至可能直接被客户程序改变circle1.radius=5。\n问题来了，如果该变量非常重要，关乎程序整体生态的，比如说在一个已经写好的程序中，需要增加一个对某变量÷的操作，那么这个变量肯定不能为0了。这个变量的赋值都是由类函数进行，假设理论上不会出现0的情况，那么这个操作相对来说是安全的。这个时候谁家小孩直接在自己的操作界面加了句circle1.radius=0，那么恭喜程序直接崩溃。\n直接让类以外的操作对类本身数据域进行操作是危险的，这个时候我们需要用到private关键字,对数据域进行保护，这样类以外的操作就不会对所属数据发生改变，甚至连访问都是不被允许的\n相对的，允许改变的使用public关键字\n引言：如果需要对private成分进行访问或者修改，则可以使用get与set函数\n\n//略变量作用域\n\n到这里为止，就能对面向对象编程有一个基本的认识了，不过要对面向编程有更深入的了解还是要具体实操，接下来会继续针对面向对象思想深入了解string类等进阶操作\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C++智能指针","url":"/2023/11/07/C-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"\n\n\n\n\nC++智能指针\n\nRAII\n资源获取初始化——利用对象的生命周期来管理资源\n\n在对象构造时获取资源，在对象析构时释放资源，这样可以确保资源的正确获取和释放，避免资源泄漏的问题。\n&nbsp;\n智能指针的实现，就是RAII概念的典型，关键词：\n\n引用计数\n所有权转移\n析构函数\n自定义删除器\n\n\n&nbsp;\nRAII的其他应用场景：\n\n文件句柄\n数据库连接\n...\n\n\n&nbsp;\n现代C++智能指针\n实现方式是类模板——定义在头文件中\n\n你就问呗\n\n智能指针提供了自动的内存管理和资源释放机制，可以避免手动释放内存或资源的错误和遗漏。通过将原始指针传递给智能指针，我们可以确保在智能指针超出作用域时，它会负责自动释放内存或释放资源。\n&nbsp;\n\nstd::unique_ptr\n\n\nstd::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);\n这样子定义出来的指针uptr，当程序运行离开其作用域时会自动释放内存。\n&nbsp;\nstd::unique_ptr 类型的对象只能通过移动语义进行转移，而不能进行复制操作。\n例如：\n    std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);\n    std::unique_ptr&lt;int&gt; uptr1 = uptr; //false\n\nstd::unique_ptr&amp;lt;int&amp;gt; uptr2 = std::move(uptr);\n\n\nstd::unique_ptr是独占所有权的，也就是说同一时间内不允许其他std::unique_ptr来指向同一目标\n\n&nbsp;\nstd::shared_ptr\nstd::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200);\n对资源做引用计数，例如现在的情况就是1\nsptr.use_count()==1\n再例如：\nstd::shared_ptr&lt;int&gt; sptr2 = sptr1;\n此时：\nsptr.use_count()==2\n当引用计数为0时，内存被自动释放——开销比unique_ptr大\n&nbsp;\n控制块\n控制块用于储存引用计数等信息，与对象分开存储，但是也是动态分配的，所以和对象一样存储在堆区。所以shared_ptr的指针有两个，一个指向对象，一个指向控制块，控制块再含有指向对象的指针。\n这样的结构使得实现了以下功能：\n\n共享拥有\n控制块访问——比如 deleter 是保存在控制信息（控制块）中的\n\n\n虽然控制块实际上和对象是分开的，但实际理解中最好和对象联系在一起，比如说引用计数，实际上就是对象“被引用”的计数，虽然是指针创建的但其实是针对对象来说的，这样子理解可能更好一点\n\n&nbsp;\nstd::weak_ptr\nshared_ptr的观察者，与其一起使用\n\n首先试想一下这样的情况：\nclass ObjectB;\n\nclass ObjectA &#123;public:    std::shared_ptr&lt;ObjectB&gt; bPtr;&#125;;\nclass ObjectB &#123;public:    std::shared_ptr&lt;ObjectA&gt; aPtr;&#125;;\nint main() &#123;    std::shared_ptr&lt;ObjectA&gt; a &#x3D; std::make_shared&lt;ObjectA&gt;();    std::shared_ptr&lt;ObjectB&gt; b &#x3D; std::make_shared&lt;ObjectB&gt;();\na-&amp;gt;bPtr = b;\nb-&amp;gt;aPtr = a;\n\nreturn 0;\n\n}\n所示，每个对象一直持有对方类型的 std::shared_ptr\n在main函数中，初始化指针a和b并指向初始化的对象A和对象B，此时分别引用计数为1，后来分别调用两者的成员指针指向对方，这个时候A和B已经被两个shared_ptr指上了，所以计数为2；return 0退出作业域，指针a和指针b的析构函数触发，（注意这个时候析构函数做的两件事——1.销毁自己2.销毁引用计数为0的对象），此时a和b销毁所有引用计数都减一，但A和B自身还相互被对象指着，所以不会被销毁。\n永动机出现了？\n\n这种情况发生时，我们只能强行手动将指针指向拨开，但是太麻烦了，所以。。。\nweak_ptr正是这么一个解决这样的情况的指针，作为弱引用，他的指向不会使得对象引用计数加一：\nclass ObjectA &#123;\npublic:\n    std::weak_ptr&lt;ObjectB&gt; bPtr;\n&#125;;\n\n这样的化，对象B的引用计数不会增加到2，于是析构的时候正常销毁，连带着A也销毁了。\n&nbsp;\n当然这只是weak_ptr的一种功能，weak_ptr的本质功能是当对象的“观察者”。\nweak_ptr本身不会对对象造成什么影响，但在需要的时候会转换为“shared_ptr”来实现对对象的操控，这样也算行了作为指针的“本分”。\nexpired() 判断所指向的原生指针是否被释放，如果被释放了返回 true，否则返回 false；\nlock() 返回 shared_ptr，如果原生指针没有被释放，则返回一个非空的 shared_ptr，否则返回一个空的 shared_ptr\n\n&nbsp;\n智能指针工厂函数\nstd::make_shared——等价于\nauto son_ = new Son(); \nshared_ptr son(son_); \n为什么不要用new来创建？比如shared_ptr son = new Son();\n因为new会动态分配一次内存，shared_ptr又会动态分配一次内存用于保存控制块等信息，分开两次影响性能，此外使用new还会不由自主地使用delete（？），这个时候两次删除同一块内存是很危险的。换句话说人家两对就是配套用的，别拆散。\n类似的有std::make_unique、std::allocate_shared\n这样可以延申出，智能指针只能管理堆对象，不能管理栈对象\n其他的别人的博客里说了很多，但我感觉其实只要理解智能指针会自动释放内存这一点就可以了，可以从这一点延申出很多使用的技巧。\n&nbsp;\n附加：多线程与智能指针\n试想一下多线程过程中子线程引用外部对象，结果外部对象销毁的时候，子对象还在使用外部对象的野指针。这个时候用shared_ptr来管理这个外部对象，用weak_ptr将对象传给子进程，这样当对象消失的时候，weak_ptr自动置空，而不是变成一个野指针指向一块未知的内存。\n&nbsp;\n//todo：源码剖析——额别期待了我自己都不信我以后会补\n\n2023/12/18更新\n麻了，我说不补充源码剖析结果面试的时候真给问上了，所以现在重新补充一下，后悔莫及。。。\n&nbsp;\n最常被问到的：unique_ptr底层是怎样实现自动释放内存的？\n这个问题最方便的回答方式，应该是重点放在智能指针的源代码的析构函数之上\n~unique_ptr() &#123;reset();&#125;\n可以说“智能指针本身是栈上分配的对象，由模板类实例化，所以在离开作用域时会自动调用析构函数”\n所示智能指针的析构函数中的reset()函数，这个函数是用来干嘛的呢？首先如果给这个函数传入某个对象，那么这个函数会直接更改本对象的指向到这个传入的对象，并释放原对象的内存。所示调用该函数的时候没有传入对象，也可以视为传入NULL，所以调用析构函数的时候会将指针指向NULL并释放原内存，这样就自动释放了内存。\n对于shared_ptr，比unique_ptr多了引用计数和指向控制块的指针，由于引用计数是存在控制块当中的，所以拥有特定方法来获取控制块当中的引用计数，具体代码可见参考博客。\n对于weak_ptr，增加的则是弱引用计数。\nC++ 智能指针最佳实践&amp;源码分析 - 极术社区 - 连接开发者与智能计算生态 (aijishu.com)\n&nbsp;\n\n","categories":["从C开始的C++"]},{"title":"C#类型","url":"/2023/10/16/C-%E7%B1%BB%E5%9E%8B/","content":"\n\n\n\n\nC#出定义\n\n数据类型——值类型与引用类型\n通过这种方式来隐含地控制指针运行\n\n\n值类型表示变量本身\n引用类型本质上是地址\n值类型与引用类型使用相同的语法来分配内存\n所有内存的释放都不需要手工进行，CLR执行一种算法来跟踪可以访问的和不可访问的引用变量，定期清除那些不能访问的对象，并将其内存返回给操作系统\n预定义类型除了object和string之外都为值类型\n自定义类型除了结构（struct）和枚举（enum）之外都为引用类型\n\n\n&nbsp;\n值类型：\n\tint i;//未初始化\n\nint j = i;//C++中允许但C#中不允许\n\n\n\nint i = 3;//或者int i = new int();相当于int i=0；调用了int的构造函数\n\nint j = i;//允许\n\n\n&nbsp;\n引用类型：\n预定义引用类型：string，object，string str=“abcd”；\n自定义引用类型：（类，接口，委托，事件……）\n    class rpoint // 定义了一个引用类型\n    &#123; public int i;public int j;&#125;  \n    rpoint rp1;   // 完成了定义\n    int i = rp1.i;  // 初始化之前，既不能读\n    rp1.i = 3;      // 也不能写。\n    rp1 = new rpoint();  // 初始化\n    int j = rp1.j;       // 可以读\n    rp1.j = 3;           // 可以写了。\n\n&nbsp;\nstruct与class\n在C#中这两者的区别和C++中略有不同\n\n类型：struct是值类型，class是引用类型\n内存分配：struct在栈上分配内存\n继承：struct不支持继承，而class支持继承\n默认构造函数：struct默认有一个无参构造函数，而class没有\n\n\n&nbsp;\n赋值方法：\n值类型拷贝一个全新的数据结构\n引用类型只能生成一个新的引用\n\n\trpoint rp1 = new rpoint();\n\nrpoint rp2 = rp1;\n\nrp1.i = 20;\n\n//rp2.i==20 第二个也变了\n\n\n\nvpoint rp1 = new vpoint();\n\nvpoint rp2 = rp1;\n\nrp1.i = 20;\n\n//rp2.i==0 第二个不变\n\n\n&nbsp;\nstring:\n引用类型，但表现出值类型的特性\n\n\tstring s1 = &quot;abcd&quot;;\n\nstring s2 = s1;\n\ns1 = &amp;quot;efg&amp;quot;;//abcd，第二个不变\n\n\n&nbsp;\n&nbsp;\n方法参数传递\n回忆：\nC的函数参数传递——拷贝（传值传址）\nC++函数参数传递——拷贝和换名\n&nbsp;\nC#中值类型是拷贝形式，引用类型是拷贝地址形式\n除了string类型，任何改变字符串的企图都会导致新的字符串的创建，更像一个值类型\n\n\tprivate GameObject solve(GameObject obj)&#123;\n        //对对象进行处理\n        return obj;\n    &#125;\n\nprivate void solve(GameObject obj)&#123;\n    //对对象进行处理\n&#125;\n\n\n上者GameObject 处理过后效果其实是一样的，在C++中前一种方式似乎更符合直觉，但在C#中作为引用类型本身传入函数时就拷贝的就是地址，使用起来更为方便。\n对于值类型，经常性地会出现返回值类型远远达不到我们的目的（比如需要返回多个值类型的情况下），这个时候也可以利用ref 关键字来讲值类型转变成引用类型\n\tprivate void g(ref vpoint p)&#123;\n        p.x = 100;\n    &#125;\n    //函数外值类型直接发生改变\n\n&nbsp;\nout：\n如果不需要使用初始值\n\n\tvoid f(ref int p)&#123;\n        p = 8;\n    &#125;\n    int a;\n    f(ref a);//false\n    int a;\n    a = 1;//无意义,我们适用的情况就是不需要初始值的情况\n    f(ref a);\n\n//改为\nvoid f(out int p)&#123;\n    p = 8;\n&#125;\nint a;\n  f(out a);//很不错\n\n//也可以结合定义一起使用\nf(out int a);//替换f(out a);不需要int a；这个东西了\n\n\n老师也提到C#如果没使用已经初始化的值会警告，这一点在日常使用的时候确实感受颇深，这也是比C++更为人性化的一点\n\n&nbsp;\n对于引用类型，使用ref会改变整个对象指针\n\tvoid f(ref rpoint p)&#123;\n        p = new rpoint();\n    &#125;\n\n以上程例如果没有ref会毫无意义，因为引用类型传入函数和C++中传递指针的原理是一样的，试想如果在C++中传指针的函数内改变指针指向可行吗？很显然不行，因为传入地址，本质也是传入“地址的拷贝”，也就是指针的拷贝，改变这个指向和函数外的那个指针没任何关系。那么在C#中也是一样的，不过如果为引用类型加上ref 关键字，这个时候用C++的说法就变成“指针的引用”了，再去在函数内改变这个指针的指向，这个操作就变得有意义了。\n&nbsp;\n总结：\n\n值类型拷贝值\n引用类型拷贝指针\nref值类型拷贝指针\nref引用类型拷贝指针的指针\n\n\n&nbsp;\n预定义引用类型\n&nbsp;\nObject：\n所有类型都是从这个类型继承的，在程序中隐式继承\n\n相关方法（常用于各种类型重写）：\nEquals ——支持对象间的比较\nFinalize ——在自动回收之前进行清理操作//已删除\nGetHashCode ——生成一个与对象对应的数字来支持哈希表的使用（一般用于自己重写）\nToString ——生成类实例的可读文本字符串（常用于调试）\n不能妥协！要常对以上方法override\n\n&nbsp;\nString：\n–使用 CompareTo、Equals、可进行比较。使用 IndexOf、IndexOfAny、可获取字符串中子字符串或 Unicode 字符的索引。使用 Copy 和 CopyTo 可将字符串或子字符串复制到另一个字符串或 Char 数组。\n–使用 Substring 和 Split 可通过原始字符串的组成部分创建一个或多个新字符串；使用 Concat 和 Join 可通过一个或多个子字符串创建新字符串。使用 Insert、Replace、Remove、可修改字符串的全部或部分。\n–使用 ToLower 和 ToUpper 可更改字符串中 Unicode 字符的大小写。使用 Format 可将字符串中一个或多个占位符替换为一个或多个值的字符串表示形式。使用 Length 属性可获取字符串中 Char 对象的数量；使用 Chars 属性可访问字符串中实际的 Char 对象。\n&nbsp;\n用户自定义类型\n结构（值）、枚举（值）、类（引用）、接口（引用）、委托（引用）、数组（引用）\n\n&nbsp;\n数组：\nC#支持明确的数组类型\nint[] intarray;\nIntarray = new int[32];\nIntarray[3] = 5;\ndouble[,] matrix = new double[10,10];\nMatrix[3,4]=2;\n动态数组：ArrayList;\n&nbsp;\nvar:\n可变类型，可当作C#版的auto\n\n代替具体类型，实现快速编程的隐式用法，常用在foreach遍历中，实质是语法糖。很典型的在遍历字典类型时，取代KeyValuePair模板\n和new一起使用，来实现一个匿名类型，用来代替需要预先创建的实体类，灵活高效\n不能使用var来定义一个全局变量（预先不可知嘛）\n不能用来定义函数。包括返回值、参数类型\n定义变量时必须先给值\n被定义成var类型之后，若已经指定类型，则不能转换为其他类型\n\n\n&nbsp;\n匿名类型：\n例：用var定义匿名类\n\n\tvar annoyCla1 = new&#123;\n        ID = 10010,\n        Name = &quot;CXY&quot;,\n        Age = 25\n    &#125;;\n        \nint id = annoyCla1.ID\n\n\n&nbsp;\n元组 tuple\n\tpublic(int , string)f()&#123;\n        return (1,&quot;DD&quot;);\n    &#125;\n    //这样就用不到一个类了\n    var a = f();\n    int i = a.Item1;\n    string s = a.Item2;\n\n&nbsp;\n泛型类：\n（欸我草走神了没听见\n&nbsp;\nParams：\n可变长参数，用于不确定类型以及变量数量的\n//todo例子\n&nbsp;\n类型转换\n隐式、显式、静态、动态\n\n回忆：\nC++中隐式转换只能向上转换，就算出错也是编译出错。\n显式向上转换是没必要的，显式向下转换是可以的。\n隐式的向下转换有可能数据丢失，运行时不安全，可能导致崩溃。\n显示向下转换可以先对类型进行识别（typeID），所以准确讲显示向下转换是安全的。\n尽量用显示转换或者动态保证安全性，但不要滥用动态转换因为动态转换影响性能\n&nbsp;\nSystem.Convert\n基本类型转换\n\nstring s=&quot;123&quot;;\n\nint si&#x3D;Convert.ToInt32(s,10)&#x2F;&#x2F;si&#x3D;123;\n&nbsp;\nMain函数\n\npublic static void main（string [ ]args)\n\n\n\n","categories":["从C++开始的C#"]},{"title":"C++类多态","url":"/2023/08/26/C-%E7%B1%BB%E5%A4%9A%E6%80%81/","content":"\n\n\n\n\n基类和派生类\n\n还记得面对对象篇章中提到过的对“Mk2”进行“改造”的内容吗，接下来这一篇章，将引入C++继承和多态的相关操作与衍生内容。\n基类和派生类\n开门见山，一个类C1从另一个类C2扩展而来，称C1为派生类/子类，C2为基类/父类/超类。\n对于派生类，它能继承父类的所有数据域和函数，也能增加新的数据域和函数。\n继承，也就是is a关系。\nclass vegetable&#123;\n    int shape;\n    int color;\n&#125;;\n\nclass cabbage : public vegetable&#123;    bool edible;&#125;;\n白菜继承与蔬菜，并多赋予了“可食用”布尔值\n\n对于基类vegetable，可以派生多个类似cabbage这样的类，什么胡萝卜番茄都行。\n对于派生类cabbage，可以继承多个类似vegetable这样的类，比如白菜可以是蔬菜也可以是食物。\n&nbsp;\n安全\n派生类中冒号后面的标识符叫“访问修饰符access-specifier”，默认是private\n一般情况下在public、protected或private之中选一个\n对于数值类型本身访问类型：\n\n\n访问publicprotectedprivate\n同一个类yesyesyes派生类yesyesno外部的类yesnono\n\n对于类继承类型（也就是访问修饰符作用）：\n\n一般情况下都是用public来继承，除了（   ）\n\n\n\n\n数据类型\\继承类型publicprotectedprivate\npublicpublicprotectedprivateprotectedprotectedprotectedprivateprivateprivateprivateprivate\n\n当然，被保护的成员或者私有成员可以通过基类的其他公有函数和成员来被派生类访问\n\n&nbsp;\n构造函数和析构函数\n派生类的构造函数在执行其自身代码之前首先调用它的基类的构造函数。派生类的构造析构函数首先执行其自身的代码，然后自动调用其基类的析构函数\n\n派生类并不继承基类的构造函数，取而代之的是，派生类会调用基类的构造函数来给基类的数据进行初始化。\n可以通过初始化列表的方式来主动调用基类的构造函数，额，当然更专业的说法是显式调用。\nDerivedClass(parameterList): BaseClass()&#123;&#125;\nDerivedClass(parameterList): BaseClass(argumentList)&#123;&#125;//带参数的构造函数\n\n当然，你不主动人家就会主动调用，这个叫隐式调用。\n如果类叠的很多，那么构造函数和析构函数会在该调用的时候依次调用，特别是构造函数，创建一个派生类的对象的时候，构造函数会从祖宗类开始一连串地被调用，这个叫构造函数链；析构函数则是反着来，从自己到祖宗一连串被调用，这个叫析构函数链。\n&nbsp;\n函数重定义、函数重写与函数重载\n这三个都是C++中截然不同的概念，因为长得像我把他们放一块讲\n\n&nbsp;\n函数重定义\n在基类定义的函数能够在派生类中被重新定义\n\n用法是重写并重新定义函数内容。\nvoid print(int num) &#123;\n    cout &lt;&lt; &quot;Original: &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nvoid print(int num, string message) &#123;    cout &lt;&lt; &quot;Redefined: &quot; &lt;&lt; message &lt;&lt; num &lt;&lt; endl;&#125;\nprint(10);                      &#x2F;&#x2F; 调用 print(int)print(20, &quot;Value is: &quot;);        &#x2F;&#x2F; 调用 print(int, string)\n\n函数重定义会覆盖原有的函数定义，使得原有函数的行为改变。\n函数重定义只能在同一个作用域内进行，不同的作用域内可以存在同名函数，互相之间不构成重定义关系。\n函数重定义与函数的参数列表和返回类型都必须完全一致。\n\n\n在子类中可以重定义父类的函数\n\n&nbsp;\n函数重载\n在一个作用域内有多个同名但参数列表不同的函数\n\n只是用于适应不同的参数类型或参数个数。\nvoid print(int num) &#123;\n    cout &lt;&lt; &quot;Integer: &quot; &lt;&lt; num &lt;&lt; endl;\n&#125;\n\nvoid print(double num) &#123;    cout &lt;&lt; &quot;Double: &quot; &lt;&lt; num &lt;&lt; endl;&#125;\nprint(10);      &#x2F;&#x2F; 调用 print(int)print(3.14);    &#x2F;&#x2F; 调用 print(double)\n\n同一个作用域内可以有多个同名函数，但它们的参数列表必须不同（参数类型、参数个数或参数顺序不同）。\n函数重载是静态多态性（编译时多态性）的一种表现，编译器根据函数调用时的参数类型或个数来确定调用哪个重载函数。\n函数重载只能在同一个作用域内进行，不同的作用域内可以存在同名函数，互相之间不构成重载关系。\n函数重载与函数的返回类型无关，只与参数列表有关。\n\n\n&nbsp;\n函数重写/覆盖\n指子类重新定义父类中已有的虚函数。\n\n用于实现多态性，对父类虚函数进行重新实现。\nclass Shape &#123;\npublic:\n    virtual void draw() &#123;\n        cout &lt;&lt; &quot;Drawing a shape.&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Circle : public Shape &#123;public:    void draw() override &#123;        cout &lt;&lt; &quot;Drawing a circle.&quot; &lt;&lt; endl;    &#125;&#125;;\nclass Rectangle : public Shape &#123;public:    void draw() override &#123;        cout &lt;&lt; &quot;Drawing a rectangle.&quot; &lt;&lt; endl;    &#125;&#125;;\nShape* shape1 &#x3D; new Circle();Shape* shape2 &#x3D; new Rectangle();\nshape1-&gt;draw();     &#x2F;&#x2F; 调用 Circle 类的 draw 函数shape2-&gt;draw();     &#x2F;&#x2F; 调用 Rectangle 类的 draw 函数\n\n函数重写只能发生在父类和子类之间，在同一个继承关系中进行。\n函数重写要求父类中的函数必须是虚函数（通过关键字 virtual 声明）。\n函数重写的函数签名（函数名、参数列表和返回类型）必须与父类中被重写的虚函数完全一致。\n函数重写可以改变函数的实现细节，子类可以根据自身需要重新定义虚函数的行为。\n函数重写是动态多态性（运行时多态性）的一种表现，具体调用哪个函数是在运行时根据对象的实际类型确定的。\n\n\n子类和父类同名函数不是重定义就是重写\n\n&nbsp;\n多态\n首先，子类型是被派生类定义的类型，超类型是被基类定义的类型。\n多态意味着一个超类型的变量可以引用一个子类型的对象。\n\n另外《C++程序设计》这本书讲的太抽象了，所以我引用了CSDN@programing菜鸟的文章内容。\n文章中提到：\nC++的多态必须满足两个条件：\n1 必须通过基类的指针或者引用调用虚函数\n2 被调用的函数是虚函数，且必须完成对基类虚函数的重写\n\nclass Person //成人\n&#123;\n  public:\n  virtual void fun()\n   &#123;\n       cout &lt;&lt; &quot;全价票&quot; &lt;&lt; endl; //成人票全价\n   &#125;\n&#125;;\nclass Student : public Person //学生\n&#123;\n   public:\n   virtual void fun() //子类完成对父类虚函数的重写\n   &#123;\n       cout &lt;&lt; &quot;半价票&quot; &lt;&lt; endl;//学生票半价\n   &#125;\n&#125;;\nvoid BuyTicket(Person* p)\n&#123;\n   p-&gt;fun();\n&#125;\n\nint main()&#123;   Student st;   Person p;   BuyTicket(&amp;st);&#x2F;&#x2F;子类对象切片过去   BuyTicket(&amp;p);&#x2F;&#x2F;父类对象传地址&#125;\n代码中Student类继承了父类Person，众所周知学生应该享受半价票，所以是否为半价票的输出结果藏在响应类中。但是函数可认不出是不是学生，如果要实现”认出是学生“这个功能，那么不可避免的可能要写两个函数或者写一个判断条件甚至引用不同的类，这样不仅浪费了计算机资源还不符合代码工程基本规范，素质极低。\n尝试使用多态，首先在主函数中将各自类的地址传入相同函数中，BuyTicket()函数内使用指针引用了虚函数fun()，结果如下：\n\n函数BuyTicket()中的参数为父类对象，理论上应该打出两个全价票，不过传入的是子类地址，所以就实现了子类方法，这就是C++多态的一个理解思路。\n如果只是传类本身，而不是指针，那么就不满足多态了。\nStudent st;\nPerson p;\nBuyTicket(&amp;st);\nBuyTicket(&amp;p);\n\n结果是：\n\n如果满足多态，编译器会调用指针指向对象的虚函数，而与指针的类型无关。如果不满足多态，编译器会直接根据指针的类型去调用虚函数。\n\n&nbsp;\n虚函数\n虚函数使得系统能够基于对象的实际类型决定在运行时调用哪一个函数\n\n首先，虚函数是定义在类里头的，类外面的虚函数没有意义。\n基类使用virtual进行函数声明，然后子类再进行重写（重定义），这个动作叫函数覆盖，而这样一来，就能在运行时系统基于对象类型来判断调用的哪个函数，这个功能叫动态绑定。\n不过有意思的是在《C++程序设计》中提到过如果在基类中定义为虚函数，那么在派生类中重写的函数不需要再加上关键字virtual，已经是关键字了（上示例中没有这样做可能是为了更好体现）。\n匹配一个函数的签名与绑定一个函数的实现是两个独立的问题。\n\n变量类型决定编译时匹配到的函数，这个叫静态绑定。\nC++通过参数类型、参数个数、参数顺序在编译时寻找匹配的函数，在运行时动态绑定函数的实现，这个叫动态绑定。\n把含有虚函数的类称为多态类型。\n\n\n&nbsp;\n虚函数表\n动态绑定的技术核心就是虚函数表\n如果定义了一个虚函数，那么编译器会生成一个虚函数表和一个虚表指针，这些都是编译器自动生成的。虚函数表是一个指针数组（这个数组和字符串数组相似也有“尾部空间”），元素时虚函数的指针，用来存储虚函数的地址。虚表指针是用来指向虚表本身的，在类的对象创建时，这个指针自动指向虚表。对象在调用虚函数的时候，就是用过指针来查阅虚表，然后再通过虚表内存储的虚函数地址来找到正确的要调用的虚函数。\n非虚函数不需要经过虚表\n\n所以虚表指针就是多态形成的关键，拿上面儿童票成人票举例\nint main()\n&#123;\n   Student st;\n   Person* p = &amp;st;\n   p-&gt;fun();\n&#125;\n\n在对象被实例化的时候，虚表指针指向相应的类的虚表，于是对象st中的虚表指针便指向了Student类的虚函数表。尽管指针类型为Person类，但由于基类本身也自带虚表指针类成员，所以指向子类对象也是可行的，这个时候用这个指针调用函数fun()，发现这个指针指向的对象是子类对象，于是通过子类的虚表指针（隐式操作p-&gt;__vptr)访问到子类虚表，于是便调用到子类的相应函数。\n虚表中是如何储存的呢，首先这个指针数组存的都是虚函数的地址，类中有几个虚函数就会有几个成员地址。当子类重写虚函数时，虚函数表在子类中的表现：新的重写过后的虚函数地址就会替换掉掉相应原来的地址。当然这只是替换子类这个“复制”过来的虚函数表，并不是真的替换掉了。\n对应的虚表指针找到对应的虚表，对应的虚表储存对应的虚函数，这就是多态的一句话逻辑，而上文所解释的一系列操作，其实就是动态绑定的过程，也就是这些操作都是在函数运行时进行的，和传统的静态绑定不同（函数调用在编译阶段就能确定下来）。\n动态绑定三条件：\n\n通过指针来调用函数\n指针upcast向上转型（继承类向基类的转换称为upcast）\n调用的是虚函数\n\n\n虚函数表占用空间：将每个虚函数的指针大小乘以虚函数数量，并添加额外的空间用于虚函数表指针。虚函数表指针的大小等于指针的大小。\n通常，32位平台上的指针大小为4字节，64位平台上的指针大小为8字节。\n\n&nbsp;\n&nbsp;\n抽象类和纯虚函数\n纯虚函数与抽象类定义\nvirtual double getArea()=0;\n也就是虚函数后面加=0\n抽象类就是包含纯虚函数的类。\n言简意赅，抽象类不会包含任何具体的实例，实际的作用就是强制子类重写虚函数，实现多态，这里书中给出了一个很好的例子解释，大概意思就是不同形状的图形都由一个抽象类抽象出来，但是实际上无法完成实例化，说具体点就是这个抽象类定义了纯虚函数”算周长“和”算面积“，任何图形都得包含这两个功能。但是这么一个类没办法给出具体形状，所以只能通过子类继承重写虚函数来实现多态以实现实例化。\n这里纯是书中写的太长懒得记录\n\n&nbsp;\nC++11新关键字：override&amp;&amp;final\n\n用final修饰的虚函数无法重写。用final修饰的类无法被继承。final像这个单词的意思一样，这就是最终的版本，不用再更新了。\n被override修饰的虚函数，编译器会检查这个虚函数是否重写。如果没有重写，编译器会报错。\n\n\nvirtual void fun() final&#123;&#125;\nvirtual void fun1() override&#123;&#125;\n\n&nbsp;\n强制类型转换\n\nstatic_cast（静态转换）\n\n\n处理非多态类型，比如基本数据类型。与常见的隐式转换类似，使用这个关键字更多的是用于代码可读性\n\n\ndynamic_cast（动态转换）\n\n\n用于在继承关系中进行类型转换，特别是在具有多态性的类层次结构中。它可以在运行时检查转换的有效性，如果转换不合法，则返回空指针（对于指针类型）或引发 std::bad_cast 异常（对于引用类型）\n\n// 语法：dynamic_cast&lt;目标类型&gt;(表达式)\nBaseClass* basePtr = new DerivedClass();\nDerivedClass* derivedPtr = dynamic_cast&lt;DerivedClass*&gt;(basePtr);  // 在继承关系中进行向下转型\nif (derivedPtr != nullptr) &#123;\n    // 转型成功\n&#125; else &#123;\n    // 转型失败\n&#125;\n\n\nreinterpret_cast（重新解释转换）\n\n\n用于将一个指针或引用重新解释为不同的类型，通常用于进行低级别的类型转换，如将指针转换为整数或将整数转换为指针。它不进行任何类型检查，因此需要谨慎使用。\n\n\nconst_cast（常量转换）\n\n\n用于从常量类型中移除 const 修饰符，以便进行修改。它主要用于旧代码的兼容性或特殊情况下的修改操作，但需要注意不要违反 const 的语义。\n\n&nbsp;\n&nbsp;\n\n2023.9.7更新\n上面多态的实例代码有问题。。先不看那个\n&nbsp;\n构造函数和析构函数的虚函数问题\n构造函数不能设置成虚函数，因为虚函数表是在对象创建的时候被分配空间，而构造函数正是在对象创建的时候被调用。在构造函数被创建时，对象实际上还没完全创建，虚函数表尚未形成，所以理论上这样的操作是冲突的（在vs编译器中设置构造函数为虚函数会直接提示错误）。\n析构函数，基类的析构函数有必要设置成虚函数的。在父类指针指向对象被释放的时候，只会运行父类指针的析构函数（不是指向的），一般情况下并不会有太大影响，但若析构函数涉及空间释放等操作，那么不执行子类的析构函数就会造成内存泄漏！\n&nbsp;\n虚函数的底层实现逻辑\n现在发现我之前写的好像更抽象，我自己都看不太懂。\n首先如果类中含有虚函数，则会为类创建一个虚函数表和一个隐藏起来的指针（虚指针vptr），每个类包括子类等都有自己的虚函数表。虚指针指向自己的虚函数表，在对象创建时，对象的虚指针就会自动指向自己原本类的虚函数表。而虚函数表中存什么呢，虚函数表本质是指针数组，内容是虚函数的位置。比如说一个类中有一个虚函数，那么表中就会存这个虚函数的地址，如果有两个，那么第二个的位置就会顺着存起来。\n如果有子类继承并重写虚函数，那么子类的表除了会复制父类表，同时也会改写对应重写的虚函数地址变为更新后的地址，这样一来，多态系统中的类表不太一样的地方就是这个重写函数不太一样。\n此时有一个父类指针指向子类对象，这个指针在调用虚函数的时候，会触发一个叫动态绑定的机制，在调用时，这个父类指针首先会找到子类对象的虚指针vptr，这个指针恰恰指向的就是子类的虚函数表，我们之前提到过这个表在重写的过程中发生了相应改变，这个改变正好就是虚函数的重写，所以我们能在这个表中直接找到对应的应该调用的子类重写过后的虚函数。\n当然，这个过程是运行时发生的，之所以要在运行时发生，因为编译的时候对象的实际类型是未知的，之所以未知，可以理解成这个对象可以在运行时改变类型，所以最好不要在编译时让编译器知道类型。为了解决这个问题，动态绑定就被引入了。\n不过这个暴论是通过结果说原因，属于是口才的艺术，不过我也懒得去关注这些无关紧要的了\n\n&nbsp;\n”父类指针“相关乱想\n首先在编译器中用子类指针会发生报错\n\n”为什么一定要用父类指针“，其实这个也可以从结果出发，比如我们为什么要用多态，因为要操作方便，操作方便的表现就在多种情况下我们只用到一个接口，那么父类指针就是最好的选择。\n&nbsp;\n引用也可以代替指针\n第一次听说有”父类引用“这个说法\n\n&nbsp;\n虚函数表位置\n不能说一定在什么位置，这个和对象相关，如果对象在堆上表就在堆上，对象在栈上就在栈上\n&nbsp;\ntodo：C语言实现多态\n可见11.21碎片问题补充C++相关计算机基础相关 | Coding中。。。 (jiuriri.com)\n&nbsp;\n什么不能被继承\n\n构造函数\n析构函数\n赋值运算符\n\n\n&nbsp;\n\n2023/12/5更新\n重温多态\n首先在理解多态的时候最好先完全得将这些概念区分开来。\n\n虚函数是多态的实现工具\n虚函数和类继承息息相关\n类继承和多态没有直接联系\n\n\n对类继承的学习导致了我在这方面极其敏感，以至于看见一个类继承就联想起了多态。\n这几句话可能并不严谨，但很好记忆：\n类继承和多态是方便程序员的，它实现了代码复用，但他们的侧重点不同\n类继承复用了实现的过程，而多态复用了创建的过程\n还是那个问题，“明明可以直接使用if树，为什么要使用多态”，这几个月我一直在寻找这个问题的答案，直到学习到了各种设计模式设计原则之后才逐渐明白其中的道理。\n\n开闭原则规定了对扩展开放，对修改封闭，在大型项目中if树往往会变得十分冗长且难以修改，多态就是解决这个问题的完美方案，在对多态修改的时候对不用修改的地方不会造成影响。\n多态的特点是把if树中的内容看作一个个对象，把“条件判断”改为“直接呼号”，通过类继承的父类接口，利用虚函数的虚指针寻到目标方法，再直接对其进行修改，而且为一个个对象定义不同的子类，互不干扰。\n工厂模式是多重多态组合实现的结果，把同一款面粉制造成包子或者馒头，这个原本使用if树的地方改造成多态，这就是工厂模式中的抽象产品类到具体产品类；制造馒头还是制造包子，这个if树也改造成多态，这就是工厂模式中抽象工厂类到具体工厂类。你问为什么步骤要分开，因为我作为老板我需要包子和馒头的不同设计图，多态给了老板我一个产品接口，而用户在点单的时候需要工厂接口来获取不同的选择。由于用户的需求是无限的，也许某一天用户又想吃饺子了，那么设计饺子设计图、搭建饺子工厂和包子和馒头是没关系的，这样做的目的又符合了开闭原则。\n\n\n这样一看，这些概念就形成了闭环，一套嵌一套。那么现在何不重新回想一开始的问题呢，那就是将多态和类继承区分开来。\n#include&lt;iostream&gt;\nusing namespace std;\nclass Base &#123;\npublic:\n    Base() &#123;\n        cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; endl;\n    &#125;\n    ~Base() &#123;\n        cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl;\n    &#125;\n&#125;;\n\nclass Derived : public Base &#123;public:    Derived() &#123;        cout &lt;&lt; &quot;Derived constructor&quot; &lt;&lt; endl;    &#125;    ~Derived() &#123;        cout &lt;&lt; &quot;Derived destructor&quot; &lt;&lt; endl;    &#125;&#125;;\nint main() &#123;    Derived p;    return 0;&#125;&#x2F;&#x2F;实现结果：&#x2F;&#x2F;Base constructor&#x2F;&#x2F;Derived constructor&#x2F;&#x2F;Derived destructor&#x2F;&#x2F;Base destructor&#x2F;&#x2F;这是类继承最基础的规定，那就是&#x2F;&#x2F;“构造子类对象时先调用基类构造函数再调用子类构造函数，销毁子类对象时先调用子类构造函数再调用基类构造函数”\nint main() &#123;    Base* p&#x3D;new Derived;    delete p;    return 0;&#125;&#x2F;&#x2F;实现结果：&#x2F;&#x2F;Base constructor&#x2F;&#x2F;Derived constructor&#x2F;&#x2F;Base destructor&#x2F;&#x2F;类继承的规定仍然起作用，只不过这个时候的指针对象类型其实是“Base”&#x2F;&#x2F;所以自动调用的是基类的析构函数\n&#x2F;&#x2F;如果将基类析构函数设为虚函数：&#x2F;&#x2F;Base constructor&#x2F;&#x2F;Derived constructor&#x2F;&#x2F;Derived destructor&#x2F;&#x2F;Base destructor&#x2F;&#x2F;虚函数将这个析构函数地址存进虚函数表中，这个时候删除指针p，触发多态于是运行子类析构函数，随后继续调用基类的析构函数。&#x2F;&#x2F;——这个是因为子类直接包含了基类的部分，也就是说子类析构函数中其实自动包括了基类的析构函数，而不是析构函数被调用了两次！\n苦于技术不到位，没办法画图更好理解。。。\n\n可以意识到多态的精髓还是这一句\nBase* p=new Derived;\n\nBase说明无论如何这个对象的类型就是基类类型的，于是析构函数会使用基类的——也就是说“多态包子”和“多态馒头”其实就是“面粉类型”。\n对象是指针，说明最后的实现还是要通过虚表指针去找。\nnew Derived显式调用子类构造函数，这个地方可以加深“对象都是由构造函数创建”的概念，同时也能得知“构造函数不能定义为虚函数”这个概念。\n于是缺的就是子类的析构函数了，这个时候如果在子类中分配一些新内存就容易导致错误，于是我们要将基类析构函数定义为虚函数。\n\n\n如果在深入复习，那么就涉及到虚表指针静态绑定动态绑定的过程了，读者可以往上翻翻看，这里就先缓一缓继续探讨面向对象了。\n&nbsp;\n\n2024/9/17更新\n虚函数表的内存分布\n虚函数表存放位置，data段、数据段、常量区。\n由于虚函数表是编译期间决定的，而堆栈区都是运行期间被分配的。而虚函数表本身内容是一个数据，不能把他当作代码，所以也不会放在代码段。这样从结果开始分析就发现放在只读常量段最好。\n虚函数表中存什么，存的是虚函数地址，由虚表指针来指向虚函数表。\n虚表指针和类的成员变量一样放在类中，也就是说他的存放地址随对象分配，可能是堆区也可能是栈区。这里要注意虚表指针是放在类初始地址上的，由于是指针占四个字节，所以可以理解成占类的初始四地址。\n&nbsp;\n类的多继承\n一个类继承多个父类，继承了多少个类就有多少个虚表，也就有多少个虚表指针。\n类本身额外多写的虚函数和第一个继承的父类的虚函数混在一起记在第一个虚表中，按照继承的顺序来存放，父类函数放在子类前面。\n后面继承的类虚函数依照父类不同，分来一个个单独的虚函数表中。\n重写的虚函数同样会重写地址，这个不影响地址分布。\n&nbsp;\n菱形继承\n容易出现二义性和内存浪费的现象，因为孙子类中留有两份基类对象。\n虚继承的原理就是同样是派生类对象拥有虚表指针，虚继承类同样拥有虚表，不过这个虚表内保存的是基类地址偏移量（指针），也就是无论多少个派生类他都是指向同一个基类。\n含虚继承的派生类，在构造时需要将基类与虚基类都构造一遍。因为虚继承关系中只有最终派生类会负责虚基类的构造（程序运行时会忽略其他派生类对虚基类的构造）。这个是编译器规定的，因为虚继承当中只保留一份虚基类实例，这样就导致了其直接派生类可能产生的二义现象，所以直接让间接派生类负责对其的构造。\n引入虚继承会导致额外的性能开销（指针的额外查询）、空间开销（虚继承表）。\n其内存空间布局同样可以递推，比如虚表空间布局、虚类指针空间布局等。不过虚基类表中存储的是从派生类对象的起始地址到虚基类子对象中的偏移量，如果有多个则是依照顺序的多个虚继承。而虚基类表指针这个和虚表指针就一致了，他们都是直接指向表的，由程序在动态运行时经过虚基类表指针找到表，在找到对应偏移值。\n需要注意的是虚基类表指针总是在虚函数表指针之后。\n虚继承后，派生类都会生成它自己的虚函数表和虚表指针，并不完全准确，准确来讲，当虚基类有成员变量时，派生类会生成它自己的虚函数表和虚表指针，当派生类没有成员变量时，并不会重新生成派生类自己的虚函数表和虚表指针。\n\n有一种问法是这样写会如何继承。\nclass A &#123;\npublic:\n    int data;\n&#125;;\n\nclass B : virtual public A &#123;  &#x2F;&#x2F; B 使用虚继承&#125;;\nclass C : public A &#123;  &#x2F;&#x2F; C 不使用虚继承&#125;;\nclass D : public B, public C &#123;  &#x2F;&#x2F; D 继承 B 和 C&#125;;\n\n这样会导致D中存有A的实例又会存有A的偏移量。\n&nbsp;\n\n2024/10/3日更新\n所有的类默认函数\n\n构造函数\n\n带参数的构造函数\n拷贝构造函数\n移动构造函数\n\n\n\n析构函数\n\n赋值运算符重载\n\n\n\n牢记一点就是不同构造函数都是函数重载实现的。\nMyClass()\nMyClass(int a)\nMyClass(const MyClass&amp; class)\nMyClass(const MyClass&amp;&amp; class)\n拷贝构造函数使用引用的原因：\n如果直接传值，那么编译器会为这个值生成一个临时对象，如果说这个值是一个类对象值，那么意味着会调用这个类的拷贝构造函数来进行构造，也就是会无限递归拷贝构造函数导致栈溢出。\n拷贝构造函数和移动构造函数使用const的原因：\n\n防止值被修改，契合构造函数的语义——构造出一个新对象而不是对原对象进行修改\n允许传递常量对象\n\n\n\n","categories":["从C开始的C++"]},{"title":"C#集合与泛型","url":"/2023/11/06/C-%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/","content":"\n\n\n\n\nC#集合与泛型\n\nC#集合与泛型\n&nbsp;\n数组\n\n数组是带索引的同类型对象的集合。\n数组是一个对象，他们具有各种方法和属性。\n\n\nint [] arr =new int[10];——创建了一个System.Array的对象\n–对于预定义类型，每个元素已经具有默认值。\n–对于一般的自定义对象的数组，如MyClass.\npublic class C\n&#123;\n    public int i;\n    public C(int pi)\n    &#123; \n        this.i = pi;\n    &#125;\n&#125; \n\n&nbsp;\n索引器\n类似属性，可使用 get 和 set 访问器来定义索引器。\n“它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。”\n\npublic class FootBallTeam\n    &#123;   string[] players;\n        public FootBallTeam()\n        &#123;\n            players = new string[11];\n        &#125;      \n         public   string this[int index]\n        &#123;\n            get\n            &#123;\n                if (index &gt;= 0 &amp;&amp; index &lt; 11)\n                    return players[index];\n          \t\treturn &quot;&quot;;\n            &#125;\n            set\n            &#123;\n             if (index &gt;= 0 &amp;&amp; index &lt; 11)\n                players[index] = value;\n         &#125;\n    &#125;\n&#125;\n\nthis是必要的\n\n可以在set或者get前增加private\n&nbsp;\n集合类所支持的接口\n先试看List类\npublic class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable  \n\nn为了支持foreach语句，集合类必须实现IEnumerable 接口，该接口只包含一个方法 GetEnumerator\n&nbsp;\n公用集合类\nSystem.Collections名字空间下：\n\nArrayList——动态增长的数组\nStack——堆栈\nQueue——队列FIFO\nSortedList——键值对集合，根据键值排序\nHashTable——键值对集合，根据键的哈希值组织\n\n\n以上集合类存放的是“对象”\n泛型形式更加常用\n\n&nbsp;\n泛型\n泛型类、泛型方法，常与集合或者集合相关方法使用\n\n早期C#版本中，通过化是这样子的：\nArrayList list1 = new ArrayList();\n list1.Add(3);\n list1.Add(105); \nArrayList list2 = new ArrayList(); \nlist2.Add(&quot;It is raining in Redmond.&quot;); \nlist2.Add(&quot;It is snowing in the mountains.&quot;); \n\n也就是类型与通用基类Object直接进行强制转换\n\n多次装箱拆箱影响性能\n缺少编译时类型检查\n\n\n&nbsp;\n泛型参数：\nList&lt;int&gt; list1 = new List&lt;int&gt;(); \nlist1.Add(3); \n\n&nbsp;\npublic class GenericList \n在泛型类型或方法定义中，类型参数是客户端在实例化泛型类型的变量时指定的特定类型的占位符。\n类型形参声明必须是标识符，不能是类型。\n   public class GenericList&lt; int size&gt;  \n   C++中允许非类型的模板参数。\n \nC++ 使用typename 或class 关键字\nC# 中无需关键字。\nC++中的非类型模板参数在类中可以当作常数使用，比如说定义数组\n\n&nbsp;\n约束\n约束就是用来约束泛型的，指限制泛型不用某种特殊类型参数\n\npublic class GenericList where T:\n\n&nbsp;\n泛型接口\n为泛型集合定义接口\n\n非泛型接口：\npublic interface IComparable//  非泛型接口\n    &#123;\n       int CompareTo(object obj);    \n    &#125;\npublic class Person : IComparable &#123;\n        double  height;\n        public int CompareTo(object obj)\n        &#123;\n            Person p = obj as Person;  // 类型转换是很耗时的\n            if (this.height &gt; p.height ) return 1;\n            else return -1;\n        &#125;       \n    &#125;\n\n&nbsp;\n泛型接口：\npublic interface IComparable&lt;T&gt;// 泛型接口\n    &#123;\n         int CompareTo(T other);  \n    &#125;\n \npublic class Person : IComparable&lt;Person&gt; &#123;        public   double height;        public int CompareTo(Person other)        &#123;            if (this.height &gt; other.height)  &#x2F;&#x2F; 没有转换，快速                    return 1;            else return -1;        &#125;    &#125;\n泛型方法\nstatic void Swap&lt;T&gt;(ref T lhs, ref T rhs)\n &#123; \n    T temp; \n    temp = lhs; \n    lhs = rhs; \n    rhs = temp; \n&#125; \n\n只适用于泛型类成员\n\n&nbsp;\n常用泛型类\nSystem.Collections .Generic名称空间下：\n\nStack&lt;&gt;\nQueue&lt;&gt;\nHashSet&lt;&gt;\nList&lt;&gt;\nDictionary&lt;&gt;\n\n\n&nbsp;\nList&lt;&gt;\n表示可通过索引访问的对象的强类型列表。提供用于对列表进行搜索、排序和操作的方法。\n\n\n&nbsp;\nHashset&lt;&gt;\n提供高性能的集合运算。集合是一组不重复出现且无特定顺序的元素.\n\n\n&nbsp;\n无法排序的集合通过以下方式排序：\nclass Node\n    &#123;      \n    public int i;   \n    public int j;\n    public Node( int pi,int pj)    \n    &#123;       \n        i=pi;j=pj;             \n    &#125;      \n&#125;\nHashSet&lt;Node&gt; hs = new HashSet&lt;Node&gt;();            \nRandom r = new Random();\n           \nfor (int i &#x3D; 0; i &lt; 5; i++)&#123;    int temp&#x3D; r.Next(100);    hs.Add(new Node(temp, temp*2));&#125;\nforeach (Node n in hs) MessageBox.Show(n.i.ToString());IEnumerable&lt;Node&gt; ie &#x3D; hs.OrderBy(n &#x3D;&gt; n.i);\nforeach (Node n in ie) MessageBox.Show(n.i.ToString());\n&nbsp;\nDictionary&lt; TKey, TValue&gt;\n提供了从一组键到一组值的映射。字典中的每个添加项都由一个值及其相关联的键组成。\n\n\n&nbsp;\n泛型中的协变和逆变\n\n协变：Covariance\n\n\n–指能够使用比原始指定的派生类型的派生程度更小(不太具体的)的类型，\n\n逆变：Contravariance\n\n\n–指能够使用比原始指定的派生类型的派生程度更大（更具体的）的类型。 \n\n","categories":["从C++开始的C#"]},{"title":"C++面试","url":"/2024/09/14/C-%E9%9D%A2%E8%AF%95/","content":"\n\n\n\n\n9.13面试拾遗\n\n9.13面试拾遗\n\nDelete与Delete[]\n\n\ndelete 释放new分配的单个对象指针指向的内存；\ndelete[] 释放new分配的对象数组指针指向的内存。\n&nbsp;\n如果是简单类型，其实都可以！\nint *a = new int[10];\ndelete a;\ndelete[] a; //都不会报错\n\n释放效果是相同的，分配简单类型时内存大小已经确定，系统已经记忆好了。\n它直接通过指针可以获取实际分配的内存空间，信息存在结构体_CrtMemBlockHeader中\n&nbsp;\n如果时复杂类型就会出现差异。\nclass A\n&#123;\n    private:\n    char *m_cBuffer;\n    int m_nLen;\npublic:\n    A()&#123; m_cBuffer = new char[m_nLen]; &#125;\n    ~A() &#123; delete [] m_cBuffer; &#125;\n&#125;;\nA *a = new A[10];\ndelete a; //仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏\ndelete[] a; //调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间\n\ndelete ptr代表用来释放ptr指向的内存。\ndelete[] rg用来释放rg指向的内存，还逐一调用数组中每个对象的destructor。\n简单类型没有，析构函数，所以加不加中括号是等同的。\n如果对象中含有系统资源，那么不调用析构函数容易造成文件线程端口等的死锁。\n&nbsp;\n\n直接调用基类函数\n\n\n继承关系中，如果只拥有子类的引用，要调用基类函数，可以在子类函数中写下：Base::func()\n&nbsp;\n\n数组初始化\n\n\n无敌了真能被这个给问倒\n\nint a[10]=&#123;0&#125;;\nchar str[10]=&quot;\\0&quot;;    //等价于char str[10]=&#123;0&#125;;\n\n\nint a[10]&#x3D;&#123;0,1,2,3,4,5,6,7,8,9&#125;;char str[10]&#x3D;&quot;Hello&quot;;\nint a[]&#x3D;&#123;0,1,2,3,4,5,6,7,8,9&#125;;\nint a[2][5]&#x3D;&#123;&#123;0,1,2,3,4&#125;,&#123;5,6,7,8,9&#125;&#125;;\nint *pia &#x3D; new int[10];\n&nbsp;\n\ndelete this\n\n\n对象必须是new出来的才能这样自行删除。\n这一句代码执行后该对象、该对象的任意成员变量都不能被访问，也就是说安全性不足。\n保证delete this之后调用的函数不会调用到这个对象的虚函数以及成员变量。\n因为detele之后内存不是立即返回给操作系统，而是会因为缓存保留一段时间，这个时候反而是可以读取到的，就有可能出现问题。\n析构函数不能用delete this，delete this本身就是在调用析构函数，如此就堆栈溢出了。\n强制需要this的情况：需要将对象作为整体引用时。\n&nbsp;\n\n虚基类\n\n\nClass A；\nClass B ：public A；\nClass C ：public virtual A；\nClass D ：public B ,public C；\n实现原理和虚函数一样，都是虚类表与虚类指针。\n虚基类依旧存在继承类中，只占用存储空间；虚函数不占用存储空间。\n虚基类表存储的是虚基类相对直接继承类的偏移；而虚函数表存储的是虚函数地址。\nC++ 虚继承实现原理（虚基类表指针与虚基类表）-CSDN博客\n&nbsp;\n\n内存对齐\n\n\nstruct stu&#123;\n    char sex;\t\t\t\n    int length;\t\t\t\n    char name;\t\t\n&#125;;\n\n我不知道为什么我老喜欢说这个sizeof后是9，纯天才\n&nbsp;\n\n拷贝构造函数\n\n\nclass A&#123;\n    A(const A &amp;a)&#123;\n        //临时对象具有常性，也就是穿过来的右值，所以用const\n        //标准上说const可以接收const与非const的参数\n        //如果不加&amp;就会变成普通的复制构造函数\n    &#125;\n&#125;\n\n&nbsp;\n\nUnity文件引用\n\n\n由于我有写查找对象引用经历，被问到了，忘了\n\nmeta文件中含有guid，无论什么文件都有这个guid。\nFileId指在文件内区分不同文件的标识符。\n保存引用关系就是通过保存guid来实现的。\n&nbsp;\n\n链表节点删除\n\n\n单给一个节点，如何单独删除它，在不知道前序节点的情况下。\n获取后面节点的值，将其赋给当前节点，再直接删除后续节点。\n&nbsp;\n\n链表快排\n\n\n\t和数组快排一样\n/**\n * Definition for singly-linked list.\n * struct ListNode &#123;\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) &#123;&#125;\n *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n * &#125;;\n */\nclass Solution &#123;\npublic:\n    ListNode* solve(ListNode* p)&#123;\n        if(!p||!p-&gt;next)&#123;\n            return p;\n        &#125;\n\n    ListNode* L = partition(p);\n    ListNode* R = p-&amp;gt;next;\n    //快排的细节是操控节点的选取要默认往下一位。\n    //要注意这里的p其实是已经经过partition后的，也就是右边节点的第一个。\n    //不然会出现111这种无限排序的现象，在数组中因为我们习惯性默认往下排了一位，但链表需要特殊处理\n    \n    p-&amp;gt;next = NULL;\n\n    //返回出左边头节点和右边头节点，然后遍历左边链表到尾节点后链接到右边\n    ListNode* resultL = solve(L);\n    ListNode* resultR = solve(R);\n    ListNode* P = resultL;\n    while(P-&amp;gt;next)&#123;\n        P = P-&amp;gt;next;\n    &#125;\n    P-&amp;gt;next = resultR;\n    return resultL;\n&#125;\n\nListNode* partition(ListNode* h)&#123;\n    //逆大天数据超时，这里可以优化成选择中间节点（快慢指针）\n    ListNode* L = new ListNode(-1);\n    ListNode* R = new ListNode(-1);\n    ListNode* l = L;\n    ListNode* r = R;\n    ListNode* p = h;\n    int val = h-&amp;gt;val;\n    while(h)&#123;\n        p = h-&amp;gt;next;\n        h -&amp;gt;next = NULL;\n        if(h-&amp;gt;val&amp;lt;val)&#123;\n            L-&amp;gt;next = h;\n            L = L-&amp;gt;next;\n        &#125;\n        //这里的h隐性放到了右边节点的第一位，间接影响了主函数的遍历\n        else&#123;\n            R-&amp;gt;next = h;\n            R = R-&amp;gt;next;\n        &#125;\n        h = p;\n    &#125;\n\n    L-&amp;gt;next = r-&amp;gt;next;\n    R-&amp;gt;next =NULL;\n    return l-&amp;gt;next;\n&#125;\n\nListNode* sortList(ListNode* head) &#123;\n    return solve(head);\n&#125;\n\n};\n&nbsp;\n&nbsp;\n\n","categories":["面试查漏补缺"]},{"title":"GAS插件基本概念","url":"/2025/11/23/GAS%E6%8F%92%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"\n\n\n\nGAS技能系统基本概念\n\n\nGAS技能系统基本概念\n参考：[UnrealOpenDay2020]深入GAS架构设计 | EpicGames 大钊哔哩哔哩bilibili\n词汇表\nUAbilitySystemComponent - ASC ——只有拥有ASC的Actor才有释放管理技能的能力\nUGameplayAbility - GA ——一个技能的主体逻辑\nUGameplayEffect - GE ——一个技能的效果（属性的修改，动作的触发）\nUGameplayCueNotify - GC ——特效部分（一次性特效、持续性特效）\nFGameplayAttribute - Attribute ——一个游戏属性（生命值等等），多个组成AttributeSet挂载在Actor上\nFGameplayTag - Tag ——给类和对象挂标签，层次化搜索\nUGameplayTask - Task ——异步操作任务\nFGameplayEventData - Event ——游戏事件（ASC之间）\n\n核心架构\n\n\nEditor（绿色）主要是实现UI部分\n\n\n&nbsp;\nTag\n\n本质是轻量化的FName、内存中组织为树状结构（UGameplayTagsManager），模式为A.B.C代表树状的嵌套结构。在编辑器中的ProjectSettings左边的ProjectTags可找到全局定义的所有Tags。\nGameplayAttribute\n\nfloat BaseValue——初始值\nfloat CurrentValue——被buff效果叠加后的值\n\n\n方便进行回滚\nGameplayEffect\n\n\n修改属性——统一的流程途径修改GA，方便统一进行回调\n流程效果——修改属性的逻辑，Tag增减（眩晕、沉默），给与能力\n\n\nGameplayCue\n\n可以在GE里配置触发，也可以在GA里手动进行调用触发\n\nStatic：一次性效果（爆炸）\nActor：持久（火焰）\n\n\nGameAbility\n\n\n不要把基础移动、射线检查、UI交互当成能力\n表示专门用来触发的什么事件\n\n\nGameplayTask\n\n\n执行异步任务（等待蒙太奇、等待一段时间）\n框架中已经有一系列预制好的Task\n\n\nGameplayEvent\n\n\n手动触发Actor之间的游戏时间\n靠Tag进行识别，可以携带Payload数据（如子弹命中后的回调）\n\n\nAbilitySystemComponent\n\n\n运行核心、管理协调\n\n\n\n技能系统的实质，就是Actor上的ASC向另一个Actor的ASC上相互增删Effect、触发Cue、贴标签的流程。\n\n\n总结\n&nbsp;\n\n\n","categories":["虚幻引擎系列"]},{"title":"InsideUE5阅读笔记GamePlay","url":"/2024/10/06/InsideUE5%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0GamePlay/","content":"\n\n\n\n\nInsideUE5阅读笔记GamePlay架构篇\n\nInsideUE5阅读笔记GamePlay架构篇\n《InsideUE4》基础概念 - 知乎 (zhihu.com)\nUE5文件目录\n\nBinaries：存放编译生成的二进制文件（gitignore）\n\nConfig：配置文件\n\nContent：蓝图、资源等\n\nDervedDataCache（DDC）：引擎针对平台特化后的资源版本\n\nIntermediate：各种中间文件\n\nBuild中间文件\nUHT预处理的.generated.h/.cpp文件\nVS项目文件\nAssetRegistryCache缓存文件，uasset资源注册表\n\n\n\nSaved：自动保存文件，日志，烘焙数据等\n\nSource：代码文件\n\n\n\n&nbsp;\n命名约定\n\nT：模板类TArray，TMap，TSet \nU：UObject派生类\nA：AActor派生类\nS：SWidget派生类\nI：抽象接口\nE：枚举类\nb：bool变量\nF：其他类型——FString，FName\n\n\n&nbsp;\nUObject\nUE游戏世界的所有类基类，提供元数据、反射生成、GC垃圾回收、序列化、编辑器可见，Class Default Object等。动态创建。\n一句话介绍：大多数与游戏逻辑、资源管理相关的类都继承自UObject，UObject为这些类提供了反射、序列化、GC等功能，AActor就是其中之一。Actor通过组装Component来实现一些具体的功能，同时也可以通过UChildActorComponent实现父子嵌套（SceneComponent有transform，所以理论上SC会被当成RootComponent，而且父子嵌套的实质也是SceneComponent之间的嵌套）。同样继承于UObject的ULevel中含有所有Actor的引用，Level也就是关卡，也可以理解为大地图上的一块区域，多个Level组成一个World。再往上走，World由WorldContext来进行切换，切换world的本质是切换PersisitentLevel。world之上就是GameInstance了。\n&nbsp;\nAActor\n继承自UObject，额外提供Replication（网络复制），Spawn（生命周期），Tick（更新）功能。此外，Actor提供TArray存储子Actor。\nActor不提供Transform，因为有许多不需要带有坐标的object也是Actor，比如世界设置对象，游戏模式对象等，UE不需要这些没有坐标的对象独立划出空间来存储“坐标”来浪费空间。\n&nbsp;\nComponent\nUActorComponent的简称，是所有Compnents的基类。\n在AActor中，有一个TSet&lt;UActorComponent*&gt; OwnedComponents，保存着这个Actor所拥有的所有Component,一般其中会有一个SceneComponent作为RootComponent。\nActor中支持包含多个SceneComponent，也就是一个Actor其实可以代表多个实体\n\nTArray&lt;UActorComponent*&gt; InstanceComponents，存储被实例化的Components。\n如果Actor要想被放进Level中，必须要有实例化USceneComponent（源码中声明为“RootComponent”），在这个Component中，包含Transform和SceneComponent相互嵌套功能。\n虚幻引擎遵循组合优于继承的概念，所以只有带有Transform的SceneComponent拥有嵌套功能，其他组件不能相互继承嵌套。\nActor之间有父子关系的概念，但是Actor并不关心父子关系，Actor只负责对象的网络同步，创建销毁等功能，父子关系由SceneComponent负责，因为他又Transform，在3D坐标世界上就能理解了。所以Actor的类“AddChildren”的方法“Child：AttachToActor“是间接通过调度”Child:AttachToComponent“来创建父子关系的。\n&nbsp;\nLevel\n由多个Level组成一个World，是Actor的容器，供玩家活动的场景，包含静态网格体（Static Mesh）、体积（Volume）、光源（Light）、蓝图（Blueprint）。\nLevel的释放和加载是动态的，类似于Unity引擎中的”场景“，Level可以视为闯关类游戏中的会切换场景的关卡，也可以视为吃鸡游戏中将大地图动态进行划分的区域（不可视区域没必要加载）。这样的粒度也方面团队协作。\n\n\n\nALevelScriptActor:顾名思义即Level自己的脚本，可以在这个脚本内获取关卡内所有的Actor，可以编写这个Level的相关游戏逻辑。\nAWorldSettings：AInfo类的类都不直接放入world中，这个worldsetting只和本Level相关，内含各种Level相关的配置设置，例如GameMode等\n\n\n世界场景设置（World Settings） | Unreal Engine (52vr.com)\n\n\nAInfo：那些再world中没有物理展示的Actor基类，保存world中设置数据的管理类，也可以作为实现复制意图的Actor使用。\n\n\nALevelScriptActor意思是关卡的脚本Actor，用于执行Level中的逻辑操作，而WorldSetting继承于AInfo，用于操作游戏世界的设置。\n在Level中，WorldSetting记录本Level中的所有规则属性，Level记录了Level内的所有Actor。而Actor内也存储WorldSettings和LevelScriptActor。\n\n\nULevel内的Actor排序\nULevel内有一个TArray&lt;AActor*&gt; Actors字段存储关卡内所有Actor，遍历Actors会很花时间，所有Level内有一个排序Actor的方法ULevel::SortActorList()，他会单独把网络对象和非网络对象分开，网络对象放在后面，并使用索引进行标记，可以加速网络复制的检测速度。（AWorldSettings是静态数据提供者，是放在最前列的）\n于Unity的异同\nUnity中和Level很像的场景概念叫Scene\n\nScene之间独立，一个Scene包含它自己需要的对象、组件、光照等，切换场景时完全卸载；Level可以由多个Sublevel组成，多个Sublevel流式加载到同一个主关卡。虽然Unity也支持流式加载，但Unity的Scene加载需要在代码中手动管理控制，没有向UE那样直观。\n\n\nUE5中被World Partition替换，自动将世界分块，根据玩家视角与距离动态加载卸载\n\n\nScene本身没有逻辑，要完成一些关卡相关的逻辑必须单独挂GameObject加脚本逻辑；Level有单独的关卡蓝图脚本系统，如ALevelScriptActor。\n\n\n\n&nbsp;\nWorld\n在World中用SubLevel的方式将Level拼接起来。\nPersisitentLevel：一开始就加载进来的Level\nStreamingLevels：动态加载进来的Level\nLevels：当前已经加载进来的Level\n当然可以一口气把单独的Level放进PersisitentLevel里，也可以按照流式加载进行区分，如果是后者则World里有一个叫CurrentLevel的引用，在编辑器里指向其他Level，而运行时只指向PersistentLevel。\n相关WorldSetting以PersistentLevel为主，也有单独为特定Level配置的设置。\nLevel之间不会共享Actor的引用，但是碰撞时全局的，也就是说所有的Actor物理实体是在World当中的。\n&nbsp;\nWorldContext\nnamespace EWorldType\n&#123;\n    enum Type\n    &#123;\n        None,\t\t// An untyped world, in most cases this will be the vestigial worlds of streamed in sub-levels\n        Game,\t\t// The game world\n        Editor,\t\t// A world being edited in the editor\n        PIE,\t\t// A Play In Editor world\n        Preview,\t// A preview world for an editor tool\n        Inactive\t// An editor world that was loaded but not currently being edited in the level editor\n    &#125;;\n&#125;\n\n各种不同的World类型\n\nWorldContext就是管理这些不同World的工具，负责World之间切换的上下文，也负责Level之间切换的操作信息。\n&nbsp;\nGameInstance\n继承于UObject。\n保存WorldContext和其他的整个游戏的信息，贯穿游戏始终，在整个游戏内保持一致。\n惯常的做法是继承GameInstance，并编写那些能作用于整个游戏范围的逻辑，比如玩家的单机分数之类，这些是不随关卡退出而刷新的，比如联网逻辑或者全局游戏设置等。以此来”扩展“GameInstance的功能，可以在UE中配置自定义的GameInstance。\n&nbsp;\nEngine\n分化为两个子类：UGameEngine和UEditorEngine。\nUGameEngine指游戏运行时逻辑的引擎类，当游戏打包启动的时候负责游戏的核心逻辑。\nUEditorEngine指编辑器状态的逻辑引擎类，负责创建和编辑游戏内容。\n启动PIE状态由UEditorEngine负责，但是启动之后的PIE状态本身就是由UGameEngine负责。\n\n&nbsp;\nGamePlayStatics\n蓝图静态方法的暴露类，方便操作蓝图数据库。\n&nbsp;\nPawn\nPossess然后传递Input\n\n继承于AActor。即“可操控的棋子”。\npawn定义了三个模板方法接口：\n\n可被Controller控制\nPhysicsCollision表示\nMovementInput基本响应接口\n\n\n对于Input，Actor本身能接受input事件，如wasd事件，但是接受事件之后如何进行响应Actor就没有继续进行处理了。而Pawn额外包装了一层MovementInput，可以理解为默认地增加了“按下w之后会向前移动”的逻辑接口。\n一句话介绍：Pawn就是一个特殊的Actor，它具备“可被控制”、“物理Collision表示”、“移动响应MovementInput”接口三个基本功能，可以对这三个功能进行定制化，派生出“默认的DefaultPawn”、”观战SpectatorPawn“、”人型Character“。AController也是特殊的Actor，用于控制Pawn，可以派生出APlayerController和AAIController。APlayerState继承于AInfo，AInfo是没有物理表示的AActor，APlayerState于AController绑定在一群，充当网络复制的数据状态。\n&nbsp;\nDefaultPawn\n默认的Pawn，带有默认的DefaultPawnMovementComponent、spherical CollisionComponent和StaticMeshComponent。\n&nbsp;\nSpectatorPawn\n继承于DefaultPawn，将Movement改为了“USpectatorPawnMovement（不带重力漫游）”，关闭了StaticMesh显示，定义了一个“观战摄像机”行为。\n&nbsp;\nCharacter\n继承于Pawn，人型pawn。\n相当于带人型骨架的Pawn，同样带有移动、碰撞体、mesh三部分，不过是人型的。\n&nbsp;\nController\n继承于AActor。\nController于Pawn是一一对应的，也就是说如果碰上需要一次性操控多个Pawn，或者多个Ctr控制单个Pawn的情况，需要进行特殊处理。有种鼓励人们去进行扩展的意思，毕竟一对一的模式更加方便引擎自身进行项目管理和错误筛查。\n和Unity的不同：\nUnity是GameObject+Component的模式，自由组合，对此并没有任何定义，也就是说控制器、角色本体、甚至MVC模式设计模式本身都需要从0开发。这给了设计者非常大的自由性。\nUE规定好UObject、Actor、Component的各自职责，衍生出了Pawn+Controller的角色控制模式，更加强调类之间的层级关系。\n\nController与Pawn：\n\nPawn与Controller都掌管Actor“运动“的概念，其中Pawn更强调”运动的能力“，例如碰撞检测、动画播放、位置更新等；而Controller更强调”运动的决策“，也就是运动自身的逻辑，什么时候该走，该往哪个方向走。\nPawn更强调能力，也就是说Pawn更适合编写特地的一些功能逻辑，例如战车与坦克，坦克能开炮，战车不能，所以坦克Pawn需要编写开跑功能；而他们两者都能驾驶，所以可以使用同一个Controller来控制他们两个。\nController更面向玩家，Pawn因为某些情况”死掉了“，例如血条清空等，那么Pawn自身就析构了，而Controller还存在，毕竟实际上玩家还是有权利控制控制器的，只不过可能得不到反馈罢了。所以如果有持久性的例如玩家得分需要进行记录，那么可以放在Controller当中进行逻辑处理。\n\n\n\n&nbsp;\nAPlayerState\n继承于AInfo。AInfo应该不陌生，也就是”没有实体的Actor“。\nController可以存取玩家状态，就是通过其内部引用的APlayState实现的。\nAPlayerState与Pawn、Controller是平级的关系，虽然和Controller绑定，但其实有多少实际的玩家才会生成多少APlayerState。\nAPlayerState独立成一个Actor还能保证网络同步时的数据稳定性，比如UE的网络架构中，如果断开连接，那么Controller就消失了，再次连接上时重新使用APlayerState的数据进行重连就好了。\nAPlayerState在切换关卡的时候也会被释放掉，所以和GameInstance作区分，照开发实际需求来就好。\n\n&nbsp;\nAPlayerController\n继承于AController\n\nCamera管理——可以知道Camera是挂在Controller上而不是Pawn了\nInput系统\nUPlayer关联（LocalPlayer或者UNetConnection）\nHUD显示\nLevel切换（网络切换Level通过PCtr进行RPC调用后转发到自己的World）\nVoice\n\n\n&nbsp;\n&nbsp;\nAAIController\n继承于AController\n\nNavigation导航\nAI行为树等其他AI组件\nTask系统\n\n\n\n&nbsp;\nGameMode\n由AInfo派生。管控Level相关逻辑。\n\nClass登记与实体Spawn：反射出的UClass类型信息就登记在此，用于方便Spawn出新对象。\n游戏进度：重启游戏、暂停游戏的支持。SetPause、ResartPlayer函数进行逻辑控制。\n\n\n\nLevel切换：可以指定是否播放开场动画。\n多人游戏状态：MatchState指定开始状态结束状态。\n\n\nLevel Blueprint与GameMode：\n\n前者注重关卡内特殊表现，后者注重游戏本体逻辑\n简而言之就是通用玩法可以放GameMode里\nGameMode只在Server中有\nGameMode与PlayerController职责很像，都是负责游戏玩法，连着和不冲突\n\n\n\n&nbsp;\n一句话介绍：除了PlayerState，同样也有其他派生自AInfo的类，对应Level的State叫做”AWorldSetting“，对应一局游戏的State叫做”GameState“。GameMode更侧重于管控Level的逻辑，比如游戏进度等。每个Level都可以独立设置GameMode，也可以直接配置全局的GameMode。GameState代表了一局游戏中的数据，例如玩家一局中的得分等，而GameInstance表示的是贯穿一整个游戏程序的数据。\n&nbsp;\nGameState\n由AInfo派生，和APlayerState对应，保存当前游戏的状态数据，比如任务数据等。\n与GameInstance做区分，GS是一局游戏的数据，而GI是整个游戏程序的数据\n\n&nbsp;\nUPlayer\n看到这里的时候不由得感到震惊，感觉UE做的GamePlay框架真的很多\n\n继承于UObject。是Actor与Game层之间的中间层。\n级别比World更高，因为哪怕World不断切换，玩家是一成不变的。UPlayer当中置有PlayerController的引用，所以可以理解为两者是相互关联的（即引擎会为Player做输入相应）。UPlayer不代表游戏中的存在，而是确确实实代表玩家本身在Gameplay中的类。\n一句话介绍：GameInstance不仅保存World，也存储Player。LocalPlayer代表本地玩家，NetConnection代表远端的连接，负责同步远端的PlayerState。LocalPlayer再GameInstance除四害的适合就默认创建出来，而远程的玩家通过远程同步数据，并不具备输出能力。\nULocalPlayer\nUPlayer的派生，即本地玩家。GameInstance具有ULocalPlayer的列表，支持遍历访问实现本地玩家相关操作。\n为了顺从UE越来越多的网络联机需求，单独分出来Local的玩家类，比UPlayer多出来了Viewport的功能逻辑，在本地屏幕上给出操作反馈。\nLocalPlayer创建流程：\n1.初始化GameInstance默认创建GameViewportClient（管理渲染窗口、处理用户输入，与游戏视图和渲染系统交互）。\n2.内部转发到GI的CreateLocalPlayer创建LocalPlayer，再创建PlayerController。\n3.调用Ctr内部的InitPlayerState，将PlayerState与LocalPlayer对应上来。\n4.网络联机中远程同步过来的PlayerState通过Replicated过来。\n\n&nbsp;\nUNetConnection\nUPlayer的派生，代表远程同步过来的玩家对象。\n相比于ULocalPlayer，少了输出相关的逻辑。\n\n&nbsp;\nGameInstance\n继承于UObject。在GameEngine里创建。\n\n引擎初始化，init、shutDown\nPlayer的创建，CreateLocalPlayer，GetLocalPlayers\nGameMode的重载\nOnlineSession的管理\n\n\nGameInstance可以被上层的Engine实例出多个的。（理论上）\n\nPIE：指在编辑器中按下“Play”后在编辑器的上下文当中运行的游戏，可以实现动态更改场景蓝图变量等。（存有GI）\n\n\n\n独立启动游戏：指脱离编辑器运行的游戏，通过编译/打包后运行的可执行文件。（存有GI）\n\n\n\n编辑器模式：直接在编辑器中进行操作，可以做到对场景、关卡、甚至动画等的实时浏览功能，但是没有输入相应。（不存有GI）\n\n\n\nGI一般能做的业务逻辑：\n\n切换Level相关\n自定义生成Player\nUI相关（一般开发都是由专门的Actor负责管理UMG，但是使用GameInstance管理也是一种思路）\n全局配置（游戏设置）\n从游戏启动到游戏结束中需要存储的全局变量\n\n\n&nbsp;\nSaveGame\nGameInstance适合存储关卡外存储的数据变量，如果由需要存进内存中的持久性数据，可以考虑继承USaveGame，通过UObject的序列化机制来实现属性字段的序列化保存。\n相关接口：\n\nCreateSaveGameObject\nLoadGameFromSlot\n\n\n&nbsp;\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n","categories":["虚幻引擎系列"]},{"title":"DOTween插件入门","url":"/2023/11/15/DOTween%E6%8F%92%E4%BB%B6%E5%85%A5%E9%97%A8/","content":"\n\n\n\n\nDotween——动画效果\n\nDotween——动画效果\nDOTween 是一个快速、高效、完全类型安全的 Unity 面向对象动画引擎，针对 C# 用户进行了优化，免费和开源，具有大量高级功能。\n要使用Dotween，需要导入名字空间\nusing DG.Tweening\n\n也可以不导入，然后自己修改Global setting或Specifix settings。\n例如：DOTween.Init(autoKillMode, useSafeMode, logBehaviour);\n&nbsp;\n初始化\n可以自己初始化，也可以默认系统自己初始化，但最好自己初始化。\n这个操作也可以在DOTween的GUI中进行，但是代码可以实现中途变换，也就是说第二次初始化DOTween之前创建的tween不会受到这次初始化的影响。\nstatic DOTween.Init(bool recycleAllByDefault=false,bool useSafeMode=true,LogBehaviour logBehaviour=LogBehaviour.ErrorsOnly)\n\nrecycleAllByDefault——设置为false说明不进行回收，结束后直接销毁\nuseSafeMode——设置为true会使tween更慢但更安全，允许允许时处理事件\nLogBehaviour——根据所选模式进行错误、警告等信息记录\n\n\n&nbsp;\nAPI\n有一些小技巧能初步认识函数方法：\nDO: 动作操作前缀。例如：DoMove(),DoKill()等等。\nSet:动画设置操作前缀。例如：SetLoop(),SetEase()等等。\nOn: 响应回调事件前缀。例如: OnStart(),OnComplete()等等。\n&nbsp;\n生命周期\n在创建tween是，会自动播放。\n结束后会自动终止。\n更改autoKill为FALSE，则不会自动清除tween，可以实现重复使用。\n不需要手动回收tween。\n&nbsp;\nOnComplete(TweenCallback callback)：动画完成触发事件\nOnKill(TweenCallback callback)：动画被销毁时触发\nOnPlay(TweenCallback callback)：当动画播放的时候触发，每次播放都会触发\nOnPause(TweenCallback callback)：当动画暂停时\nOnRewind(TweenCallback callback)：动画被重置时\nOnStart(TweenCallback callback)：当动画第一次播放的时候，再播的时候不会被触发了\nOnStepComplete(TweenCallback callback):完成单个循环开始调用\nOnUpdate(TweenCallback callback):每一帧调用\nOnWaypointChange(TweenCallback callback):路径回调\n&nbsp;\n使用方式\n小白版：DOTween.To(()=&gt;myValue,x=&gt;myValue=x,100,1);\n第一个lambda表达式表示将myValue返回给起始值，myValue是提前设置好的一个变量，中间的lambda表示更新数，x会由DOTween自动更新，然后赋予给myValue然后实现更新，100则是最终目标值，1代表时间，也就是说这一句表示myValue过渡到100，时间为1\n\n原型为DOTween.To(getter,setter,to,float duration)\n\ngetter——一个委托，将属性的值返回给补间\nsetter——一个委托，将属性的值设置给补间\nto——要到达的最终值\nduration——补间持续时间\n\n\n\n专业版：transform.DOMoveX(100,1);\n表示直接将目标对象当前的X坐标平滑过渡到100，时间为1\n\n这是与一些已知Unity对象的适用方法，例如Transform、Rigidbody、Material\n这些快捷方式有一个from版本，例如transform.DOMoveX(100,1).from();指将对象从这个值缓动为当前值\n\n&nbsp;\n这两种方式都会返回一个tween，用于储存为引用以后再次使用。\n一些详细的基本使用方式：\nDOTween - 文档 (demigiant.com)\n其他方法：\nPause():暂停动画\nSetLoops(3):循环3次\n&nbsp;\nSequences（序列）\n不要使用空序列！！！\n\n序列指一堆补间分为一组进行处理，同样一堆序列也可以分为一组，深度没有任何限制。——不过被嵌套的序列会被锁定\n补间只能嵌套在单个序列中，不能重复分组。\n初始化：\nSequence mySequence = DOTween.Sequence();\n 一些新概念：\n回调函数——//todo\n\n用以下方法操控序列：\n\nAppend(Tween tween)——添加一个tween\nAppendCallback(TweenCallback callback)——添加一个回调函数\nAppendInterval(float interval)——添加一个时间间隔\nInsert(float atPosition,Tween tween)——在给定的时间位置插入给定的补间，这样一来可以重叠补间\nInsertCallback(float atPosition,TweenCallback callback)——如上，现在是插入回调函数\nJoin(Tween tween)——在刚插入的最后一个补件或回调的位置同时插入新补间\nPrepend(Tween tween)——在序列最前面添加\nPrependCallback(TweenCallback callback)——同上\nPrependInterval(float interval)——同上\n\n\n文档中的原话“You can create Sequences made only of callbacks and use them as timers or stuff like that.”\t\n意思是可以利用回调函数与间隔时间这两个特性设置动画版计时器，而且会更加精准。\nusing UnityEngine;\nusing DG.Tweening;\n\npublic class MyScript : MonoBehaviour&#123;    private Sequence timerSequence;    private float elapsedTime;\nprivate void Start()\n&#123;\n    // 创建仅包含回调函数的序列动画\n    timerSequence = DOTween.Sequence();\n\n    // 设置初始时间和计时间隔\n    elapsedTime = 0f;\n    float interval = 1f; // 1秒钟的间隔\n\n    // 添加回调函数到序列动画中，用作定时器\n    timerSequence.AppendCallback(TimerCallback).SetDelay(interval).SetUpdate(UpdateType.TimeScaleIndependent);\n    \n    // 播放序列动画\n    timerSequence.Play();\n&#125;\n\nprivate void TimerCallback()\n&#123;\n    // 在每个间隔触发的回调函数中执行自定义逻辑\n    elapsedTime += 1f;\n    Debug.Log(&amp;quot;Elapsed Time: &amp;quot; + elapsedTime + &amp;quot; seconds&amp;quot;);\n\n    // 可以在此检查条件是否满足，然后执行其他操作\n&#125;\n\n}\n效果是在控制台是输出秒数\n\n注意格式timerSequence.AppendCallback(TimerCallback).SetDelay(interval).SetUpdate(UpdateType.TimeScaleIndependent);\n说明可以这样快捷添加补间等操作\n一般情况下在序列创建完后需要添加以下语句：\n\nmySequence.SetAutoKill(false)——不自动销毁\nmySequence.Pause()——暂停播放等待mySequence.Play()控制播放\n\n\n&nbsp;\n相关设置\n全局设置包括一些安全模式，日志模式等，也可以设置播放模式，这些可以在GUI界面设置，具体函数可以参考文档。\n这里附上一些重要的：\n\nSetAs\n\n\n说明这个之前先了解一下Tween类与TweenParams类\nTween类创造的对象用来储存补间动画，可以通过这个对象来设置对象的属性\nTweenParams类对象用来储存补间动画的属性\nTween myTween = transform.DOMoveX(10, 1);\nTweenParams myParams = new TweenParams();\n//设置myParams后\nmyTween.SetAs(myParams);\n如果补间一开始，则不起作用\n\n\nSetAutoKill(bool autoKillOnCompletion = true)——设置自动销毁\n\n\n\nSetEase（Ease easeType \\ AnimationCurve animCurve \\ EaseFunction customEase)——设置补间曲线，更改比如缓变过程怎样变换等\nSetLoops(int loops,LoopType loopType = LoopType.Restart)——设置循环\n\n\n剩余可以查看文档\n&nbsp;\n&nbsp;\n\n","categories":["Unity基础概念"]},{"title":"UE_Puerts脚本插件","url":"/2025/11/16/Puerts%E8%84%9A%E6%9C%AC%E6%8F%92%E4%BB%B6/","content":"\n\n\n\nUE脚本插件Puerts\n\n\nUE脚本插件Puerts\n好处：\n\n有类型检查，解决Lua无类型的痛\n性能和蓝图差不多\n可以热更\n\n\n概述：一套虚拟机运行时，创建并管理JS/TS的运行时环境（通过例如V8引擎），负责脚本加载编译、GC，完成反射绑定和静态模板绑定功能，有调试支持，也支持热重载。\n&nbsp;\ntypescript\n\nstring\nnumber\nboolean\nnull（适用于联合类型）\nundefined（适用于联合类型）\n数组[]或Array\n元组[]\n\n\n&nbsp;\nPuerts架构\n\n桥接层（V8的各种API，C++的相关类）\n类型映射（通过反射系统实现）\n内存管理（TS对象和引擎对象一对一）\nJS引擎（v8/Node.js/QuickJS）\n\n\nPuerts核心原理大揭秘：TypeScript如何驱动游戏引擎逻辑-CSDN博客\nTS调用C++\n1、Puerts可以使用反射生成.d.ts文件，这个文件包含所有可以通过反射机制获取到的C++函数（包括蓝图），这个文件保证了TS的类型安全检查。如果是非反射的函数或者对象，需要在C++端手动进行静态绑定。\n2、C++的类以及所有成员都可以在TS算随意获取并创建，如果是蓝图类或者其他相关资源，需要提前通过UE.Class.Load()进行加载（等同于C++的LoadObject&lt; UClass&gt;），然后再通过UE的其他API对这个蓝图进行操作，例如利用world.SpawnActor进行对象生成，或者通过blueprint.tojs直接将其转换成js代码供TS操控此资源。\n3、V8的桥接层会处理函数转发，在此之前需要对参数进行转换，例如TS中的对象UE.Vector需要转换成FVector结构体，UObject对象则通过TS的代理对象包装来进行转换，当对象函数被调用时，自动转发到C++层。\n4、如果函数有返回值，则需要再次通过桥接层进行参数转换返回给TS。\n&nbsp;\nC++调用TS\n思路有很多\n主要通过C++委托绑定来进行调用。\n1、C++内声明委托，然后TS端通过反射生成.d.ts文件，按照TS调用C++的思路，TS端可以拿到这个委托了。如果不是UClass下的委托，需要在TS端使用toDelegate。纯C++也可以直接使用std::function将函数当初参数传给TS，也可以访问到。\n2、TS内部进委托绑定。\n3、C++进行委托触发。\n&nbsp;\n内存管理\nV8的内存管理：(99+ 封私信 / 62 条消息) 翻译：V8 引擎的内存管理 - 知乎\nPuerts中TS代理对象含义：\nC++中UObject对象和类似TArray的对象创建后，TS在使用时，会一对一地创建一个TS的对象与之对应，例如上文中的UE.Class.Load()，返回的就是一个TS的代理对象，这种方式就是典型的TS代理对象持有UE对象的引用，这个时候此UE对象的引用计数就会+1，以至于这个对象不会被UEGC掉。当UE的对象被手动摧毁时，会有回调函数通知TS的代理对象也摧毁，这样的方式保证了内存安全，防止崩溃。\n\n","categories":["虚幻引擎系列"]},{"title":"KMP算法","url":"/2023/08/09/KMP%E7%AE%97%E6%B3%95/","content":"\n\n\n\n\nKMP算法\n\nKMP算法\n算法主要分为两部分：KMP、与next算法\nKMP:本质是字符串的循环搜寻，不过在搜寻失败时通过next值来判断需要跳过多少个字符开始搜寻\nint kmp_search(string str,string patt)&#123;\n    int next=build_next(patt);\n    \nint i=0;//主串\nint j=0;//子串\nwhile(i&amp;lt;str.size())&#123;\n    if(str[i]==patt[j])&#123;//单个字符匹配则后移\n        i++;\n        j++;\n    &#125;\n    else if(j&amp;gt;0)&#123;//匹配到一半不匹配了，就根据next后移\n        j=next[j-1];\n    &#125;\n    else&#123;//第一个就匹配失败了就直接移动主串\n        i++;\n    &#125;\n    if(j==patt.size())&#123;//匹配完成\n        return i-j;\n    &#125;\n&#125;\n\n}\nnext：实质是一路遍历过来的前几个字符的相同前后缀的数量\nint bulid_next(string patt)&#123;\n    int next[patt.size()]=&#123;0&#125;;\n    int prefix_len=0;//当前共同前后缀的长度，也可以看做前缀尾指针\n    int i=1;\n    while(i&lt;patt.size())&#123;\n        if(patt[prefix_len]==patt[i])&#123;\n            prefix_len++;\n            next.append(prefix_len);\n            i++;\n        &#125;\n        else&#123;\n            if(prefix_len==0)&#123;\n                next.append(0);\n                i++;\n            &#125;\n            else&#123;\n                prefix_len=next[prefix_len-1];\n            &#125;\n        &#125;\n    &#125;\n    return next;\n&#125;\n\n&nbsp;\n\n","categories":["数据结构与算法"]},{"title":"SlateApplication输入管理与Slate控件运行原理","url":"/2025/11/15/SlateApplication%E8%BE%93%E5%85%A5%E7%AE%A1%E7%90%86%E4%B8%8ESlate%E6%8E%A7%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/","content":"\n\n\n\nSlateApplication输入管理与Slate控件运行原理\n\n\nSlateApplication输入管理与Slate控件运行原理\n在UE4编辑器扩展与slate基础 | Coding中。。。中稍微研究了点Slate的一些基础概念，在UE多线程与windows多线程输入 | Coding中。。。中涉及到了输入相关，也和SlateApplication这个类有一些关系，所以现在来具体看看这几个东西是怎么一回事。\nSlate在官方文档上的描述：\n\n易于访问模型的代码和数据。\n支持程序化 UI 生成。\nUI 描述不易出错。\n支持动画和设计。\n\n\n&nbsp;\nWidget控件结构\nSWidget是所有控件的父类，和一般的控件一样，UWidget持有SWidget的引用，UWidget只处理一些数据相关的内容，而SWidget则去管理一些渲染和点击相关的内容。\n按照结构区分，控件大致可分为三种类型：\n\n叶控件 - 不带子槽的控件。如显示一块文本的 STextBlock。其原生便了解如何绘制文本。\n面板 - 子槽数量为动态的控件。如垂直排列任意数量子项，形成一些布局规则的 SVerticalBox。\n合成控件 - 子槽显式命名、数量固定的控件。如拥有一个名为 Content 的槽（包含按钮中所有控件）的 SButton。\n\n\n如果是SPanel（面板）或者SCompoundWidget（合成控件），那么他们是可以实现父子关系以实现复杂布局的，由Slot来实现。\n举个例子SVerticalBox，Slot在代码里的体现是这样的：\nclass SVerticalBox : public SBoxPanel\n&#123;\n    SLATE_DECLARE_WIDGET_API(SVerticalBox, SBoxPanel, SLATECORE_API)\npublic:\n    class FSlot : public SBoxPanel::TSlot&lt;FSlot&gt;\n    &#123;\n    public:\n        //。。。\n    &#125;\n&#125;\n\n用了一个很罕见的嵌套类的方式来定义FSlot，基类为TSlot，这种方式本质目的为实现一个垂直插槽特有的Slot类型，例如实现一些布局相关的属性方法，设置内边距、水平垂直对齐方式等。\nSlot有一些很经典的使用方式：\n// 使用 SNew 创建 VerticalBox，然后使用 + 操作符添加插槽\nTSharedRef&lt;SVerticalBox&gt; VerticalBox = SNew(SVerticalBox)\n\n&#x2F;&#x2F; 添加第一个槽位，设置自动高度和居中对齐\n\nSVerticalBox::Slot().AutoHeight() &#x2F;&#x2F; 插槽高度由内容决定.HAlign(HAlign_Center) &#x2F;&#x2F; 水平居中对齐[  SNew(SButton) &#x2F;&#x2F; 在这个插槽中放置一个按钮  .Text(FText::FromString(&quot;Button 1&quot;))]这个内容在UE4编辑器扩展与slate基础 | Coding中。。。里面见过一点，其实只是个语法糖，重载了+和[]等一些符号，值得一提的是这种方式添加控件其实就是和在UMG里面操作UI蓝图的底层实现，当UMG中的控件 AddToViewport时，会触发UWidget的RebuildWidget与TakeWidget等逻辑，然后UMG上面的控件树就会转化成Slate的控件树了，也就和代码所示的内容类似，这个地方也蛮重要，等到渲染流程时再研究。\n在SVerticalBox对应的UVerticalBox中，有一些和Slot相关的虚函数：\n\n这个OnSlotAdded，在UPanelWidget的AddChild内被调用，意思就是这样的布局控件添加了新子控件后就会调用这样的函数来添加插槽Slot。\nOnSlotAdded在UPanelWidget里面没有逻辑，而是在UVerticalBox中重写：\n\nBuildSlot的内容：\n\nAddSlot，将slot用FScopedWidgetSlotArguments包了一下，暂时不知道干啥的，总之最后还是添加到了BoxPanel是Slot插槽中：\n\n交互\n前面提到具体的点击和渲染的管理由SWidget负责，而面向用户的数据由UWidget负责。\n几个UWidget的方法：\npublic:\n  virtual void SynchronizeProperties() override;\nprotected:\n  UMG_API virtual TSharedRef&lt;SWidget&gt; RebuildWidget();\n\n举个例子UButton的RebuildWidget：\nTSharedRef&lt;SWidget&gt; UButton::RebuildWidget()\n&#123;\nPRAGMA_DISABLE_DEPRECATION_WARNINGS\n  MyButton = SNew(SButton)\n      .OnClicked(BIND_UOBJECT_DELEGATE(FOnClicked, SlateHandleClicked))\n      .OnPressed(BIND_UOBJECT_DELEGATE(FSimpleDelegate, SlateHandlePressed))\n      .OnReleased(BIND_UOBJECT_DELEGATE(FSimpleDelegate, SlateHandleReleased))\n      .OnHovered_UObject( this, &amp;ThisClass::SlateHandleHovered )\n      .OnUnhovered_UObject( this, &amp;ThisClass::SlateHandleUnhovered )\n      .ButtonStyle(&amp;WidgetStyle)\n      .ClickMethod(ClickMethod)\n      .TouchMethod(TouchMethod)\n      .PressMethod(PressMethod)\n      .IsFocusable(IsFocusable)\n      ;\n\nPRAGMA_ENABLE_DEPRECATION_WARNINGS    if ( GetChildrenCount() &gt; 0 )    &#123;        Cast&lt;UButtonSlot&gt;(GetContentSlot())-&gt;BuildSlot(MyButton.ToSharedRef());    &#125;\nreturn MyButton.ToSharedRef();\n\n}\n每次Rebuild，SWidget都在UWidget里面重建并重新绑定各种事件。RebuildWidget这个函数，只有在Slate初始化和认为需要彻底重建的时候才会触发，这里需要区分两个点：彻底重建与属性同步。\n如果在UMG中只是修改一些控件属性，例如文本颜色，控件大小等，那么就会触发SynchronizeProperties进行属性同步，将控件状态进行标记，然后由每一帧的OnPaint进行重绘。\n只有当涉及到结构性的修改时才会触发RebuildWidget，例如将控件删除替换等。\nvoid UButton::SynchronizeProperties()\n&#123;\n    Super::SynchronizeProperties();\n\nif (!MyButton.IsValid())\n&#123;\n    return;\n&#125;\n\nPRAGMA_DISABLE_DEPRECATION_WARNINGS    MyButton-&gt;SetButtonStyle(&amp;WidgetStyle);    MyButton-&gt;SetColorAndOpacity( ColorAndOpacity );    MyButton-&gt;SetBorderBackgroundColor( BackgroundColor );    MyButton-&gt;SetClickMethod(ClickMethod);    MyButton-&gt;SetTouchMethod(TouchMethod);    MyButton-&gt;SetPressMethod(PressMethod);PRAGMA_ENABLE_DEPRECATION_WARNINGS}\n如果有自定义的控件且有额外的自定义属性，记得重写这个函数，不然在UMG编辑器内每次修改属性都需要重新编译蓝图（触发RebuildWidget）才会触发重绘。\n还有一些别的比如TArrtibute绑定的方法，总之思路就是需要同步属性并进行重绘就行\n\n&nbsp;\nUI点击流程\n在UE多线程与windows多线程输入 | Coding中。。。内聊了Windows系统的点击事件怎么传到UE里的，到了SlateApplication停止了，那么这篇就从这里开始研究，这个地方的代码也是很经典的。\n以鼠标点下事件为例，从文章中，消息已经通过消息循环走到了SlateApplication的OnMouseDown内：\n这里可以看出还在做转换，将WindowsOS的消息包成PointerEvent，内含点击的屏幕坐标等等。\nProcessMouseButtonDownEvent 对应的还有很多\nProcessMouseButtonUpEvent 抬起\nProcessKeyDownEvent 键盘按钮相关\nProcessTouchStartedEvent 模拟动端触屏\n等等等等，就不一一列举了，这些事件的路由都是相似的，涉及到的函数名也是这种什么MouseDown什么KeyDown，也不一一列举了。\n经过一系列判断捕获的代码之后：\nFReply FSlateApplication::RoutePointerDownEvent(const FWidgetPath&amp; WidgetsUnderPointer, const FPointerEvent&amp; PointerEvent)\n&#123;\n    ...\n    //slateUser，包含了一些什么鼠标的位置，捕获的对象等等，举个例子就是多人游戏本地连两个手柄的情况，内涵索引index来区分\n    TSharedRef&lt;FSlateUser&gt; SlateUser = GetOrCreateUser(PointerEvent);\n    SlateUser-&gt;UpdatePointerPosition(PointerEvent);\n    //先回走一遍OnPreviewMouseButtonDown的流程，从根节点往下遍历\n    FReply Reply = FEventRouter::Route&lt;FReply&gt;( this, FEventRouter::FTunnelPolicy( WidgetsUnderPointer ), TransformedPointerEvent, []( const FArrangedWidget TargetWidget, const FPointerEvent&amp; Event )\n    &#123;\n        const FReply TempReply = TargetWidget.Widget-&gt;OnPreviewMouseButtonDown(TargetWidget.Geometry, Event);\n        return TempReply;\n    &#125;, ESlateDebuggingInputEvent::PreviewMouseButtonDown);\n    \nif( !Reply.IsEventHandled() )\n&#123;\n    //然后从叶子节点往上遍历\n    Reply = FEventRouter::Route&amp;lt;FReply&amp;gt;( this, FEventRouter::FBubblePolicy( WidgetsUnderPointer ), TransformedPointerEvent, [this]( const FArrangedWidget TargetWidget, const FPointerEvent&amp;amp; Event )\n    &#123;\n        FReply TempReply = FReply::Unhandled();\n            if( !TempReply.IsEventHandled() )\n        &#123;\n                        //如果是模拟点击\n            if( Event.IsTouchEvent() )\n            &#123;\n                TempReply = TargetWidget.Widget-&amp;gt;OnTouchStarted( TargetWidget.Geometry, Event );\n                //如果是不是模拟点击\n            if( !Event.IsTouchEvent() || ( !TempReply.IsEventHandled() &amp;amp;&amp;amp; this-&amp;gt;bTouchFallbackToMouse ) )\n            &#123;\n                TempReply = TargetWidget.Widget-&amp;gt;OnMouseButtonDown( TargetWidget.Geometry, Event );\n            &#125;\n&#125;\n    return TempReply;\n\n}, ESlateDebuggingInputEvent::MouseButtonDown);\n\nRoute函数算是最精髓的部分了，但这里先不看这个，先看下最后OnMouseButtonDown到哪了，把流程走完。\n直接看Visual的调用栈发现直接走到了SWidget的OnMouseButtonDown里面：\n\nSWidget的OnMouseButtonDown本质是将这个事件传给鼠标事件处理器去了，很明显这是一个虚函数，要通过子类重写，然后来函数体内触发一些事件委托等等，值得一提的是这个函数的返回值FReply是何意味。\n来了解这个之前，先了解几个点击的基本概念。\n捕获（Capture）、焦点（Focus）和控件树\n捕获的概念从控件角度理解可能要好点，意思就是某个控件捕获到了鼠标的输入，然后后续的事件会最优先作用于这个控件，例如鼠标拖动某控件（哪怕鼠标已经移出窗口了，回来也会接着被捕获）。\n焦点是一个状态，通常意义为某某控件被“聚焦”了，被聚焦的控件会直接收到键盘、手柄等的输入。\n这两个概念都被上面提到的FSlateUser控制，里面有一些比如设置Focus、设置Capture等的方法。\n从源代码上看，一次鼠标事件处理，要经过信息转换-&gt;事件本身是否捕获-&gt;哪个控件被聚焦（如果不是捕获）-&gt;具体控件处理事件几个流程，所以可以将“捕获”理解成一次特定的，向特殊控件传输专门信息的方案，但这块接触的应用不多，还不是很能理解。\nbool FSlateApplication::ProcessMouseButtonDownEvent( const TSharedPtr&lt; FGenericWindow &gt;&amp; PlatformWindow, const FPointerEvent&amp; MouseEvent )&#123;\n    ...\n    if (!SlateUser-&gt;IsDragDropping())//还顺便处理的拖动的情况，这里也的理解也不是很深\n    &#123;\n        FReply Reply = FReply::Unhandled();\n        if (SlateUser-&gt;HasCapture(MouseEvent.GetPointerIndex()))//是否被捕获\n        &#123;    \n            Reply = FEventRouter::Route&lt;FReply&gt;(...);\n            ...\n        &#125;\n        else&#123;\n            ...\n            Reply = RoutePointerDownEvent(WidgetsUnderCursor, MouseEvent);//不是就检查聚焦\n            ...\n        &#125;\n&#125;\n\n控件树在上面的SWidget结构中已经提到过了，这里指的最终形成的在UMG控件反射器上表现的UI树形结构。\nUI控件树的单位：FArrangedWidget，内含一个SWidget，这个单位也作为Route函数中lambda表达式的参数类型之一\n\nRoute\nRoute直译过来就是路线，结合源代码中的作用，理解成“利用UI控件树的结构路径，通过某种算法，找到这个事件应该由哪个控件接手”。\n\ttemplate&lt; typename ReplyType, typename RoutingPolicyType, typename EventType, typename FuncType &gt;\n    static ReplyType Route( FSlateApplication* ThisApplication, RoutingPolicyType RoutingPolicy, EventType EventCopy, const FuncType&amp; Lambda, ESlateDebuggingInputEvent DebuggingInputEvent)\n    &#123;\n        ReplyType Reply = ReplyType::Unhandled();\n        const FWidgetPath&amp; RoutingPath = RoutingPolicy.GetRoutingPath();\n        const FWidgetPath* WidgetsUnderCursor = RoutingPolicy.GetWidgetsUnderCursor();\n        \n#if WITH_SLATE_DEBUGGING        FSlateDebugging::FScopeRouteInputEvent Scope(DebuggingInputEvent, RoutingPolicyType::Name);#endif\n    EventCopy.SetEventPath( RoutingPath );\n\n    for (; !Reply.IsEventHandled() &amp;amp;&amp;amp; RoutingPolicy.ShouldKeepGoing(); RoutingPolicy.Next())\n    &#123;\n        const FWidgetAndPointer&amp;amp; ArrangedWidget = RoutingPolicy.GetWidget();\n\n        if constexpr (Translate&amp;lt;EventType&amp;gt;::TranslationNeeded())\n        &#123;\n            const EventType TranslatedEvent = Translate&amp;lt;EventType&amp;gt;::PointerEvent(ArrangedWidget, EventCopy);\n            Reply = Lambda(ArrangedWidget, TranslatedEvent).SetHandler(ArrangedWidget.Widget);\n            ProcessReply(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;amp;TranslatedEvent);\n        &#125;\n        else\n        &#123;\n            Reply = Lambda(ArrangedWidget, EventCopy).SetHandler(ArrangedWidget.Widget);\n            ProcessReply(ThisApplication, RoutingPath, Reply, WidgetsUnderCursor, &amp;amp;EventCopy);\n        &#125;\n    &#125;\n\n    return Reply;\n&#125;\n\n\n其实我也不是很想直接贴源码，太难看了，但是还是嫌麻烦，所以不想看的话就直接看我总结：\n\nRoute通过某种策略RoutingPolicy来获取一系列要处理的ArrangedWidget（前面提到的控件树结点）\n所谓的处理也就是调用传入Route的Lambda函数，看前面的代码可以知道这个Lambda函数其实就是在调用具体控件里的类似OnMouseButtonDown方法，这些方法还会返回FReply回复\n这里的RoutingPolicy涉及到Next()等方法，感兴趣的可以进去看看并学习下算法\n核心是一个for循环，意思就是遍历通过这些“策略”获取到的SWidget，调用他们的OnMouseButtonDown（或者其他事件）方法，然后这些方法还会返回Reply，如果Reply是Handled了，或者策略不是ShouldKeepGoing了，就停止循环。\n那么SWidget的遍历顺序就很重要了，因为如果遍历的过程中被某个Widget返回了Handled，那么循环就停止了，相当于事件被“截胡”了\n\n\n所谓的Handled、Unhandled，没有具体的定义必须什么时候要返回被处理，其实理解成设计思想就行，Handled也就意味着这次点击起到了实质性作用了就返回处理，反之则不处理，体现在源码中举个例子就是Button控件的事件通常会返回Handled，而像是VerticalBox这种布局控件通常就会返回Unhandled，当然这些都是可以自行定制的，没有绝对的限制。\n那么具体有哪些策略呢？直接偷一张别人的图\n\n\nFDirectPolicy只查找根节点，用于拖拽\nFToLeafmostPolicy只查找最后的叶子节点，用于Capture\nFTunnelPolicy从根节点往下遍历，用于PreviewMouseButton\nFBubblePolicy从叶子节点往上遍历，用于上面提到的以外的情况\n\n\n&nbsp;\n特殊：鼠标事件的双层路由机制\n对于MouseButtonDown，也就是上文提到过的源代码的内容，会发现它的处理方式是先从父节点遍历到子节点，触发OnPreviewMouseButtonDown，然后再从叶子节点往上遍历（如果没被Handled），触发OnMouseButtonDown。\n这里的设计叫做“双层路由机制”，一是在父节点上预留一个接口，用于处理比如“点击统计”或者阻断式的“弹窗”等，从上往下遍历；二是为了保证点击事件能更直观，比如按钮下层有另一个按钮，那么肯定是直接触发这个子按钮，所以要从下往上遍历\n&nbsp;\nHitTestGrid\n时间紧任务重，不想具体研究这个了，以后再说吧，实在不行参考别人写的：【UE·底层篇】Slate源码分析——点击事件的触发流程梳理_ue slate-CSDN博客\n&nbsp;\nUI渲染流程\n大致可分为以下几个流程：\n\n触发渲染指令（在tick中）——标志函数：FSlateApplication::DrawWindows()\n测量布局，控件树执行中序遍历，自下而上询问每一个控件的DesiredSize——标志函数：FSlateApplication::DrawPrepass()\n排列绘制，自上而下计算控件要显示的真正大小——标志函数：FSlateApplication::DrawWindowAndChildren()\n生成绘制指令与渲染批次，然后在渲染线程中进行合批，最后传入RHI线程内执行GPU绘制\n\n\n准备（GameThread）\nDesiredSize顾名思义就是“期待大小”，由每个控件本身决定，每个控件都实现ComputeDesiredSize()——SWidget内，比如图片可以设置为图片原大小，也可以设置字体为原大小等。对于不含子项的控件，按照自己的属性和缓存去决定DesiredSize，对于含子项的控件需要依据子项大小和本身的计算逻辑去算自己的DesiredSize。\n在绘制过程中，因为已经知道了子控件的DesiredSize，所以自顶向下排列（排列的函数ArrangeChildren()也需要SWidget中的每个控件去实现）并绘制，比如某父项在OnPaint时，会优先给子项预留他的DesiredSize的空间，然后递归调用子项的OnPaint来绘制。\n&nbsp;\n开始（RenderThread）\n每个OnPaint最终都会将要绘制的图元信息传入一个Slate的绘制元素列表中，这个列表每一帧都会更新，渲染线程会不断消耗这个列表。\n渲染线程，在UE中封装了一个类来处理Slate的渲染，那就是FSlateRenderer，这个类会根据图形API的不同被派生成不同的类，例如FSlateRHIRenderer、FSlateOpenGLRenderer等等。\t\nint32 SImage::OnPaint( const FPaintArgs&amp; Args, const FGeometry&amp; AllottedGeometry, const FSlateRect&amp; MyCullingRect, FSlateWindowElementList&amp; OutDrawElements, int32 LayerId, const FWidgetStyle&amp; InWidgetStyle, bool bParentEnabled ) const &#123;\n    ....\n    FSlateDrawElement::MakeBox(OutDrawElements, LayerId, AllottedGeometry.ToPaintGeometry(), ImageBrush, DrawEffects, FinalColorAndOpacity);\n    .....\n    return LayerId;\n&#125;\n\n由上面的代码中可见，生成了一个FSlateDrawElement，这个元素会被进一步包装成FSlateRenderBatch，然后再传给渲染线程进行合批操作。\n合批\nOnPaint自己返回了一个LayerId。\nSWindow::Paint返回的LayerId为0，依据传递链通过OnPaint依次将这个参数传递给控件并返回新值，大部分控件不会改变这个值，有子项的可能会改变，（部分）规矩为：\n\nSCompoundWidget 包含一个子控件，它会使子控件的LayerId + 1\nSPanel包含多个子控件，不改变LayerId，所有子控件都继承父控件的LayerId\n\n\n\n渲染线程中的FSlateRenderBatch会根据LayerId从小到大排序，LayerId相同的可以合批，还有一些其他规则，具体参考：(99+ 封私信 / 54 条消息) 南山搬砖道人 - 知乎\n总结的一些针对合批的优化：\n\n尽量保证UI材质相同（图集）\n利用Invalidation Box——可以缓存子控件的布局和绘制，只有变化时才会重新PrePass和OnPaint，针对静态页可以有优化(99+ 封私信 / 58 条消息) UE4 InvalidationBox优化 - 知乎\n简化控件树，复杂的控件树可能导致LayerId管理混乱\n利用Retainer Box(99+ 封私信 / 58 条消息) UE4 RetainerBox优化 - 知乎\n\n\n\n合批完成后，生成RHICommand提交给RHIThread完成真正的Slate渲染。\n\n","categories":["虚幻引擎系列"]},{"title":"UE4编辑器扩展与slate基础","url":"/2024/11/15/UE4%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%A9%E5%B1%95%E4%B8%8Eslate%E5%9F%BA%E7%A1%80/","content":"\n\n\n\n\n\n\nUE4编辑器扩展\n模块认识\n虚幻文档模块\n模块是是虚幻引擎软件层面上的基本架构块，对引擎功能进行了独立封装。只有经过更改的模块会重新编译一次。可以运行时控制何时加载卸载哪些模块，也可以通过条件编译来卸载加载模块（如不同平台）。\n模块构成\n\nUE包含Engine类文件和项目类文件，Engine类文件包含引擎相关模块，不和实际项目存放在一起，但会被项目引用，在打包时链接上。实际项目中的模块放在Source文件夹下，引擎模块大致包括如下：\n\nCore: 提供基本的运行时功能。\nCoreUObject: 包含UObject系统。\nEngine: 提供游戏引擎的核心功能。\nRenderer: 负责图形渲染。\nPhysics: 处理物理模拟。\nAnimation: 管理动画系统。\nAI: 提供人工智能功能。\nNetworking: 处理网络通信。\nUI: 管理用户界面。\n\n\n\nSource文件夹子文件目录，这些名字就代表一个个模块名字，当然，也可以将模块放在子文件夹中，如果要自定义模块，那么就要按着这个结构来：\n[](https://imgse.com/i/pAJCpnS\nbuild文件定义模块的构建配置，包括依赖的其他模块和库（例如引用了引擎库中哪些模块）。\nTarget文件定义了模块的构建目标，比如构建平台、构建类型、依赖关系等。\n\nUBT负责虚幻编译，也就负责操控模块的依赖关系，他在查找模块的依赖关系时会直接查看Build文件，也就是说模块必须拥有Build文件才能被UBT发现。如此以来，该自定义模块中的代码就可以使用被依赖模块中的代码了，生成IDE文件时，也会包含这些代码。\n\n\n\nusing UnrealBuildTool;\n\npublic class ModuleTest: ModuleRules&#123;    public ModuleTest(ReadOnlyTargetRules Target) : base(Target)    &#123;        PrivateDependencyModuleNames.AddRange(new string[] &#123;&quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;&#125;);    &#125;&#125;\n\n此外，还需要在Private文件夹中建立一个叫[ModuleName]Module的cpp文件，这个文件不需要创建.h文件，在这个类中写入IMPLEMENT_MODULE(FDefaultModuleImpl,ModuleTest)宏，并在这个文件中新建扩展IModuleInterface的类，为模块提供默认实现，不过也可以手动编写模块类、构造函数等。\n\n\nIModuleInterface重要函数：StartupModule、ShutdownModule函数。\n\n\n在项目的.uproject文件中进行模块注册，可以控制模块在哪个加载阶段中加载：\n\n\n&quot;Modules&quot;: [\n         &#123;\n             &quot;Name&quot;: &quot;MyProject&quot;,\n\n         &amp;quot;Type&amp;quot;: &amp;quot;Runtime&amp;quot;,\n\n         &amp;quot;LoadingPhase&amp;quot;: &amp;quot;Default&amp;quot;\n     &#125;,\n\n     &#123;\n         &amp;quot;Name&amp;quot;: &amp;quot;ModuleTest&amp;quot;,\n\n         &amp;quot;Type&amp;quot;: &amp;quot;Runtime&amp;quot;\n     &#125;\n ]\n\n\n.uproject文件中的注册与build文件中模块引用：\n前者影响整个项目构建运行环境，侧重于控制模块的编译顺序，后者影响当前模块构建的过程（确保编译当前模块时所依赖的模块已经构建完毕）\n也可以理解为，前者是将自定义模块加入到“主模块”的引用当中，使之能在项目启动时被识别。\n此外，主模块的Build文件夹也需要注册新加入的自定义的模块。\n\n\n如果按照这样的方式新建了模块，那么就可以在虚幻的“新建C++类”中找到这个模块了：\n\n创建类后，.h文件自动添加到public文件夹中，.cpp文件自动添加到private文件夹中，当然也可以手动新建类，手动添加publicprivate。\n\n封装规则：\n\n如果头文件放在private中，那么内容会在该模块内公开，但不可用在其他模块中\npublic内属于公开文件夹，所有（引用的）模块均可使用\n如果既不放在private，也不放在public，则默认private，这种一般属于“游戏主模块”会干的事\nprivate和public中的文件需要同名对应\n在虚幻引擎中新建类，这些工作都会自动完成\n\n\n\n虚幻文档中的推荐时将模块区分为“运行时”与“编辑器”之分，例如：\n\n编辑器版本支持运行时与编辑器版本编译，运行时版本支持运行时版本编译，因为运行时不需要编辑器版本的代码。\n具体步奏可以参考\n\n\n\n细节面板扩展\n可以直接通过虚幻反射系统的UProperty宏信息来直接设置如何显示属性，也可以通过自定义细节面板来实现更详细的方式。这里分为两个大类。\n宏信息\n先参考这个\n自定义细节面板\nIPropertyTypeCustomization支持Struct\nIDetailCustomization支持UClass\n引用\n如果要自定义一个UClass或者Struct在细节面板中的展示，那么需要做到以下几点：\n\n重新定义一个类，在这个类中写表现逻辑\n\n类继承接口IPropertyTypeCustomization或者IDetailCustomization\n类中定义静态方法static TSharedRef&lt;IDetailCustomization&gt; MakeInstance() \n类中重新实现虚方法virtual void CustomizeDetails(IDetailLayoutBuilder&amp; DetailBuilder) override;，如果是UStruct则是\n\n\n  virtual void CustomizeHeader(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle,\n    FDetailWidgetRow&amp; HeaderRow, IPropertyTypeCustomizationUtils&amp; CustomizationUtils)\n    override;\nvirtual void CustomizeChildren(TSharedRef&lt;IPropertyHandle&gt; PropertyHandle,\n    IDetailChildrenBuilder&amp; ChildBuilder, IPropertyTypeCustomizationUtils&amp;\n    CustomizationUtils) override;\n\n\n在自定义结构所在的模块向PropertyEditor进行注册\nvoid StartupModule()&#123;\n    FPropertyEditorModule&amp; PropertyModule = FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(&quot;PropertyEditor&quot;);\n    PropertyModule.RegisterCustomPropertyTypeLayout(&quot;%targerStruct%&quot;),FOnGetPropertyTypeCustomizationInstance::CreateStatic(&amp;TargetCustomization::MakeInstance);\n    //MakeInstance的目的就是让PropertyEditor可以在这个地方构造自定义对象单例\n&#125;\n\nvoid ShutupModule()&#123;    FPropertyEditorModule&amp; PropertyModule &#x3D; FModuleManager::LoadModuleChecked&lt;FPropertyEditorModule&gt;(&quot;PropertyEditor&quot;);    if(PropertyModule)&#123;        PropertyModule-&gt;UnregisterCustomPropertyTypeLayout(&quot;%targerStruct%&quot;);    &#125;&#125;&#x2F;&#x2F;这里的%targerStruct%必须是去掉A或者F的字符串（%号无意义去除），UE是通过反射获取对应的Class的\n\n在这个模块的Build.cs中添加依赖\n\n\n\nPrivateDependencyModuleNames.AddRange(new string[]&#123;\n    ...\n    &quot;PropertyEditor&quot;,\n    ...\n&#125;)\n\n自定义的表现逻辑类和目标结构在模块初进行注册绑定后，Editor就不会为这个目标结构生成默认的细节面板了，此时直接在UE中打开他的细节面板会直接显示空。\n转而调用对应的CustomizeDetails（或者CustomizeHeader和CustomizeChildren），此时需要在这些重新实现的方法中编写属性的表现逻辑。\n细节面板重新自定义代表这个细节面板的所有相关逻辑都会消失，除了最基础的输入框和名称展示，右键的复制粘贴操作也会消失，甚至“确认输入后刷新面板”也需要重新编写事件\n\n以IPropertyTypeCustomization举例：\nTSharedRef&lt;IPropertyHandle&gt; redirectHandle = PropertyHandle-&gt;GetChildHandle(GET_MEMBER_NAME_CHECKED(F%targerStruct%, targetProperty)).ToSharedRef();//获取对应的属性句柄\nChildBuilder.AddProperty(redirectHandle);\n\n这样子编写，对应属性就会原封不动按照默认的表现展示出来，对于一些其实不需要自定义修改但是又不想重新编写逻辑的属性很适用。\n如果要自定义编写，则最基础的方法是\nChildBuilder.AddCustomRow(NSLOCTEXT(FText::FromString(TEXT(&quot;ChildRow&quot;)))\n    .NameContent()\n    [\n        ...\n    ]\n    .ValueContent()\n    [\n        ...\n    ]\n);\n\n用来向细节面板中添加一行，Name就是左边的内容，Value就是右边的内容，而方框内就是Slate的写法了。\nSlate最佳实践\n在知乎上找到一张图醍醐灌顶\n\n也就是说这种链式编程的写法是和UMG表现上是一致的。\n这里也不做过多展开了，直接归纳一些常见常用的基础写法。\n可以使用SNew或者SAssignNew构建Slate实例（实质是SWidget实例），然后将这个实例可以直接放在中括号中，如上图所示，这样就可以直接展示SWidget中的对应控件逻辑了。\n除了使用AddProperty，如果想在属性内进行特殊个性化也是能实现的。\nhandleTemp-&gt;CreatePropertyValueWidget(false)\nhandleTemp-&gt;CreatePropertyNameWidget()\nhandleTemp-&gt;CreateDefaultPropertyButtonWidgets()\n\nIPropertyHandle的方法CreatePropertyValueWidget，直接返回默认的属性SWidget，将他放置在中括号中给予插槽，就能以默认的形式展现属性的值或者名字，可以用这种方法直接还原属性值的表现或者名字的表现。Value后的bool参数表示是否添加默认的属性按钮，和第三个方法一样。\n默认的属性按钮：\n\n布局控件：\n\nSOverlay——叠加布局，不是很常用\nSHorizontaiBox、SVerticalBox——添加子控件布局，挺常用的\n\n\nSNew(SHorizontalBox)\n+ SHorizontalBox::Slot()\n[\n    SNew(STextBlock)\n    .Text(FText::FromString(&quot;Left&quot;))\n]\n+ SHorizontalBox::Slot()\n[\n    SNew(STextBlock)\n    .Text(FText::FromString(&quot;Center&quot;))\n]\n+ SHorizontalBox::Slot()\n[\n    SNew(STextBlock)\n    .Text(FText::FromString(&quot;Right&quot;))\n]\n\nSlot就是插槽，将目标属性“插入”槽中的意思\n可以直接在Slot()方法后接.方法控制布局\nSNew(SHorizontalBox)\n+ SHorizontalBox::Slot()\n.AutoWidth()//如果是SVerticalBox，则为AutoHeight\n[\n    SNew(STextBlock)\n    .Text(FText::FromString(&quot;Auto Width&quot;))\n]\n\n\nSScrollBox——滚动区域\n\n\n属性控件：\n\nSButton——按钮\nSTextBlock——文本块\nSSearchBox——搜索框\nComboBox——下拉菜单\n\n\n更多内容看这里\n细节讲一下ComboBox\nSNew(SComboBox&lt;TSharedPtr&lt;FItemData&gt;&gt;)\n.OptionsSource(&amp;ItemDataArray) //这个集合必须是全局变量，不知道为什么\n.OnSelectionChanged_Lambda([handleTemp](TSharedPtr&lt;FItemData&gt; NewData,ESelectInfo::Type SelectInfo)\n&#123;\n    handleTemp-&gt;SetValue(NewData-&gt;Value);\n&#125;)\n.OnGenerateWidget_Lambda([](TSharedPtr&lt;FItemData&gt; Item)-&gt;TSharedRef&lt;SWidget&gt;\n&#123;\n    return SNew(STextBlock).Text(FText::FromString(FString::FromInt(Item-&gt;Value).Append(&quot; | &quot;).Append(Item-&gt;ItemID)));\n&#125;)\n.Content()\n[\n    handleTemp-&gt;CreatePropertyValueWidget(false)\n]\n\n\nOptionsSourced的值必须是TSharedPtr的集合地址，也就是说ItemDataArray必须是TArray&lt; TSharedPtr&lt; Type&gt;&gt;类。\n很意外的发现这个TArray还必须是全局变量，不然细节面板不会获取到具体值，可能和细节面板生命周期有关系。\n\nOnSelectionChanged_Lambda表示选定值变化之后的操作，也有一个OnSelectionChanged的非Lambda表达式的差分版本，注意“将选中值设定要目标值”的逻辑需要在这里重新编写。\nOnGenerateWidget_Lambda规定了每一列的具体展示内容，也有一个OnGenerateWidget的非Lambda表达式的差分版本，返回SWidget，所以理论上也可以在这里自定义其他内容。\nContent中填写默认展示框的SWidget。\n\n","categories":["虚幻引擎系列"]},{"title":"Unity Shader君の初上手","url":"/2023/11/02/Shader%E5%90%9B%E3%81%AE%E5%88%9D%E4%B8%8A%E6%89%8B/","content":"\n\n\n\n\nShader\n\nUnity——Shader入门\n\n新建Shader并使用VS+ShaderLabVS进行编译，默认的Shader代码是这样的：\nShader &quot;Unlit/MyShader&quot;\n&#123;\n    Properties\n    &#123;\n        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;\n    &#125;\n    SubShader\n    &#123;\n        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;\n        LOD 100\n\n    Pass\n    &#123;\n        CGPROGRAM\n        #pragma vertex vert\n        #pragma fragment frag\n        // make fog work\n        #pragma multi_compile_fog\n\n        #include &amp;quot;UnityCG.cginc&amp;quot;\n\n        struct appdata\n        &#123;\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n        &#125;;\n\n        struct v2f\n        &#123;\n            float2 uv : TEXCOORD0;\n            UNITY_FOG_COORDS(1)\n            float4 vertex : SV_POSITION;\n        &#125;;\n\n        sampler2D _MainTex;\n        float4 _MainTex_ST;\n\n        v2f vert (appdata v)\n        &#123;\n            v2f o;\n            o.vertex = UnityObjectToClipPos(v.vertex);\n            o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n            UNITY_TRANSFER_FOG(o,o.vertex);\n            return o;\n        &#125;\n\n        fixed4 frag (v2f i) : SV_Target\n        &#123;\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv);\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n            return col;\n        &#125;\n        ENDCG\n    &#125;\n&#125;\n\n}\n\nShader &quot;Unlit/MyShader&quot;\n\n可以设置新建Shader的路径\n&nbsp;\n属性\nProperties\n&#123;\n    _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;\n&#125;\n\n用来向监视器里面展示可控数据的代码段\n属性名(&quot;在材质球(*Material*)上展示的名称&quot;,属性类型) = 默认值\n\n&nbsp;\n子着色器（SubShader）\nSubShader用于将 Shader 对象分成多个部分，分别兼容不同的硬件、渲染管线和运行时(Runtime)设置\n\n有点像条件编译，就是Unity会自动遍历所有的SubShader直到找到第一个能用到的着色器，如果找不到，\n一个子着色器包含以下内容：\n\n与其他设备设置兼容信息\nTags——提供有关SubShader相关信息的键值对\nPass——通道\n\n\n&nbsp;\n通道\nShader的基本元素，一个Shader至少包含一个通道\n\n        Pass\n        &#123;\n            CGPROGRAM\n            #pragma vertex vert\n            #pragma fragment frag\n            // make fog work\n            #pragma multi_compile_fog\n        #include &quot;UnityCG.cginc&quot;\n**********************************************************\n        struct appdata\n        &#123;\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n        &#125;;\n**********************************************************\n**********************************************************\n        struct v2f\n        &#123;\n            float2 uv : TEXCOORD0;\n            UNITY_FOG_COORDS(1)\n            float4 vertex : SV_POSITION;\n        &#125;;\n**********************************************************\n        sampler2D _MainTex;\n        float4 _MainTex_ST;\n**********************************************************\n        v2f vert (appdata v)\n        &#123;\n            v2f o;\n            o.vertex = UnityObjectToClipPos(v.vertex);\n            o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n            UNITY_TRANSFER_FOG(o,o.vertex);\n            return o;\n        &#125;\n**********************************************************\n**********************************************************\n        fixed4 frag (v2f i) : SV_Target\n        &#123;\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv);\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n            return col;\n        &#125;\n**********************************************************\n        ENDCG\n    &#125;\n\n\nappdata指CPU向Shader提供的模型数据\nv2f是自定义的数据结构体，是顶点着色器输出的数据也是片元着色器输入的数据\nvert是顶点着色器处理函数\nfrag是片元着色器处理函数\n\n\nShader的处理流程和渲染管线是相像的\n\n语义解释：\n\nCPU-&gt;顶点着色器\n\n&nbsp;\n\n顶点着色器-&gt;片元着色器\n\n&nbsp;\n\n片元着色器-&gt;外界\n\n&nbsp;\n实验：手动建立标准光照Shader\n&nbsp;\n建立默认Shader与默认材质，挂载到物体上就是一个普通的白球（默认无光照）\n\n尝试利用Blinn-Phong光照模型为其增加检测光照的效果（图中已经添加环境光与直线光）\n也就是将这个unity默认的无光照着色器手动编译成标准着色器\n\n从之前学到的知识，Blinn-Phong模型的最终结果就是环境光+漫反射+高光\n环境光在unity中设置\n漫反射与高光是由片元着色器处理，于是我们聚焦到frag上\n可以看到frag的实现非常简单，从_MainTex中获取颜色，利用i.uv提供的坐标，再将颜色坐标信息返回给col。（那个什么FOG是利用untiy的api启用雾效）\n\tfixed4 frag (v2f i) : SV_Target\n        &#123;\n            // sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv);\n            // apply fog\n            UNITY_APPLY_FOG(i.fogCoord, col);\n            return col;\n        &#125;\n\n要加上环境光+漫反射+高光，也就是最终返回的结果最好是“final=col×(_Diffuse×diffuse+pow(specular,__Intensity)+ambient)&quot;\n其中diffuse为漫反射，specular为高光，ambient为环境光——为了区分把公式特征也写进去了，实际编写过程取决于编写者。\n&nbsp;\n漫反射：\nfixed3 worldNormal = normalize(i.normal);\nfixed3 worldPos = i.worldPos;\nfixed3 lightDir = normalize(_WorldSpaceLightPos0 - worldPos);\nfloat diffuse = max(0, dot(worldNormal, lightDir));\n\n&nbsp;\n高光：\nfixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));\nfixed3 lightDir = normalize(_WorldSpaceLightPos0 - worldPos);\nfixed3 halfDir = normalize(lightDir + viewDir);\nfloat specular = max(0, dot(worldNormal, halfDir));\nspecular = pow(specular, _Intensity);\n\n&nbsp;\n将这两个值的最终结果结合一下返回给finalColor：\n\n有了能接受光照的雏形，漫反射也能通过光照方向改变而改变光亮和高光方向，但是模拟光照的技术瓶颈还是取决于硬件支持，也就是说漫反射只能反反射单一光线，而不能反射其他物体反射出的光线，所以看起来并不真实。\n一般这种”二手光“直接用统一的环境光来代替\nfixed4 ambient = (UNITY_LIGHTMODEL_AMBIENT.xyz,1);\n\n&nbsp;\n但是加上环境光却出现了问题：\n\n物体光线又回到了最初的起点，就好像环境光将光线都扰乱了一样。\n&nbsp;\n最后尝试了很多种方式，发现竟然只是代码的语法错误\n\nfloat3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;\nfixed4 finalColor = col * (_Diffuse * diffuse + specular ) + fixed4(ambient, 1);\n\n如上，直接通过在fixed3后面加上标量1的方式是错误的，必须新建以fixed4(ambient,1)的格式新建fixed类型的向量——最终还是因为我没有正式安装CG代码的编译环境，所以并没有报错。。。\n&nbsp;\n但是新的问题又出现了，那就是这个环境光只相应纯色类型的环境光，而不能相应天空盒类型环境光。\n在自定义着色器中获取环境颜色 - Unity Forum\n在Unity社区中寻找到有人在讨论这个问题，最终把代码改成\nhalf3 ambient = half3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\nfixed4 finalColor = col * (_Diffuse * diffuse + specular ) + fixed4(ambient, 1);\n\n最终形成天空盒也能充当环境光的效果。\n&nbsp;\n优化：\n最终很遗憾地发现最终效果仍然很奇怪，因为最后才发现所使用的unity的光照是太阳光而不是点光源（太阳光默认直线平行，而点光源有距离缩减且角度都不同）\n所以更改代码逻辑如下：\nShader &quot;Unlit/NewUnlitShader&quot;\n&#123;\n    Properties\n    &#123;\n        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;\n        _Diffuse(&quot;Diffuse&quot;,Range(0,1)) = 1\n        _Intensity(&quot;Intensity&quot;,float) = 1\n\n    _IntensityHigh(&amp;quot;IntensityHigh&amp;quot;,float) = 1\n    _Specluar(&amp;quot;Specular&amp;quot;,Color) = (1,1,1,1) \n&#125;\nSubShader\n&#123;\n    Tags &#123; &amp;quot;RenderType&amp;quot;=&amp;quot;Opaque&amp;quot; &#125;\n    Tags &#123;&amp;quot;LightMode&amp;quot; = &amp;quot;ForwardBase&amp;quot;&#125;\n    LOD 100\n\n    Pass\n    &#123;\n        CGPROGRAM\n        #pragma vertex vert\n        #pragma fragment frag\n        // make fog work\n        #pragma multi_compile_fog\n        #include &amp;quot;Lighting.cginc&amp;quot;\n        #include &amp;quot;UnityCG.cginc&amp;quot;\n\n        struct appdata\n        &#123;\n            float4 vertex : POSITION;\n            float2 uv : TEXCOORD0;\n            float3 normal : NORMAL;\n        &#125;;\n\n        struct v2f\n        &#123;\n            float2 uv : TEXCOORD0;\n            UNITY_FOG_COORDS(1)\n            float4 vertex : SV_POSITION;\n            float3 worldPos : TEXCOORD1; \n            float3 normal : TEXCOORD2;\n        &#125;;\n\n\n        sampler2D _MainTex;\n        float4 _MainTex_ST;\n        v2f vert(appdata v)\n        &#123;\n            v2f o;\n            o.vertex = UnityObjectToClipPos(v.vertex);\n            o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n            UNITY_TRANSFER_FOG(o, o.vertex);\n\n            o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;\n            o.normal = UnityObjectToWorldNormal(v.normal);\n\n            return o;\n        &#125;\n        float _Intensity;\n        float _IntensityHigh;\n        float _Diffuse;\n        fixed4 frag(v2f i) : SV_Target\n        &#123;\n            // Sample the texture\n            fixed4 col = tex2D(_MainTex, i.uv);\n\n            // Calculate the lighting\n            fixed3 worldNormal = normalize(i.normal);\n            fixed3 worldPos = i.worldPos;\n            fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));\n\n            fixed3 lightDir = normalize(_WorldSpaceLightPos0.xyz);\n            fixed3 halfDir = normalize(lightDir + viewDir);\n            fixed4 lightColor = _LightColor0;\n\n            float diffuse = _Intensity*max(0, dot(worldNormal, lightDir));\n            float specular = max(0, dot(worldNormal, halfDir));\n            specular = pow(specular, _IntensityHigh);\n\n            half3 ambient = half3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);\n            fixed4 finalColor = col * _Diffuse *( diffuse +specular ) + fixed4(ambient, 1);\n\n            // Apply fog\n            UNITY_APPLY_FOG(i.fogCoord, finalColor);\n\n            return finalColor;\n        &#125;\n        ENDCG\n    &#125;\n&#125;\n\n}\n高光反射的p值比我想象中的大很多，突然想起闫令祺老师说过一般要达到128才能接近现实的效果。。\n\n\n\n与官方的标准光照着色器对比——你可以猜一下哪个是我写的\n&nbsp;\n后记：\n从别人的博客上看见使用半兰伯特(Half Lambert)模型来优化漫反射。\n就是单纯变更一下diffuse：\nfloat diffuse = 0.5*_Intensity*max(0, dot(worldNormal, lightDir))+0.5;\n这样可以去掉环境光也能形成很好的效果：\n\n但是我其实觉得这是一种投机取巧的做法——虽然看起来确实像摸像样了一点，但不能跟踪天空盒，而且和其他反射严重割裂。\n\n","categories":["Unity基础概念"]},{"title":"UEGC详解","url":"/2025/01/05/UEGC%E8%AF%A6%E8%A7%A3/","content":"\n\n\n\nUE标记清除GC算法特点\n\n\nＵＥＧＣ分析\nUE标记清除GC算法特点\nUE4采用“追踪式、精确式、非搬迁式、非实时、非渐进式”的标记清扫（Mark-Sweep）GC算法。该算法分为两个阶段：标记阶段（GC Mark）和清扫阶段（GC Sweep）\n\n\n跟踪式：达到GC条件时，通过扫描系统中是否有对象引用的方式来判断是否回收\n\n引用计数：额外分配空间用于存储引用计数，引用为0时回收对象本身\n\n\n\n精确式：需要额外的数据来判断，以识别每个对象的引用（比如标识符UPROPERTY）\n\n保守式：不需要额外的数据来支持对象的判断\n\n\n\n非搬迁式：不需要移动GC对象的内存位置\n\n搬迁式：例如标记复制法，将成功标记的对象复制到另一个堆中，剩下的对象就可以被GC了\n\n\n\n非实时：需要停止用户程序的执行\n\n实时：不需要停止用户执行\n\n\n\n非渐进式：对象被GC后立即回收占用的内存资源\n\n渐进式：在GC达成一定条件的时候进行回收操作\n\n\n\n\n\n&nbsp;\n被UPROPERTY宏修饰，或者在AddReferencedObjects手动添加引用的UObject*成员变量，才能被GC识别。\n首先说一下UE中GC的大致流程：\n\n启动GC时加锁，防止GC时引用关系发生变化\n将所有对象设置为“不可达”（特殊对象、根对象除外）\n从根对象开始遍历，引用到的对象去除“不可达”标记\n将所有“不可达”删除\n\n\n&nbsp;\n基础操作\n使用：在大多数情况下，继承自UObject类的变量，前面加一个UPROPERTY宏，那么这个变量自然就被纳入UE的垃圾回收系统之中了。\n如果变量继承自非UObject类的对象变量，那么这个这个承载这个变量需要继承自FGCObject类，并且该类需要重写实现FGCObject提供的AddReferencedObjects接口，在接口中调用AddReferencedObject方法手动添加该对象至Collector实现。\n也就是非UObject引用了UObject类对象\n\n//.h\nclass FTestClass : public FGCObject\n&#123;\npublic:\n\nFTestClass();\n\nclass UTestObject* MyObject;\n\nvirtual void AddReferencedObjects(FReferenceCollector&amp;amp; Collector) override;\n\n};\n&#x2F;&#x2F;.cppFTestClass::FTestClass(){    MyObject &#x3D; NewObject&lt;UTestObject&gt;(GetTransientPackage(), TEXT(&quot;TestGCPlgTestObject&quot;));}\nvoid FTestClass::AddReferencedObjects(FReferenceCollector&amp; Collector){    Collector.AddReferencedObject(MyObject);}\n至于其他类型的对象，则使用智能指针或者其他方法进行GC管理\nQ：如果一个对象在拥有UPROPERTY标记的同时又被AddReferenceObjects手动添加进GC系统会发生什么？\n&nbsp;\n其他操作方法\nAddToRoot()将UObject对象添加到根节点Root上，这样就不会被GC回收了，对应的方法为RemoveFromRoot()。是通过将对象对应GUObjectArray中的FUObjectItem的Flags会加上EInternalObjectFlags::RootSet标记实现的。\n&nbsp;\nIsValid()这个函数检查对象是否有效，对应C++中的“!=null”操作，但是这个函数本身可以对对象进行更多的检查。\n\n检查UObject指针指向是否为空——为空则返回false\n检查对象内部的InternalFlags，如果被标记为待销毁，则返回false\n检查对象是否正在被垃圾回收，如果是，则返回false\n\n\n#include &quot;UObject/UObjectGlobals.h&quot;\n\nbool IsValid(const UObject* Object)&#123;    if (Object &#x3D;&#x3D; nullptr)    &#123;        return false;    &#125;\nif (Object-&amp;gt;IsPendingKill())\n&#123;\n    return false;\n&#125;\n\nif (Object-&amp;gt;HasAnyFlags(RF_BeginDestroyed) || Object-&amp;gt;HasAnyFlags(RF_FinishDestroyed))\n&#123;\n    return false;\n&#125;\n\nreturn true;\n\n}\n&nbsp;\nMarkPendingKill()手动将对象设置为等待回收的对象，意思就是跳过GC一系列的算法，直接在下一轮将对象回收。是通过将对象对应GUObjectArray中的FUObjectItem的Flags加上EInternalObjectFlags::PendingKill标记来实现的。\n&nbsp;\n防止被GC\n\n使用AddToRoot函数\n直接或间接被Root对象引用\n直接或间接被FGCObject对象引用\n\n\n&nbsp;\n主动GC\nCollectGarbage()在当前帧内进行一次垃圾回收\nForceCollectGarbage()在下一帧内进行一次垃圾回收\n&nbsp;\n判断UObject对象有效性\nIsValid()——判断指针是否为空，判断是否为PendingKill\n&nbsp;\n基础定义\n类EInternalObjectFlags\nFUObjectItem用于保存UObject信息，存有一个EInernalObjectFlags的枚举变量，这个变量代表着当前对象的情况，比如PendingKill代表对象就要被回收了。\n在类型系统中的其他Flags：\n\nEObjectFlags：对象本身的标志。\nEInternalObjectFlags：对象存储的标志，GC的时候用来检查可达性。\nEObjectMark：用来额外标记对象特征的标志，用在序列化过程中标识状态。\nEClassFlags：类的标志，定义了一个类的特征。\nEClassCastFlags：类之间的转换，可以快速的测试一个类是否可以转换成某种类型。\nEStructFlags：结构的特征标志。\nEFunctionFlags：函数的特征标志。\nEPropertyFlags：属性的特征标志。\n\n\n来自大钊的《InsideUE4》\n\nReachableInCluster = 1 &lt;&lt; 23, ///&lt; 集群中存在对对象的外部引用\nClusterRoot = 1 &lt;&lt; 24, ///&lt; 集群的根\nNative = 1 &lt;&lt; 25, ///&lt; 本地的(仅UClass)。\nAsync = 1 &lt;&lt; 26, ///&lt; 对象只存在于与游戏线程不同的线程上。\nAsyncLoading = 1 &lt;&lt; 27, ///&lt; 对象正在异步加载。\nUnreachable = 1 &lt;&lt; 28, ///&lt; 对象在对象图(Graph)上不可达。\nPendingKill = 1 &lt;&lt; 29, ///&lt; 等待销毁的对象(在GamePlay中无效，但暂时还依然有效的对象)\nRootSet = 1 &lt;&lt; 30, ///&lt; 对象将不会被垃圾回收，即使未引用。\n\n如何看待FUObjectItem？这个结构在某UObject被纳入UE的GC管理后被分配，为一对一的关系，用于存储该对象的一些GC相关的元数据。也并不一定为一对一的关系，比如某些UObject不被纳入此UE的正常GC之中则不会被分配。\n由于FUObjectItem本身只是结构体，而且在GUObjectArray中排列紧密，所以在GC的扫描中能很方便得直接进行For循环遍历，而且此For循环也可以使用多线程版本的For循环。\n\n//UObjectArray.h\nstruct FUObjectItem\n&#123;\n   class UObjectBase* Object; //对象，使用newObject时返回的对象指针\n   int32 Flags;               //EInternalObjectFlags标识\n   int32 ClusterRootIndex;    //当前所属簇索引\n   int32 SerialNumber;        //对象序列码(WeakObjectPtr实现用到它)\n&#125;\n\n&nbsp;\nGC流程\n首先从CollectGarbage()开始，这个函数做了三件事：\n\n获取GC锁\n执行CollectGarbageInternal\n释放GC锁\n\n\n&nbsp;\nUE引擎中的GC是多线程的，所以要设置GC锁。比如防止一个对象加载后，其引用还没被添加，就被当成垃圾被GC掉，所以这个锁的目的是防止其他线程对这个UObject进行相关操作。\n重点是CollectGarbageInternal，这个函数之内执行标记和清扫操作。\n标记\nPerformReachabilityAnalysis()方法：\n\n在ObjectsToSerialize中添加FGCObject::GGCObjectReferencer，用于在非UObject对象上调用AddReferencedObjects方法。\n调用MarkObjectsAsUnreachable，将不带KeepFlags标记的对象标记为不可达。\n\n\nGUObjectArray，这个全局的变量保存了所有的UObject（由FUObjectItem封装）。可以通过下标来找到UObject，此下标就存储在UObjectBase::InternalIndex属性之中。\n此外，这个UObject列表的前部有一些不被纳入GC的obj，会在gc扫描时特地排除。\n\nPerformReachabilityAnalysisOnObjects判断可达。\n\n\nReferenceToken是一组token流，用于描述类中对象的引用情况，使用它的原因是代替UProperty来扫描对象引用关系，达到更高效率。\n每一个UObject都有一个对应的UClass来保存这个对象中每一个属性的相关信息，可以通过这个对象的实例化地址来遍历所有的属性，这样也能得到所有的引用对象。但是时则以的效率太慢，因为大部分情况下对象的属性都不是UObject类型。\n\ntoken流的意思就是将一系列数据转化为uint32值，这个值的实际意义是这个对象引用的其他对象的偏移位置，使之更方便传输与缓存。\ntoken在UE中由FGCReferenceInfo这个类来描述，具体如下：\n/** Mapping to exactly one uint32 */\nunion\n&#123;\n /** Mapping to exactly one uint32 */\n struct\n &#123;\n     /** Return depth, e.g. 1 for last entry in an array, 2 for last entry in an array of structs of arrays, ... */\n     uint32 ReturnCount\t: 8;\n     /** Type of reference */\n     uint32 Type\t\t\t: 4;\n     /** Offset into struct/ object */\n     uint32 Offset\t\t: 20;\n &#125;;\n /** uint32 value of reference info, used for easy conversion to/ from uint32 for token array */\n uint32 Value;\n&#125;;\n\n\n\nReturnCount——嵌套深度\nType——引用的类型（EGCRefenceType）\nOffset——引用对应属性在类中的地址偏移\n\n\n可以通过解析token流来得到所引用的属性，然后这个属性其实就是这个类的成员变量，换句话说也就是“这个对象所引用的对象”了；其次，两个token（32位）还可以用于存储指针（64位），比如使用AddReferencedObjects添加对象时，它的函数指针。\n\nProcessObjectArray就是实质性的遍历Uobject的token流并寻找引用关系的方法，在多线程的情况下，UObject的列表被分配给各个线程，并调用ProcessObjectArray。此方法中遍历的就是ObjectsToSerialize中的UObject来寻找引用关系并判断可达性的。\n所有一整个标记的流程大概为：UObject的反射信息UClass中含有一个token流属性，这个属性为一个用int值保存属性信息的共同体——&gt;CollectGarbage()中的标记核心函数触发——&gt;PerformReachabilityAnalysis()获取到GUObjectArray中的所有对象，根据标签更改标记，包括继承了FGCObject的非UObject对象，如果对象可达，则放入ObjectsToSerialize——&gt;PerformReachabilityAnalysisOnObjectsInternal()通过解析对象的token流，判断属性是否为UObject类型，如果是，则将引用对象去除不可达标记，并将其加入ObjectsToSerialize中\n\nObjectsToSerialize这个列表是动态的，因为遍历的过程中肯定会遍历到引用的新对象，于是这个新对象也会被纳入到这个ObjectsToSerialize中，并一轮又一轮得递归遍历。\n&nbsp;\n清除\n整个标记流程结束后，GObjectArray再次被遍历，所有的不可达对象放入GUnreachableObjects中。\n清除的流程分为UnhashUnreachableObjects和IncrementalDestroyGarbage两部分，前者调用所有不可达对象的BeginDestroy，后者调用所有不可达对象的FinishDestroy。\nBeginDestroy意思是通知对象即将被销毁，该对象需要做好在其他线程上的清理工作。\nFinishDestroy调用之前会判断对象是否做好清理工作，之后会将走到这一流程的所有对象在下一帧调用析构函数，被彻底清理。\n&nbsp;\nCluster\n//todo\n&nbsp;\nQA\n可以看https://zhuanlan.zhihu.com/p/401956734的最后段，我觉得很有用\n\n","categories":["虚幻引擎系列"]},{"title":"UE多线程与windows多线程输入","url":"/2025/11/11/UE%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8Ewindows%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BE%93%E5%85%A5/","content":"\n\n\n\nUE多线程\n\n\nUE5多线程+windows系统多线程输入实战\nUE5里的线程\n\nGameThread-游戏线程\nDrawThread-渲染线程\nRHIThread-调用各平台绘图API的线程\n其他线程（网络、文件I/O）\n\n\n怎么进行多线程\n\nRunnableThread\nThreadPool\nTaskGraph\n\n\nRunnableThread\n这种方式是最基础的多线程方式，既创建一个线程任务。\n这种方式由“FRunnable”类和“FRunnableThread”两个类相互配合实现\n如果用这种方法实现，则需要将我们的业务代码写在继承Runnable类的子类当中，并实现Init(),Run(),Stop(),Exit()四个方法，这里只关心新加的线程是什么逻辑，并不关心多线程具体如何实现。\nFRunnableThread既线程本身的抽象，内含静态方法Create，可以通过这个方法创建FRunnable线程。\n\nThreadPool\n固定数量的线程池，适用于持续时间短，比较复杂的异步任务。\n\n线程池在这里创建，位置为FEngineLoop::PreInitPreStartupScreen，还有不同种类的好几个池，这里先不看\nAsync和AsyncPool函数就是典型的使用线程池的方法\nAsync(EAsyncExecution::ThreadPool,[]()&#123;&#125;);//内部调用AddQueuedWork接口\n\n底层的实现方式也是利用了Runnable，网上偷了张图，不做过多介绍了\n\n总结就是线程池当中的基础线程单位FQueuedThread对象继承自FRunnable，这些线程单位通过线程池中的“待执行任务队列”和“空闲线程列表”管理。任务本质其实也就是一个函数，通过封装后通过AddQueuedWork接口传入，一旦传入任务，线程池就会检查是否拥有空闲线程，如果有就直接分配，如果没有就先放进“待执行任务队列”中。\nTaskGraph\n既任务线程直接产生依赖。典型的多线程GC就是通过这样的方法来实现的。包括GameThread，RenderThread，都是通过TaskGraph管理的。\n从根本上讲，TaskGraph只是一个“基于任务的并发系统”，管理线程池只是他功能中的一部分，总而言之，TaskGraph可以用来创建并发任务，同时也提供了等待机制，实现了调度一系列有依赖关系、可分布在不同线程的任务的功能。\n关键词：有向无环任务网络（DAG）\nTaskGraph支持两种线程，NamedThread和AnyThread，NamedThread就是外部创建的，例如GameThread和RenderThread。\n具体的实现方法也不深入看了，这里浅尝即止，既有一个任务队列，此外每个任务都有个FGraphEvent对象，此对象维护一个“后续任务列表”；每个任务还对应有一个“后续任务引用”，可以理解成这个任务的“代理”；每个任务还有一个计数器，记录自己依赖了多少别的对象，系统会轮询这个计数器，如果为0就加入总任务队列中待运行。\n如果想让A放在B的后面运行，那么就将A的“后续任务引用”加入到B的“后续任务列表”中，一旦B完成了，就会遍历后续任务列表，并将列表中的任务计数器-1。其实也就是是一个拓扑排序。\n前面提到的任务队列，也就是线程池中的“工作线程”的任务队列，这些工作线程有不同的优先级，这些优先级决定了CPU调度的优先级，高优先级获得更多CPU时间，在创建任务时，可以配置这些任务的“线程优先级”和“任务优先级”，前者决定去哪个优先级的工作线程，后者决定他在同一个工作线程的任务队列中的优先级。\n也可以使用Async来通过TaskGraph来创建多线程任务\nAsync(EAsyncExecution::TaskGraph,[]()&#123;&#125;);\n\n还是偷了张图，有空就多看看，请忽略叠了好几层的水印\n\n线程同步的方法\n首先上面说的TaskGraph我认为就是一种同步方法，让DAG自动管理不同任务之间的相互依赖，这样就可以无须关心任务同步。\n当然UE还提供了一些基础的同步功能。\n\n原子操作——Atomics\n\n\nusing RefCountType = std::conditional_t&lt;Mode == ESPMode::ThreadSafe, std::atomic&lt;int32&gt;, int32&gt;;\n\n这个类型就是智能指针中引用计数的类型，这里就用到了原子计数\n\n锁——FCriticalSection\nFEvent——线程间通知机制，允许线程等待特定信号后再进行\n如果在多线程中有线程不确定什么时候结束，又和其他线程有依赖关系，可以考虑用。可以使用FEvent对事件包装，然后调用Wait方法后再调用Trigger。\n\n\nWindows多线程输入\n实际在公司里做的一个具体的需求，就是需要保证主游戏线程卡顿（如果发生）的同时，保证其输入以及输入时触发的一系列功能（特效、音效）等不受影响。\nUE的输入流程\n首先看一下UE是怎么处理输入的。\n\n在FEngineLoop中\n\n这个地方只看行的话，是在GEngine-&gt;Tick()之前，也就是说是在每次tick，但是在处理主流程逻辑之前进行输入信号处理。\n再往里走，遇到一个WinPumpMessages函数\n\n这个函数是一个标准的WINDOWSAPI消息循环，这里稍微扩展一下WindowsOS的一些概念\n消息队列：一个由OS直接管理的队列，也分为系统级和应用级，一般消息都是直接发送给系统级的消息队列，然后再由OS分发给各线程的引用级消息队列上\n消息循环：一个死循环，通常由“GetMessage/PeekMessage”、“TranslateMessage”和“DispatchMessage”三部分组成，分别代表“从消息队列中获取消息”、“翻译消息生成字符信息”和“分发消息给目标窗口”，这里GetMessage是阻塞式的，也就是拿不到消息就不会返回，而PeekMessage不是。\n窗口过程函数：在窗口收到消息时（DispatchMessage）触发的逻辑函数\n窗口类：windowsOS在创建窗口时，需要告诉OS这个窗口的类型，比如一些已经预定义的button、edit等，如果需要自定义窗口，则需要自定义窗口类，像这样：\n这个UnrealWindow既虚幻编辑器的窗口类定义，一般最重要的是要把窗口过程函数（AppWndProc）定义出来。\n\n如果比较熟悉Windows编程，那么对这一套流程应该很熟悉，后面我实现虚幻上的Windows平台多线程输入也是用的这一套逻辑。\n经过UE的窗口过程函数，会走到这里：\n\n意思就是在UE的Windows输入消息真正传入UE的input系统之前，还有一个机会去处理它，那就是传入一个自定义的MessageHandler。可以在一些Actor中依赖一些自定义的MessageHandler，然后这个Actor就可以越过input系统直接获取到WindowsOS的消息了。这里要注意生命周期，不过暂时还不知道有什么具体应用。\n再之后就是根据输入信息来处理了，ProcessMessage以及后面的ProcessDeferredMessage都会根据Message的不同类别来进行不同的处理，这里的分类指是否为键盘、是否为键盘中的字符串、是否为连携键（比如ctrl+）等等等等，这里有点意思的是输入法相关也算一次输入信息，比如是英文输入法，那么按下键盘a，处理发布一个KeyDown信息，还会发布一个a的KeyChar信息；如果是中文输入法，那么KeyChar会出现在输入法真正打入一个中文时发布，比如发布一个“啊”字符。\n\n再往后，就到了SlateApplication里面了，从这里开始，一条输入消息算是从原始输入信息正式转换进了UE的inputsystem当中。\n\n再往后的内容，可能更重要些，但和现在要做的需求关联并不是很大。我以后还会总结的。\n多线程输入\n从上面的分析可知，虚幻引擎是在主流程tick之前进行消息输入处理的，那么可能会发生这样的情况：如果主流程因各种原因卡顿、掉帧，就会导致用户的输入会产生延迟。\n所以解决的思路就是利用Runnable单拉一个线程出来，在创建时建立一个新的windows隐藏窗口，然后在这个独立的工作线程中创立一个消息循环，定义窗口过程函数，这样独立线程的输入就不会被主线程影响了。\n\n","categories":["虚幻引擎系列"]},{"title":"UE智能指针源码阅读","url":"/2025/11/12/UE%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","content":"\n\n\n\nUE里的智能指针源码阅读\n\n\nUE里的智能指针源码阅读\n注释：\n\n还有很多，这里直接总结（抄一段）：\n\n惯例的智能指针内存分配特性\n弱引用解决循环引用\n有线程安全的版本\n模板特性可支持几乎所有类型\n共享引用永远不会为空，永远可以解引用，实现运行时安全\n\n\n辅助类和函数：\n\nMakeShareable() - 将普通指针转化成共享指针\nMakeShared(...) - 构造时同时分配控制块内存与目标对象内存\nTSharedFromThis - 从本类中生成一个自己的类，或者获取TSharedRef*\nStaticCastSharedRef() - 静态向下转换\nConstCastSharedPtr() - const引用转换为mutable引用\nStaticCastSharedPtr() - 动态向下转换\nConstCastSharedRef() - const指针转换为mutable指针\nStaticCastWeakPtr()\nConstCastWeakPtr()\n\n\n几条建议：\n\nReset()释放对象引用并（可能）释放内存\n共享指针内部不要调用自己的delete\n不光C指针，UE的智能指针和UObject也不兼容，原因一致\n\n\n和标准库以及其他智能指针的不同点：\n\n称呼不一样，更贴近Unreal语法\n不要直接用weak类型的指针做参数，然后使用shared的构造函数凭空构造，最好用pin，理由和上面的一样\nTSharedFromThis返回的是共享引用\n\n\n虚幻实现智能指针的理由：\n\nstd以及其他库的智能指针并不是全平台通用的\n与Unreal容器更好的协作\n线程安全可选，强制线程安全可能导致性能问题\n更多改进\n\n\n以上，便是虚幻官方对U智能指针的总结，基本上涵盖了所有智能指针特性\nSharedPtr：\ntemplate&lt; class ObjectType, ESPMode InMode &gt;\nclass TSharedPtr\n&#123;\npublic:\n    static constexpr ESPMode Mode = InMode;\n    ...\n    //省去一大堆各自特化的构造函数、功能函数\n    ...\nprivate:\n    ObjectType* Object;// 不能为空\n    SharedPointerInternals::FSharedReferencer&lt; Mode &gt; SharedReferenceCount;\n&#125;\nFSharedReferencer是一个包含一个指针的对象，它指向的是引用控制块，在SharedPointerInternals.h内：\n\ntemplate&lt; ESPMode Mode &gt;class FSharedReferencer&#123;    …private:   TReferenceControllerBase&lt;Mode&gt;* ReferenceController;&#125;\n所以一个Shared指针对象的大小为16，（在64位的情况下），而控制块的内容是两个计数：\ntemplate &lt;ESPMode Mode&gt;\nclass TReferenceControllerBase\n&#123;\npublic:\n    FORCEINLINE explicit TReferenceControllerBase() = default;// 顺手把默认构造函数删了\n    RefCountType SharedReferenceCount&#123;1&#125;;\n    RefCountType WeakReferenceCount&#123;1&#125;;\n    ...\n&#125;\n\n贴上原注释机翻：\n// 对这个对象的共享引用数量。当这个计数达到零时，关联的对象\n// 将被销毁（即使还有弱引用！），但引用控制器不会被销毁。\n//\n// 这个计数从1开始，因为我们通过构造TSharedPtr创建引用控制器，\n// 而这就是第一个引用。没有必要从0开始然后再递增\n// 对此对象的弱引用数量。如果有任何共享引用，这也算作一个\n// 弱引用。当这个计数达到零时，引用控制器将被删除。\n//\n// 这个计数从1开始，因为它表示我们也在初始化\n// SharedReferenceCount 的共享引用。\n&nbsp;\n所以一个Shared指针的基本结构就很清晰了，本质就是一个指向对象的指针，和一个指向引用控制块的指针，在文件中，又通过Internals将引用控制块包了一层，各自处理逻辑来实现自动化引用技术功能。\nSharedPtr做了什么，引用控制块做了什么\n先看最底层的引用控制块，由上文的注释可得到以下信息：\n控制块初始化的时候，强引用计数就附一\n强引用计数也算做一个弱引用计数（但是从代码中看并不会对计数本身的值产生影响）\n强引用计数归0时释放指向对象，弱引用计数归0时释放控制块\n也就是说，虚幻的shared智能指针支持：哪怕对象本身已经销毁，也允许弱引用的安全存在。\n这样做的目的之一，就是保证在对象释放掉之后也能被查询到，比如使用IsValid()安全检测对象是否有效，而且控制块本身肯定要比对象轻量，所以控制块是否销毁也无所谓。\n&nbsp;\n看下控制块内的剩下内容：\nvirtual void DestroyObject() = 0; // 虚函数声明的，允许重写的自定义delete\nFORCEINLINE int32 GetSharedReferenceCount() const&#123;&#125; // 获取计数数量，懒得看，里面有个线程安全的分支\nFORCEINLINE bool IsUnique() const // 检查此控制块是否只被一个引用\n&#123;\n    return 1 == GetSharedReferenceCount();\n&#125;\nFORCEINLINE void AddSharedReference()&#123;&#125; // 增加引用计数，也有线程安全的版本，可以理解为SharedReferenceCount++\nFORCEINLINE void ReleaseSharedReference() // 释放（减少）引用计数\n&#123;\n    //如果为线程安全版本，则在此处多加，但减少计数的代码还是一样的\n    checkSlow( SharedReferenceCount &gt; 0 );\n    if( --SharedReferenceCount == 0 )\n    &#123;\n        DestroyObject(); // 如果变0了就释放对象\n        ReleaseWeakReference();\n    &#125;\n&#125;\nFORCEINLINE void AddWeakReference()&#123;&#125;; // 增加弱计数，和强计数几乎一样\nvoid ReleaseWeakReference()\n&#123;\n    if(--WeakReferenceCount == 0)\n    &#123;\n        delete this;\n    &#125;\n&#125;\n\nTReferenceControllerBase(const TReferenceControllerBase&amp;) &#x3D; delete;TReferenceControllerBase&amp; operator&#x3D;(const TReferenceControllerBase&amp;) &#x3D; delete; &#x2F;&#x2F;不准拷贝\n也没啥，基本上都是计数的基本操作，提供api，分别设置强引用弱引用为0干嘛。\n再看下SharedPointerInternals的内容，其构造和控制块是一致的，通过构造函数列表的方式，同步控制块和其指针的构造，例：\nFORCEINLINE FSharedReferencer()\n: ReferenceController( nullptr )&#123; &#125;\n\n总结下shared指针控制块构造规则：\n\n拷贝构造时，强引用计数+1\n移动构造时，原始控制块指针赋空\n通过弱指针拷贝构造时，会检查是否已经存在强引用计数，如果有，才会+1\n通过弱指针移动构造时，也会检查是否已经存在强引用计数，而且会释放掉原弱指针\n拷贝赋值运算符，在赋值的对象不同的情况下，增加原引用计数，减少强指针计数，最后将自己的控制块指针赋值过去\n移动赋值运算符，直接将指向挪过去就行\n\n\n其实和字符串定义如出一辙。从上面的总结其实就可以分析出智能指针对引用计数的管理方式了，以下为盲写的shared指针定义，代码为伪代码，实际情况比这个负责得多。\ntemplate&lt;class Type, ESPMode InMode&gt; // InMode为线程安全的设置，先不管，这里写上属于是一个象征意义\nclass TSharedPtr\n&#123;\npublic:\n    inline void explicit TSharedPtr() = default;\n    inline void TSharedPtr(TSharedPtr const&amp; ptr)&#123;\n        if(ptr != nullptr)&#123;\n            count++;\n        &#125;\n    &#125;;\n    inline void TSharedPtr(TSharedPtr&amp;&amp; ptr)&#123;\n        ptr.ObjectPtr = nullptr;\n    &#125;\n    inline TSharedPtr&amp; operator=(TSharedPtr const&amp; ptr)&#123;\n        if(ptr.ObjectPtr != ObjectPtr)\n        &#123;\n         ptr.count++;\n        &#125;\n        return *this\n    &#125;      \n   inline TSharedPtr&amp; operator=(TSharedPtr&amp;&amp; ptr)&#123;\n        if(ptr.ObjectPtr != ObjectPtr)\n        &#123;  \n            count--;\n            if(ptr != nullptr)\n            &#123;\n                ptr.count++;\n            &#125;\n        &#125;\n        return *this;\n    &#125;   \n    virtual ~TSharedPtr()&#123;&#125;\n    void Release()&#123;\n        count--;\n        if(count&lt;=0)&#123;\n            Destory(ObjectPtr);\n        &#125;\n    &#125;\nprivate:\n    Type* ObjectPtr;\n    int count;\n&#125;\n\n由于控制块聚焦于计数，所以此伪代码省去了ObjectPtr指针本身的管理，那么指针本身在哪管理呢，那就是TSharedPtr本体 \n真实的SharedPtr的构造函数重载非常多，这里只举例几个：\nFORCEINLINE explicit TSharedPtr( OtherType* InObject )\n    : Object( InObject )\n    , SharedReferenceCount( SharedPointerInternals::NewDefaultReferenceController&lt; Mode &gt;( InObject ) )\n&#123;\n    SharedPointerInternals::EnableSharedFromThis( this, InObject, InObject );\n&#125;\n\nFORCEINLINE TSharedPtr( OtherType* InObject, DeleterType&amp;&amp; InDeleter )    : Object( InObject )    , SharedReferenceCount( SharedPointerInternals::NewCustomReferenceController&lt; Mode &gt;( InObject, Forward&lt; DeleterType &gt;( InDeleter ) ) )&#123;    SharedPointerInternals::EnableSharedFromThis( this, InObject, InObject );&#125;\n先关注一个细节：Shared指针只在类名处使用模板ObjectType，但实际构造时却使用了通用模板OtherType，这样做的好处是适配关联类型的指针指针构造，比如ObjectType为父类，通过此基础类型构造子类OtherType的指针，那么是可以的；如果两者不关联呢？请看以下构造函数模板声明：\ntemplate &lt;\ntypename OtherType,\ntypename DeleterType,\ntypename = decltype(ImplicitConv&lt;ObjectType*&gt;((OtherType*)nullptr))\n\n第三行意思就是检查OtherType类型是否可以转换成ObjectType类型，如果不通过，则编译期检查失败，那么这个模板就不会实例化，于是编译器就会报错。\n\n其他常规的也不贴了，总之这些更上层的构造都有一个特点：只关注于UE对象本身的联动。\n比如上层可以重载各种各样的构造函数来完善指针的各自初始化途径；\n再比如上文使用普通指针去初始化一个智能指针，内部其实是调用了EnableSharedFromThis来创建，这个后面再说。\n智能指针与普通指针同时指向一个对象的做法是不规范的，因为智能指针自动会析构对象，此时普通指针就会变成悬空指针\nWeakPtr\n弱指针的定义，大致结构和共享指针是一致的。\ntemplate&lt; class ObjectType, ESPMode InMode &gt;\nclass TWeakPtr\n&#123;\n    ...\nprivate:\n    ObjectType* Object;\n    SharedPointerInternals::FWeakReferencer&lt; Mode &gt; WeakReferenceCount;\n&#125;\n//有一个FWeakReferencer，含有一个TReferenceControllerBase*对象，和共享指针是一致的\n\ntemplate&lt; ESPMode Mode &gt;class FWeakReferencer&#123;    …private:    &#x2F;** Pointer to the reference controller for the object a TWeakPtr is referencing &#x2F;    TReferenceControllerBase&lt;Mode&gt; ReferenceController;&#125;\n这个控制块，如果这个弱指针和共享指针指向的是同一个对象，那么这个控制块也是同一个控制块，他们共享内部的所有功能。\n如上文所示，功能块内有共享指针计数与弱指针计数，而这两个计数的增加删除规则，其实是差不多的，重点在析构的时候有所不同\nFORCEINLINE void ReleaseSharedReference() // 释放（减少）引用计数\n&#123;\n    //如果为线程安全版本，则在此处多加，但减少计数的代码还是一样的\n    checkSlow( SharedReferenceCount &gt; 0 );\n    if( --SharedReferenceCount == 0 )\n    &#123;\n        DestroyObject(); // 如果变0了就释放对象\n        ReleaseWeakReference();\n    &#125;\n&#125;\n\nFORCEINLINE void ReleaseWeakReference()&#123;   checkSlow( WeakReferenceCount&gt; 0 );    if( –WeakReferenceCount&#x3D;&#x3D; 0 )    &#123;      delete this;    &#125;&#125;\n维持了人设，即控制控制块，在计数为0的时候直接删除this。\n&nbsp;\nPin\n[[nodiscard]] FORCEINLINE TSharedPtr&lt; ObjectType, Mode &gt; Pin() const&amp;\n&#123;\n    return TSharedPtr&lt; ObjectType, Mode &gt;( *this );\n&#125;\n\n[[nodiscard]] FORCEINLINE TSharedPtr&lt; ObjectType, Mode &gt; Pin() &amp;&amp;&#123;    return TSharedPtr&lt; ObjectType, Mode &gt;( MoveTemp( *this ) );&#125;\npin用于利用一个WeakPtr对象来返回一个SharedPtr对象，如果指向的目的对象没有其他有效SharedPtr指向，则会返回空。\n有左值引用和右值引用两个版本，如果是右值版本，则转化后这个弱引用则用不了了。\n调用的是这个私有构造函数：\nFORCEINLINE explicit TSharedPtr( TWeakPtr&lt; OtherType, Mode &gt; const&amp; InWeakPtr )\n    : Object( nullptr )\n    , SharedReferenceCount( InWeakPtr.WeakReferenceCount )\n&#123;\n    if( SharedReferenceCount.IsValid() )\n    &#123;\n        Object = InWeakPtr.Object;\n    &#125;\n&#125;\n\n检查引用计数的逻辑，卸载SharedReferenceCount里面，就不深入了。\n&nbsp;\nSharedRef\n和SharedPtr一样，但是必须有所指向，区别在于SharedPtr内允许空指针构造，而SharedRef不允许。\n&nbsp;\nUniquePtr\nUniquePtr写在Unique.h文件中。\ntemplate &lt;typename T, typename Deleter = TDefaultDelete&lt;T&gt;&gt;\nclass TUniquePtr : private Deleter\n&#123;\n    ...\nprivate:\n    using PtrType = T*;\n    LAYOUT_FIELD(PtrType, Ptr);\n    ...\n    FORCEINLINE ~TUniquePtr()\n    &#123;\n        GetDeleter()(Ptr);\n    &#125;\n    ...\n&#125;\n\nLAYOUT_FIELD宏展开后是一个T*类型的变量，以及这个字段相关的反射代码。\n和C++保持一致，他将拷贝构造和拷贝运算符直接删除了。\nTUniquePtr(const TUniquePtr&amp;) = delete;\nTUniquePtr&amp; operator=(const TUniquePtr&amp;) = delete;\n\nSharedFromThis\n对标std::enable_shared_from_this\n本质是一个类，总所周知想要调用这个，需要将自己的类继承它。\ntemplate&lt; class ObjectType, ESPMode Mode &gt;\nclass TSharedFromThis\n&#123;\npublic:\n    [[nodiscard]] TSharedRef&lt; ObjectType, Mode &gt; AsShared()\n    &#123;\n        TSharedPtr&lt; ObjectType, Mode &gt; SharedThis( WeakThis.Pin() );\n        check( SharedThis.Get() == this );\n       return MoveTemp( SharedThis ).ToSharedRef();\n    &#125;\n\n   [[nodiscard]] TWeakPtr&lt; ObjectType, Mode &gt; AsWeak()    &#123;        TWeakPtr&lt; ObjectType, Mode &gt; Result &#x3D; WeakThis;       check( Result.Pin().Get() &#x3D;&#x3D; this );        return Result;    &#125;\n   template&lt; class SharedRefType, class OtherType &gt;    FORCEINLINE void UpdateWeakReferenceInternal( TSharedRef&lt; SharedRefType, Mode &gt; const* InSharedRef, OtherType* InObject ) const    &#123;        if( !WeakThis.IsValid() )        &#123;            WeakThis &#x3D; TSharedRef&lt; ObjectType, Mode &gt;( *InSharedRef, InObject );        &#125;    &#125;protected:    TSharedFromThis() &#123; &#125;    TSharedFromThis( TSharedFromThis const&amp; ) &#123; &#125;    FORCEINLINE TSharedFromThis&amp; operator&#x3D;( TSharedFromThis const&amp; )    &#123;        return *this;    &#125;    ~TSharedFromThis() &#123; &#125;private:    mutable TWeakPtr&lt; ObjectType, Mode &gt; WeakThis;&#125;\n构造函数啥也不干，有一个弱指针的对象，此对象在UpdateWeakReferenceInternal内赋值，还有一个返回SharedPtr的版本，懒得抄了，然后就是应用端使用的AsShared和AsWeak，分别返回WeakThis.Pin和WeakThis自己。\nUpdateWeakReferenceInternal其实得是private而不是public，但是模板的bug让他得是public（这是5.5版本注释自己写的）。\n此函数在EnableSharedFromThis内直接调用。\n这个EnableSharedFromThis挺眼熟，也就是之前分析过的SharedPtr（SharedRef）构造中必会出现的一个函数。\n&nbsp;\n所以说继承TSharedFromThis的类，在初始化时，TSharedFromThis自身是啥都不干的，但是当有共享指针构造并指向它时，会调用EnableSharedFromThis→UpdateWeakReferenceInternal。而EnableSharedFromThis本身就接收一个TSharedFromThis对象（如果为空就跳出），这里产生逻辑闭环。\n结果就是类内的弱指针得到此类对象的赋值，再然后就是用户自己调用AsShared或者AsWeak来获取它了。\n&nbsp;\nMakeShared\n对标C++的std::make_shared\n&nbsp;\n\n","categories":["虚幻引擎系列"]},{"title":"UE网络同步模块","url":"/2025/11/17/UE%E7%BD%91%E7%BB%9C%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9D%97/","content":"\n\n\n\nUE移动组件以及相关网络同步\n\n\nUE网络同步\n在网络游戏万事通（基本概念+引擎技术栈+底层原理） | Coding中。。。栏目内从新人的角度讨论了游戏通用网络同步技术的基础概念以及部分历史发展，其中涉及到的虚幻相关的网络同步技术只涉及到了UE中的“通用复制系统”的最基础部分，由于工作的原因，长时间处于研究UI系统、脚本系统和Slate相关概念，已经长时间和之前想走的GamePlay方向渐行渐远，现在再重看UE的网络模块，发现UE为此做了相当多的处理，例如复制图表系统和Iris复制系统以及移动同步组件等等，所以现在抽时间研究研究文档，并稍微看下代码，为之后做Demo打下基础。\n&nbsp;\n基础概念\n首先是网络模式NetMode，虚幻引擎中定义了一个游戏会话的四种模式：\n\nNM_Standalone：可以直接理解成单机，理论上也有服务器逻辑，但不允许客户端连接，也可以考虑多人本地游戏。\nNM_DedicatedServer：既DS连接，服务器单独运行，没有客户端的图形、声音、输入等逻辑，允许客户端连接。\nNM_ListenServer：既LS连接，服务器和客户端同时运行在一个会话中，允许其他客户端连接，优点是成本低，不需要额外的服务器会话，缺点是存在竞技公平性问题，且不适合网络负载高的游戏。\nNM_Client：连接到远程的客户端，没有服务端逻辑。\n\n\n复制：属性复制，Actor复制，Rpc调用。一般情况下，启用复制后，actor的创建，销毁，移动都会自动处理，但其他功能需要手动处理，例如属性、函数、组件与子对象（及其属性函数等）。\n在虚幻的概念中，通常这些功能需要客户端自行运行：\n\n网格\n材质\n动画蓝图\n粒子系统\n声音\n物理对象\n\n\n这些功能一般由同步过来的某个属性来进行驱动。\nActor复制中的一些概念：休眠（Dormancy）、优先级（Priority）、相关性（Relevancy）\n\n&nbsp;\n网络连接中心、连接、网络通道\nNetDriver存有所有Connection的引用，对于服务器来说，是一个ServerConnection，对一个客户端来说，是一个ClientConnection，每当有一个客户端连接到服务器，就相当于NetDriver多了一个ClientConnection。客户端开始再服务器上运行时，客户端的玩家控制器会立即同步到一个Pawn以控制。\nActor的相关性值哪些Connection来同步这个Actor的复制，对于玩家控制器来说，只和自己的Connection有高相关性，所以只有自己会收到自己的玩家控制器的同步（bOnlyRelevantToOwner）。\nActor可以通过GetOwner获取其“所有者”，如果某些Actor的所有者为控制器，那么这个Actor的关联Connection为控制器的Connection。\n&nbsp;\n网络休眠\n官方文档上提示可以手动设置Actor休眠来让他不进入复制流程中。一般情况下，考虑不可见的Actor或者某些时段下对玩家影响不大的Actor进行休眠可以保证网络性能和流畅度。\n&nbsp;\n优先级\n如果UE的网络传输流量达到饱和，那么就会触发优先级机制。\n优先级确定逻辑：AActor初始值为1.0，APawn初始值为2.0，APlayerController初始值为3.0，越大意味着分配的带宽越多。虚幻引擎中的Actor优先级 | 虚幻引擎 5.7 文档 | Epic Developer Community\n&nbsp;\n相关性\n&nbsp;\nActor复制流程\n网络复制的“Main”函数为UNetDriver::ServerReplicateActors（每帧调用），它会收集并决定哪些Actor进行复制，并发送他们“被改变的属性”，然后调用UActorChannel::ReplicateActor将Actor复制到特定通道。\nint32 UNetDriver::ServerReplicateActors(float DeltaSeconds)&#123;\n    ...\n    TArray&lt;FNetworkObjectInfo*&gt; ConsiderList;\n    ConsiderList.Reserve( GetNetworkObjectList().GetActiveObjects().Num() );\n\n// Build the consider list (actors that are ready to replicate)\nServerReplicateActors_BuildConsiderList( ConsiderList, ServerTickTime );\nTSet&amp;lt;UNetConnection*&amp;gt; ConnectionsToClose;\n...\nfor ( int32 i=0; i &amp;lt; ClientConnections.Num(); i++ )\n&#123;\n    UNetConnection* Connection = ClientConnections[i];\n    //1、对Connection内所有Actor做属性检查，例如“休眠”“每帧更新”等等属性值。\n    //2、对Connection内所有Actor做相关性检查，按照优先级排序。\n    //3、进一步做筛选，例如是否有对应通道等。\n    //4、如某连接没加载需要同步的Actor所在关卡，那么不会同步此Actor，还会关闭通道。\n    //5、每秒都会调用`AActor::IsNetRelevantFor`检查相关性，不相关就关闭通道，相关则开启通道\n    //6、满足条件的调用UActorChannel::ReplicateActor将其复制到连接里面\n&#125;\n\n}\nRole和RemoteRole\n例如有一个客户端控制的角色和网络同步的NPC，那么这两个Actor的Role都是ROLE_Authority，意思是引擎负责这两个actor复制；并且客户端角色的RemoteRole 是 ROLE_AutonomousProxy，NPC是ROLE_SimulatedProxy，意思是客户端角色为会用一些真人的输入内容来加上其他推算来算出最终信息，而NPC为完全模拟，会通过上次获得的速率进行移动推算，这个推算会保证在更新间歇进行本地移动模拟来保证运动的丝滑。\n&nbsp;\n属性复制\n\nReplicated\nReplicatedUsing（带回调）\n\n\n\nNotReplicated（例如某个结构体中用这个）\n\n\n&nbsp;\nRPC\n&nbsp;\nIris复制系统\n虚幻引擎中的Iris简介 | 虚幻引擎 5.7 文档 | Epic Developer Community\n&nbsp;\n复制图表\n虚幻引擎Replication Graph | 虚幻引擎 5.7 文档 | Epic Developer Community\n&nbsp;\nUE移动组件\n这一部分文档介绍的非常少。\n移动的本质：移动基础组件的坐标移动，一般都把胶囊体设置为移动基础组件，可以设置成别的，但至少要是继承USceneComponent组件。\n\n玩家输入流程：InputComponent组件绑定的一个按钮，响应时直接调用到Pawn的AddMovementInput接口，再调用到UPawnMovementComponent::AddInputVector函数。一次移动输入相当于设置移动加速度，然后会根据移动模式、速度和时间来算出最终位置。\nUCharacterMovementComponent\nMovementMode\nWalking\n\nFalling\nJump\nSwiming\nFlying\n移动同步的流程\n参考：(99+ 封私信 / 70 条消息) UE4移动同步流程 - 知乎\n要分为“自治移动（ROLE_AutonomousProxy）”和“模拟移动（ROLE_SimulatedProxy）”，前者就是类似客户端自己操作的角色，后者就是要同步给其他客户端的角色。针对DS服务器来说，所有的角色都是需要通过模拟过来的，包括自治移动。\n自治移动\n\n每帧都会将新的数据通过RPC传给服务端，同时也会进行模拟移动。其中SavedMove列表在弱网的情况下超过96个会自动清理。\n图片歧义1：如果收到ClientAdjustPositon后，会清除服务器回传包的时间戳之前的包，后面的包不会清除，并在这个地方进行重播。\n图片歧义2：标明“现在”的时间戳在图中示意为客户端的时间戳，收到包的时间也确实是“现在”，但收到的包体时间戳可能是过去的任意一个时间点，\n模拟移动\n\n模拟移动的时候，实际位置胶囊体和Mesh是分开的。\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n","categories":["虚幻引擎系列"]},{"title":"UGUI自适应与优化与其他优化","url":"/2023/10/24/UGUI%E8%87%AA%E9%80%82%E5%BA%94%E4%B8%8E%E4%BC%98%E5%8C%96%E4%B8%8E%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96/","content":"\n\n\n\n\nUGUI自适配与优化\n\nUGUI自适配与优化\n&nbsp;\n&nbsp;\nRectTransform\n继承自Transform，是UGUI中最重要的组件之一\n\nAnchored（锚点）\nPivot（中心点）\nRotation（旋转）\nSize Delta（大小）\n\n\n\n&nbsp;\n锚点\t\nRectTransform rectTransform = GetComponent&lt;RectTransform&gt;();\nrectTransform.anchoredPosition = new Vector2(100, 100);\n\n锚点作用于父类子节点，也就是说如果UI对象有一个子对象，那么这个子对象就会基于父节点的锚点来进行位置偏移（这个父对象往往是添加UI后默认增加的“canvas”）。如果某节点没有父节点，那么锚点预设无法设置。锚点的意思是子类的中心点（Pivot）相对父类锚点（Anchored）位置不变，这个位置可以设置XYZ，可以理解成相对偏移。\n面板上的田子图一样的东西，就是锚点预设，表示设置子类锚在父类上的点。你可以通过“锚点预设”来直接点击设置锚点位置与锚点大小，也可以直接在检查器内输入数字来进行设置。\n锚点属性是一个二维数组，这个有什么含义呢，如果我们设置锚点为一个点并将其锚在父类的左下角\n\n那么子类（红色）的中心位置就会严格跟随这个锚点\n\n如图是将父类（白色）下界往上拖动\n\n再试试更改检查器中的XY，例如把他们都设置为0，0，可以看到红色中心就定在锚点上，意思就是与锚点的”偏移“为0\n\n锚点在检查器中只限制在父类范围以内（似乎通过代码可以突破这个限制？），所以二维数组的大小在0~1以内，意思就是将父类的宽高按比例进行归一了，这里就不演示将锚点位置改变到其他位置了。\n二维数组中的”min“表示锚点左下角的位置，”max“表示锚点右上角的位置，也就是说其实锚点其实可以不是一个点。\n\n图中左下角三角形表示最小，右上角表示最大，示例显示了右上角设置为0.5，0.5\n\n\n再次拖动白色右边界，发现红色的大小也随之变化，因为右上角的锚点与红色右上角（如图中右上角蓝色点）相对位置不会变化，左下角的点与锚点左下角不会相对位移。由于锚点是锚在父类对象上，大小和父类对象成比例，点相对位置和子类不变，这是锚点的基本逻辑。\n下面几个是更加夸张的例子：\n\n\n前者直接将白色负向拉伸了，此时锚点相对位置还是不变，后者将锚点直接定为覆盖父类白色全部，此时子类大小完全和父类变化成比例一致。\n&nbsp;\n中心点/轴心\nRectTransform rectTransform = GetComponent&lt;RectTransform&gt;();\nrectTransform.pivot = new Vector2(0.5f, 0.5f);\n\n前面也提到过，可以经过代码设置，同样UI元素的缩放与旋转也以这个为基准\n&nbsp;\n旋转\nRectTransform rectTransform = GetComponent&lt;RectTransform&gt;();\nrectTransform.rotation = Quaternion.Euler(new Vector3(0, 0, 45));\n\n&nbsp;\n缩放\nRectTransform rectTransform = GetComponent&lt;RectTransform&gt;();\nrectTransform.sizeDelta = new Vector2(200, 100);\n\n&nbsp;\n自适应分辨率\n所以为什么UI要设置成这样呢？为什么Unity不直接将其设置成一个真正的画板，然后直接将UI组件在上面直接画？\n如果你经常游玩《英雄联盟》，你会注意到这样一个情况：当选择游戏全屏或无边框的时候，游戏下方的技能UI界面大小是完全不一样的。这就是自适应分辨率的一个小表现，试想一下如果使用超大屏幕玩游戏，结果UI界面按比例增大比人脑袋还大，给人的体验并不好。\n你试过在电脑上下载安卓模拟器玩游戏的体验吗？\n这个在手机上最为明显，因为不同手机由于型号不同屏幕的长宽比例也不同。我不确定你玩没玩过《原神》，但这个例子是用来解释自适应分辨率的最佳对象，因为他是难得的一款双端但是UI差异十分明显的游戏。如果你在电脑上开发原神，结果在安卓手机上游玩的时候圆形的技能图标被压缩成椭圆，或者技能图标因为手机的比例问题直接印在边界下方”被劈成两半“，这些都不是我们想看到的。\n你当然可以直接通过代码将所有UI元素按需一个个安排好：\nRectTransform rectTransform = GetComponent&lt;RectTransform&gt;();\nrectTransform.anchorMin = new Vector2(0.5f, 0.5f);\nrectTransform.anchorMax = new Vector2(0.5f, 0.5f);\nrectTransform.anchoredPosition = Vector2.zero;\nrectTransform.sizeDelta = new Vector2(Screen.width * 0.8f, Screen.height * 0.8f);\n\n又或者可以通过上面所说的锚点机制来分别设置各UI元素相对父类结点的相对位置，然后父类结点的对象会根据屏幕不同而变化，子节点不变，这个时候自适应分辨率就有了初步的雏形。\n&nbsp;\n画布（canvas）\n画布 (Canvas) 组件表示进行 UI 布局和渲染的抽象空间。所有 UI 元素都必须是附加了画布组件的游戏对象的子对象。从菜单 (GameObject &gt; Create UI) 创建 UI 元素对象时，如果场景中没有画布 (Canvas) 对象，则会自动创建该对象。\n你当然可以将画布改名，但画布组件必须被包含。\n画布可以更改不同的渲染方式：\n\nScreen Space - Overlay——无视摄像机，所有元素都渲染在其他物体前面，并且UI会根据屏幕自适应\nScreen Space - Camera——UI在屏幕上的大小不会随距离而变化，这个模式下UI会随着与摄像机距离不断进行缩放来适应，缺陷是UI如果距离太远可以被物体遮挡（也有可能不是缺陷呢是吧）\nWorld Space——把UI当作物体渲染在世界中，可以制造全息效果\n\n\n&nbsp;\nHDR和MSAA的关闭\n相机默认启用HDR和MSAA，是屏幕后处理的一种，调用出帧调试器会发现空项目也会执行后处理，所以在不使用HDR和MSAA的时候手动将其关闭就不会进行调用。（直接在摄像机面板上关闭）\n&nbsp;\nStats统计面板\n\nTris——三角形面数\nVerts——三角形点数\n\n\n新建新场景，直接打开Stats面板，这个时候这两个数据就是天空盒的数据\n\n在摄像机中取消天空盒，可以得到屏幕的数据\n\n只会统计摄像机视野内的数据\n\n阴影会影响这两个数值\n\n\nSetPass calls——材质调用次数\nBatches——批处理次数\nSaved by batching——批处理节省Draw call的次数\n\n\n这个指标将是进行UGUI性能优化的重要指标之一\n\n&nbsp;\nDraw Call与批处理\n试想情况，将十块砖分开搬，还是将十块砖打包一次性搬，哪种会快点？\nDraw Call是GPU将模型呈现到屏幕上的过程的次数，其实就是“搬砖”的次数，从结果论上讲Draw Call是越少越好的。\n来自知乎@acnestis\n渲染流水线的第一步是【CPU和GPU之间的通信】，有如下3个步骤：\n\\1. 把数据加载到显存中：把网格和纹理等数据从硬盘加载到显存中（因为显卡对显存的访问速度更快）\n\\2. 设置渲染状态：CPU根据材质球设置渲染状态，比如，使用哪个顶点着色器/片元着色器、光源属性、纹理等\n\\3. 调用Draw Call：准备好上述工作后，CPU就调用一个渲染命令(Draw Call)来告诉GPU可以开始渲染啦。\nGPU的渲染能力是很强的，渲染200个还是2000个三角网格通常没有什么区别，渲染速度往往快于CPU提交命令的速度。如果一帧中Draw Call数量太多，CPU就会在“设置渲染状态-提交Draw Call”上花费大量时间，造成性能问题。\n\nDraw Call几乎等价于Batches，尽管他们指定的操作并不是一个，但数值上往往是一致的。\n批处理就是将“砖块”打包的过程，也就是将美术素材、模型等小网格组成大网格。于是Draw Call次数减少，可以大力提高程序效率。\n静态批处理与动态批处理\n在projectsetting-&gt;玩家中\n\n\n&nbsp;\n\n静态批处理\n\n\n首先在检查器的最右端将对象设置为静态。\n\n标记为静态物体就好。\n游戏中不移动不缩放的物体就可以视为静态物体。\n静态批处理的对象就是这样的使用相同材质引用的静态物体。\n静态批处理需要额外的CPU内存来存储组合的几何图形，所以其实是一种牺牲内存来加快速度的方式。在个别场景中需要牺牲渲染性能来避免内存占用，例如大森林场景中的树木。\n以上，是构建时的静态批处理，unity支持运行时的静态批处理，可调用StaticBatchingUtility类。\n&nbsp;\n\n动态批处理\n\n\n动态批处理是Unity自动使用的，不需要我们提前设置\n\n&nbsp;\n\nSRP（可编程渲染管线）批处理器\n\n\n是SRP中特有的\n\n&nbsp;\n\nGPU Instancing\n\n\n后续会讲到，这里已经有点偏离UGUI了\n\n&nbsp;\nUGUI的合批\n就是对UGUI的控件进行批处理\n&nbsp;\n帧调试器\n窗口-&gt;分析-&gt;frame debugger\n\n打开帧调试器，启用，会将摄像机渲染的过程全部分开一一呈现在面前。\n\n直接看UGUI那一栏，是UGUI的绘制过程\nDraw Mesh——绘制网络，所有的UGUI的控件在unity面前都是网络，这里点击两个Draw Mesh，发现两个Shader与贴图都不一样，因为两个操作对应的分别是图片与文字text组件。\n从这里就可以看出来，两者并没有合批。帧调试器会显示摄像机一步一步的绘画过程，所以说我们可以从这个组件间接得出是否合批。\n&nbsp;\nProfiler-UI\n和帧调试器的路径是一样的\n\n似乎unity5以上的版本调试不出？这里先标记吧\n//更新——后来在实际测试情况中调出来了//\n总之无法合批的原因就是贴图不一样\n&nbsp;\n实验与结果\n首先在刚刚建立的项目中去除光照、取消天空盒、取消HDR与MSAA。\n还是那两个UI块，结果如下：\n\nBatches值为2\n\n\n帧调试器中只出现一个Draw Mesh\n\n种种现象表明，两个色块合批了。\n&nbsp;\n于是加入text组件，位置如下：\n\n发现Batches值为3，很显然text组件和普通图片的贴图并不一样，所以没有合批\n\n&nbsp;\n移动一下Text位置：\n\n发现Batches值变为4\n\n\nDraw Mesh也变为三个\n\n&nbsp;\n众所周知Unity的渲染顺序是由对象层级来决定的，在上面的会优先渲染。而Text的摆放位置似乎会影响到两个图片的合批，就好像“打断”了他们的合批一样。\n这个就涉及到UGUI的合批规则了。\n&nbsp;\nUGUI合批规则\n\n两个UI控件能合批的基本条件是这两个控件使用的材质球(Shader)和贴图要完全相同。\n合批是以Canvas为单位，不同的Canvas是另一个批\n计算深度\n\n\n参考CSDN@WangShade的计算方法\n按照Hierarchy中从上往下的顺序依次遍历Canvas下所有UI元素\n对于当前的UI元素CurrentUI\ni.如果CurrentUI不渲染，则Depth = -1\nii.如果CurrentUI要渲染，但CurrentUI下面没有其他UI元素与其相交，则Depth = 0\niii.如果CurrentUI要渲染，下面只有一个UI元素(LowerUI)与其相交，且CurrentUI与LowerUI可以合批(材质和贴图完全相同)，则CurrentUI.Depth = LowerUI.Depth；如果两者不能合批，CurrentUI.Depth= LowerUI.Depth + 1\niv.如果CurrentUI要渲染，下面有n个元素与其相交，则按照步骤iii，分别计算出n个Depth(Depth_1、Depth_2、Depth_3…)，然后CurrentUI.Depth取其最大值，即CurrentUI.Depth = max(Depth_1, Depth_2, Depth_3，…)\n上面步骤中的“下面”和“相交”要明确下意思，这两个概念很重要。\nCurrentUI下面的UI，指Hierarchy面板中，在CurrentUI之上的元素。\n————————————————\n版权声明：本文为CSDN博主「WangShade」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/sinat_25415095/article/details/112388638\n\n这里我理解的并不是很深，详细可以看原文解释。\n注意“下面”指渲染层次，也就是说在监视器中“下面”指组件“上面”的组件\n\n总而言之，合批根据Depth来列出一个List，再根据这个List来计算合批，这个时候并不是完全依靠监视器中的List顺序来进行解释。就像上面展示的，由于Text组件与其他两个组件相交，Text“下面”是其中一个图片，所以Text深度为1，这样一来Text“上面”的图片深度就为2了，所以三个组件都不为一个批次。\n（可以自己试一下将三个组件覆盖进行改变，可以得出不一样的结果）\n&nbsp;\n优化实操\n总结如下：\n\n使用图集，将多个小图打包到一个大图中来减少内存占用，合并到一个纹理。\n动静分离——减少更新次数\n优化UI结构，防止合批中断\n\n\n&nbsp;\n现在进入最近比赛的项目中尝试进行优化。\n\n游戏还未启动，发现Batches次数已经达到惊人的22层，哪怕只是一个体量非常小的游戏。在运行时跳到30左右。\n\n四个元素给干出9个批出来，恐怕是动态血量造的孽。//后面发现随时间会越来越多。。但是我并不确定这个与时间有没有关系\n\n帧调试器界面，发现瓦片地图渲染了十多次。\n&nbsp;\n开始优化\n首先将金币与生命值划为一个图集\n\n发现PlayerUI中批次直接减少了一次\n\n关于血量的问题出在血量条上，这个原素材是用Package里面的，所以设置图集直接闪退炸了，另一个UI由于图片太多出于实验目的暂时不优化，与此同时可以看见帧调试器中的Draw Mesh也少了一次。\n\n地图划为一个图集后也显著降低了很多批次。\n这里也可以直接将地图划分为静态来启用静态批处理\n\n\n图中的15只是因为刚好地图中出现了怪物而对照组中未出现，所以理论上比15还要小很多。\n做的时候发现地图不能完全合到一个批次，怀疑是地图编辑问题导致合批中断。\n初步优化先到这里，虽然说小游戏还看不出优化效果，但是从面板上看还是很有成就感的。\n\n&nbsp;\n&nbsp;\n提高：GPU Instancing\nUnity5.4版本之后的新黑科技（虽然说对于现在已经不算什么新货了）\n对于静态批处理，需用占用系统大量内存，而对于动态批处理，有时候合批需求过多的情况下动态批处理的做法反而得不偿失，而GPU Instancing可以通过对单个实例进行渲染多个网格对象从而进行大批量相同材质和网格的对象渲染。\n可以理解成需要进行大批量相同物件的渲染时，进行GPU Instancing可以避免静态批处理造成的内存损耗，相对来说便减少了渲染时间。\n当然物件也可以显示不同属性，例如大型森林可以对树木进行缩放或者颜色改变来控制每个对象的独有性。\n&nbsp;\n使用\n新建材质/在已有材质上-&gt;在监视器中选择“启用GPU实例化”-&gt;挂载该材质到预制体上\n\n此时在Unity3D中大量实例化该预制体\n\n这里处理得有点糙，天空盒等一系列没有预处理，所以才是4\n\n&nbsp;\nGPU Instancing再深入就是shader相关了，或者一些属性设置，这些留着以后做demo再说吧（如果有机会）\n&nbsp;\n\n","categories":["Unity基础概念"]},{"title":"UMG与Slate","url":"/2024/11/15/UMG%E4%B8%8ESlate/","content":"\n\n\n\n\n11.7Slate细节\n\nUE UMG Slate 详解\numg是umg，slate是slate，但是slate是umg的爹，umg拿着爹给的资源包装一下，就成了显示在HUD上的用户界面\n\n比如UButton（umg），里头就有SButton（Slate）的引用，用的就是SButton的逻辑。\n如果单看编辑器本身，那么编辑器用户界面基本上都是Slate，有一个理由是编辑器需要提供给用户，游戏引擎的用户界面有一部分是需要频繁改变的，比如UI编辑器，是用户自定义给玩家的UI界面，另一部分是大体固定的，比如一个类的细节面板，如果这个类属性标签上有蓝图可使用，那么这个属性在细节面板上就会多一个属性名，一个输入框，以及可能的一些其他周边按钮比如撤回按钮。\nSlate的结构看起来是很扯淡的，比如：\n\tTSharedPtr&lt;SVerticalBox&gt; TempWidget;\n    Widgets[3]-&gt;AddSlot()\n    .AutoHeight()\n    [\n        SAssignNew(TempWidget, SVerticalBox)\n        + SVerticalBox::Slot()\n        .AutoHeight()\n        .Padding(0.f, 0.f, 0.f, 0.f)\n        [\n            Showing[4]-&gt;CreatePropertyValueWidget()\n        ]\n        + SVerticalBox::Slot()\n        .AutoHeight()\n        [\n            SNew(SExpandableArea)\n            .AreaTitle(NSLOCTEXT(&quot;DetailCustomization&quot;, &quot;Open&quot;, &quot;Open&quot;))\n            .InitiallyCollapsed(true)\n            .BodyContent()\n            [\n                VerticalBoxEx\n            ]\n        ]\n    ];\n\n给哥们干哪去了，这还是C++吗。\n而且一个更重要的是，这些都是写死的代码，都是写死的组件引用，能不能轻易实现动态的组件还另说，光是更改界面需要重新编译就够吃一壶了。\n总而言之就是Slate不属于UObject系统，他是基于web的方式来渲染UI的，SlateCore 负责UI逻辑和布局， SlateRHIRenderer负责UI的渲染。所以Slate当然不和蓝图系统坐一桌，但是UMG和蓝图绑定地死死的，毕竟UMG对Slate进行了包装，将SButtom包装成UButtom。\nHUD 与 UMG 概念\n细节面板、引擎工具栏、窗口栏由Slate实现，现在窗口里头有一张画布，画布上可以添加按钮，也可以添加其他UI，还能添加事件脚本，这个可以快速创建新UI的编辑器就是UMG。\nHUD也是用户界面，但是他一般情况下特指不能互动的提示关键信息的UI，比如屏幕左上的血条，网络的ping值等，或者编辑器的性能面板也属于HUD，当然，UMG也可以将其制作的UI嵌入HUD。\nUWidget与SWidget\nUWidget是WidgetBlueprint里的可视化编辑控件，是向UObject暴露的，所以自然和蓝图系统有所联系.\nUWidget内有TakeWidget函数将SWidget转换成UWidget，函数内部逻辑就是将RebuildWidget调用了一次。\nRebuildWidget被SWidget里所有的组件都重写了一遍，比如说UButton\nTSharedRef&lt;SWidget&gt; UButton::RebuildWidget()\n&#123;\n    MyButton = SNew(SButton)\n        .OnClicked(BIND_UOBJECT_DELEGATE(FOnClicked, SlateHandleClicked))\n        .OnPressed(BIND_UOBJECT_DELEGATE(FSimpleDelegate, SlateHandlePressed))\n        .OnReleased(BIND_UOBJECT_DELEGATE(FSimpleDelegate, SlateHandleReleased))\n        .OnHovered_UObject( this, &amp;ThisClass::SlateHandleHovered )\n        .OnUnhovered_UObject( this, &amp;ThisClass::SlateHandleUnhovered )\n        .ButtonStyle(&amp;WidgetStyle)\n        .ClickMethod(ClickMethod)\n        .TouchMethod(TouchMethod)\n        .PressMethod(PressMethod)\n        .IsFocusable(IsFocusable)\n        ;\n\nif ( GetChildrenCount() &amp;gt; 0 )\n&#123;\n    Cast&amp;lt;UButtonSlot&amp;gt;(GetContentSlot())-&amp;gt;BuildSlot(MyButton.ToSharedRef());\n&#125;\n\nreturn MyButton.ToSharedRef();\n\n}\n\n这是SWidget相关继承图\nSPanel中需要添加一系列的Slot（插槽）结构来进行UI布局编写，Overlay的意思是没有预定布局，所有后渲染的直接覆盖前渲染的，所以布局位置大小都需要自定义，BoxPanel指预定布局，比如说从垂直方向或者水平方向顺序放置Slot组件。\n看一下FSlot的重载：\nFSlot&amp; operator[]( TSharedRef&lt;SWidget&gt; InWidget )\n&#123;\n    SBoxPanel::FSlot::operator[](InWidget);\n    return *this;\n&#125;\n\n这下知道为什么Slate要用[]来写了，[]内返回SWidget组件，这样就可以用比如ChildSlot[SNew(...)]的方式为其添加子SWidget。\n再看BoxPanel初始化宏\n#define SLATE_SUPPORTS_SLOT( SlotType ) \\\nTArray&lt; SlotType* &gt; Slots; \\\nWidgetArgsType&amp; operator + (SlotType&amp; SlotToAdd) \\\n&#123; \\\n    Slots.Add( &amp;SlotToAdd ); \\\n    return *this; \\\n&#125;\n\n也是重载了+当初Add函数。\n然后就是最后一个和C++不太熟悉的点号\nSLATE_BEGIN_ARGS( SButton )\n    : _Content()\n    , _ButtonStyle( &amp;FCoreStyle::Get().GetWidgetStyle&lt; FButtonStyle &gt;( &quot;Button&quot; ) )\n    , _TextStyle( &amp;FCoreStyle::Get().GetWidgetStyle&lt; FTextBlockStyle &gt;(&quot;NormalText&quot;) )\n    , _HAlign( HAlign_Fill )\n    , _VAlign( VAlign_Fill )\n    , _ContentPadding(FMargin(4.0, 2.0))\n    , _Text()\n    , _ClickMethod( EButtonClickMethod::DownAndUp )\n    , _TouchMethod( EButtonTouchMethod::DownAndUp )\n    , _PressMethod( EButtonPressMethod::DownAndUp )\n    , _DesiredSizeScale( FVector2D(1,1) )\n    , _ContentScale( FVector2D(1,1) )\n    , _ButtonColorAndOpacity(FLinearColor::White)\n    , _ForegroundColor( FCoreStyle::Get().GetSlateColor( &quot;InvertedForeground&quot; ) )\n    , _IsFocusable( true )\n    &#123;\n    &#125;\n\n/** Slot for this button&amp;#39;s content (optional) */\nSLATE_DEFAULT_SLOT( FArguments, Content )\n\n/** The visual style of the button */\nSLATE_STYLE_ARGUMENT( FButtonStyle, ButtonStyle )\n\n\n使用了结构化构造，本身就是为属性赋值，比如_ButtonStyle属性，最终赋值到FArguments中，在使用SNew构造时进行传参。\nSlate真没啥用，但是如果有要更改编辑器的需求，那么Slate是真的有用，就像前面说的，UMG管不到游戏单例局外，所以只能通过重写Slate来实现，相对于Unity来说真的是一个很老旧的实现方式。\n生命周期\nUMG基于UObject，而Slate基于TSharedFromThis。\nUMG生命周期也就是UE的UI生命周期，基本上是这几个生命周期函数：\n\nvirtual void NativeOnInitialized();\nvirtual void NativePreConstruct();\nvirtual void NativeConstruct(); ---开始tick\nvirtual void NativeTick();\nvirtual void NativeDestruct(); ---结束tick\n\n\nSlate，都说了是TSharedFromThis，那么生命周期就是由智能指针来管理的。\n一些问答（防止被抓）\n\nSlate中怎么用UMG\nTakeWidget，将UUserWidget转化为SWidget\n如何在UMG里混合使用Slate与UMG\n也就是使用UWidget组件，而RebuildWidget是用来创造SWidget，所以思路是重写它，内容由UWidget来代替\n\n\n//todo一些别的，比如UUserWidget还没概念\n\n","categories":["虚幻引擎系列"]},{"title":"Unity游戏设计模式","url":"/2023/10/26/Unity%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"\n\n\n\n\n10.25目标\n\n单例模式\n懒汉式与饿汉式\nUnity中一般也就懒汉式，因为本来就是单程，很难出现线程不安全\n原理：\n\nstatic静态属性——不会被GC，存在类型对象中而不是实例化出来的对象中\n私有构造函数、私有静态对象、公有静态函数或属性——方便其他对象获取\n\n\n&nbsp;\n不过我在写这篇文章前写的倒是并不像这样规范\npublic class Singleton : MonoBehaviour\n&#123;\n    public static Singleton instance;\n    private void Awake()\n    &#123;\n        instance = this;\n    &#125;\n&#125;\n\n这个单例继承于MonoBehaviour，是挂载在对象上的，在对象初始化的时候便instance=this，意味着这个单例的初始化是挂载到unity的生命周期上的。\n\n&nbsp;\n比较规范化的饿汉式单例模式\npublic class Singleton\n&#123;\n    private Singleton() &#123; &#125;\n    private static Singleton instance;\n    public static Singleton Instance \n    &#123;\n        get\n        &#123;\n            if (instance == null)\n            &#123;\n                instance = new Singleton();\n            &#125;\n            return instance;\n        &#125;\n    &#125;\n&#125;\n\n为什么说是饿汉式，因为没有继承于MonoBehaviour，需要被继承过MonoBehaviour的对象调用过之后才算真正创建了，如果需要线程安全，那就在公有对象的地方加锁，但是其实unity没啥必要。\n\n常在Get区域DontDestroyOnLoad(obj)避免单例被场景变换而销毁\n&nbsp;\n通用单例类\n实际运用过程中其实会用到非常非常多单例类，什么对象池什么商店类什么玩家类，可以把单例操作简化到一个类中来避免重复编写——但其实也没啥必要，看起来更好看罢了\n\nnamespace Common\n&#123;\npublic class Singleton&lt;T&gt; where T : class, new()\n&#123;\n    private static T _instance;\n    private static readonly object syslock = new object();\n\npublic static T Instance\n&#123;\n    get\n    &#123;\n        if (_instance == null)\n        &#123;\n            lock (syslock)\n            &#123;\n                if (_instance == null)\n                &#123;\n                    _instance = new T();\n                &#125;\n            &#125;\n        &#125;\n        return _instance;\n    &#125;\n&#125;\n\n}}\npublic class UseSingleton : Singleton&lt;UseSingleton&gt;\n&#123;\n    public string Name;\n    public int Age;\n&#125;\n\n缓冲池优化（留存？）\n&nbsp;\n事件中心\n观察者模式、事件发布-订阅模式、Unity自带的UnityEvent\n\n游戏游玩过程中会触发非常多的事件，这些事件往往关联非常多的游戏对象与游戏系统，单独其设置逻辑会造成代码的高耦合，例如“让对象A触碰到对象B“会发生一些小事件，这个时候”对象A“与”对象B“与”事件对象“就会形成一个比较尴尬的局面——相互引用。如果两个对象只是单例那可能还算清晰，但更多情况下游戏的事件要么是”击杀n个敌人“这种带有多个实例化对象的事件、要么是”玩家死亡“这种比较单纯的事件等等。。事件错综繁杂而难以理清，暴力地相互引用必然是不正当的做法，这个时候我们需要布置一些”特殊的岗位“来特定地办这一系列事。\n最典型的能描述代码中事件中心的就是游戏的成就系统或者图鉴系统\n&nbsp;\n观察者模式\n在进入正题之前，我们最好先看准我们的需求，然后从需求中一点点迭代到代码规格当中。\n我们首先最需要的，就是实现\n\n当对象发生一些”事件“的时候，不需要去管理自己与其他对象需要做什么。\n\n\n就像玩手机一样，我们身体发出了”肚子饿“的指令，那么我们不需要去特地做饭，而是打开手机点外卖；当我们想要找人聊天的时候，我们不需要特地去朋友家中，而是直接打开聊天软件。。。明明是两者截然不同的的事件，发生的对象也不一样，但我们只需要使用手机（事件系统）就能解决。\n于是从上面的例子我们渐渐有了灵感\n\n当对象发生一些”事件“的时候，只需要向外界发出信息就行。\n\n\n这样的”信息“在C#中，就像生活中各自事件一样，是完全不一样的类型的，我们需要将这些信息，或者说发出信息的对象归并到一个列表当中——Subject，也可以叫做”抽象被观察者“。对应的，Observer就是”抽象观察者“。”对象发出事件让观察者接收“这个事情，完全可以统一归一为“抽象被观察者发出信息让抽象观察者来订阅”。\n\n当观察者接收到信息的时候，需要知道信息的来源\n\n\n“抽象被观察者”需要持有抽象观察者的列表，这样一来就可以让“被观察者”来决定消息发布给谁。而消息要如何发布呢？我们其实完全可以将这个“列表”直接定义为一个接口，然后让程序自己来决定将消息发布给谁，就像面向对象中的多态一样——毕竟一个个定义列表这件事是极其荒谬的。同样，被观察者也需要拥有统一接口——添加观察者，移除观察者，以及通知观察者。\n\n当观察者接收到信息的时候，进行一些事件实现。\n\n\n按照上面的例子，我们可以将“抽象观察者”定义为一个总的接口，然后具体实现由其他观察者来实现，可以理解成面向对象中的“多态”，在具体运行过程中，由程序来决定运行哪一个实现。\n&nbsp;\n这样一来，对象A（抽象被观察者）就不需要进行纷乱繁杂的引用，它直接持有一个抽象观察者列表，并在发起通知时直接遍历抽象者列表中的Update。\npublic class Player : ISubject&#123;\n    private List&lt;IObeserver&gt; observers=new List&lt;IObeserver&gt;();\n    ...\n&#125;\n\n其实做到现在还是抽象太多了，哪怕是我自己，在刚得知这种设计模式时仍然会感到疑惑——这种看起来更麻烦复杂的方式为什么就能解耦呢。\n让我们回到之前的需求中来，我们会发现至少作为一个对象，消息处理机制已经得到了规范——也就是说实现了“发生事件时提供消息”以及“消息到来时调用的方法和对象本身没有关系“\n&nbsp;\n发布-订阅模式\n想要将观察者与被观察者完全解耦，那就必须要设置一个调度中心来统一对”观察者、被观察者、消息“进行管理。\n和之前的玩手机一样的原理：如果你点外卖，那么理论上你和店家是不存在交互关系的，因为你只和外卖平台在进行交互，而店家也只是在处理外卖平台提供的订单通知而已。\n观察者接口：\npublic interface IObserver \n&#123;\n    public void ResponseToNotify();\n&#125;\n\n“调度中心”：\npublic class GameManager \n&#123;\n    //单例模式应用\n    private static GameManager instance;\n    public static GameManager Instance\n    &#123;\n        get\n        &#123;\n            if (instance == null)\n                instance = new GameManager();\n            return instance;\n        &#125;\n    &#125;\n    private List&lt;IObserver&gt; observers = new List&lt;IObserver&gt;();\n    //添加观察者\n    public void AddObserver(IObserver observer)\n    &#123;\n        observers.Add(observer);\n    &#125;\n    //移除观察者\n    public void RemoveObserver(IObserver observer)\n    &#123;\n        observers.Remove(observer);\n    &#125;\n    //发送通知给观察者\n    public void Notify()\n    &#123;\n        for (int i = 0; i &lt; observers.Count; i++)\n        &#123;\n            observers[i]?.ResponseToNotify();\n        &#125;\n    &#125;\n&#125;\n\n玩家死亡的时候：\npublic class NewPlayer : MonoBehaviour\n&#123;\n    void Update()\n    &#123;\n        if (Input.GetKeyDown(KeyCode.J))\n        &#123;\n            GameManager.Instance.Notify(); //触发玩家死亡通知\n        &#125;\n    &#125;\n&#125;\n\n敌人接收事件消息：\npublic class NewEnemy :MonoBehaviour, IObserver\n&#123;\n    private void Start()\n    &#123;\n        GameManager.Instance.AddObserver(this);\n    &#125;\n    private void OnDestroy()\n    &#123;\n        GameManager.Instance.RemoveObserver(this);\n    &#125;\n    public void ResponseToNotify()\n    &#123;\n        print($&quot;&#123;gameObject.name&#125;停止移动&quot;);\n    &#125;\n&#125;\n\nUI接收消息：\npublic class NewGameOverUI : MonoBehaviour,IObserver\n&#123;\n    public void ResponseToNotify()\n    &#123;\n        print(&quot;游戏结束&quot;);\n    &#125;\n    void Start()\n    &#123;\n        GameManager.Instance.AddObserver(this);\n    &#125;\n    private void OnDestroy()\n    &#123;\n        GameManager.Instance.RemoveObserver(this);\n    &#125;\n&#125;\n\n我们会惊喜地发现这种模式确确实实实现了对象只需要发布消息就能得到回馈的功能，而且对象间不需要进行引用，只需要对调度中心进行交互即可，哪怕是不用的观察者也是一样的。\n代码借鉴于观察者模式（结合C#，Unity)_unity 观察者模式-CSDN博客\n\n&nbsp;\n观察者的生命周期\n在上面的例子中，观察者定义了事件发生后的事情，但这个条件是由调度中心全权来操作的。\n按照我们以往的编码流程，“自己的事情自己做”就是理所应当的，所以函数的条件与实现都会放在一起。\n在这个模式中我们将他分开了，那么就有可能会产生一个严重的后果——调度中心尝试操作一个未知状态的观察者。\n毕竟上面流程的代码是没有添加任何安全锁，对于调度中心来说，为了解耦，它甚至不用理会观察者到底是上面，因为他只是不停地在遍历接口列表而已。\n于是我们设想一个很诡异的场景：观察者因为场景变化或者其他因素消失了，但调度中心列表中仍然存在该观察者的接口，于是调度中心一次又一次地按下那个“虚空”操作按钮。。。\n所以最好的解决方案就是将观察者的控制权与其生命周期相匹配——也就是当观察者销毁的时候及时将其移出观察者列表。\n\n在 Awake/Start 方法中把观察者添加到列表中，在 OnDestroy 方法中把观察者从列表中移除。\n在 OnEnable 方法中把观察者添加到列表中，在 OnDisable 方法中把观察者从列表中移除。\n\n\n&nbsp;\nUIManage\n&nbsp;\nDOTween\n&nbsp;\n&nbsp;\nUI的状态栈\n&nbsp;\n&nbsp;\n面向对象设计原则\n&nbsp;\n\n","categories":["Unity基础概念"]},{"title":"UnrealC++","url":"/2024/10/01/UnrealC/","content":"\n\n\n\n\nUnreal C++\n\nUnreal C++\n&nbsp;\n命名规范\nAActor派生的类以A开头、UObject派生的类以U开头、枚举以E开头、接口以I开头、模板类以T开头、SWidget派生的类以S开头、其余类以F开头。\n&nbsp;\n容器\n&nbsp;\n标准C++\n\nchar/short/int/long/float/double\n\n\nUEC++\n\nint8/int16/int32/int64/float/double\n\n\n&nbsp;\n字符串\n\nFString——类似C++中的String，含有多种字符串操作方法，能被修改，可多次存储。\nFName——表示字符串标识符的类，通常用于在代码中唯一标识对象、变量、函数等。无法修改、大小写不敏感、查询对比快。只是一个全局名字表的索引。\nFText——处理本地化文本的类，可以理解为“要被显示”的字符串，UE中有内置的本地化支持。\n\n\n&nbsp;\n容器\n\nTArray——std::vector\n\nAdd——插入数组尾部\nClear——清除\nLength——返回个数\n\n\n\nTMap——std::map\n\nAdd\nClear\nContains——根据键查找是否存在键值对\nFind——根据键返回值\nKeys——找出所有键\nLength——返回键值对数量\nRemove——根据键去除一个键值对\nValues——找出所有值\n\n\n\nTSet——std::set\n\nAdd\nClear\nLength\nRemove\n\n\n\n\n\nUE4常用，且支持反射系统\n\n&nbsp;\n反射\n首先理解一下反射这个词意味着什么。\n反射是指程序在运行时动态获取对象属性与方法的一种机制\n\n这一句用来描述广义上的反射是没有任何问题的，从技术定义上讲，反射就是用来解决运行时调控程序运行的一种方式，不过在不同的应用场景中，反射具有不同的解释。\n对于游戏开发来说，反射更适合这样的定义。\n反射是运行时动态获取属性、调用方法、序列化与通信的基础，也可为开发者提供运行时获取类型信息、使用脚本语言编写逻辑并较为方便地与宿主引擎通信的能力\n\n&nbsp;\n对于游戏开发er来说，理解反射，获取反射相关知识之前先默认都熟悉某引擎，至少使用过相关引擎做过一些demo。\n那么肯定会对这个场景很熟悉：\n\n在场景中拉入一个角色，感觉角色的血量需要调整，于是在编辑器里甚至在游戏运行过程中动态调整血量的最大值。\n\n\n这个血量包括任何可能需要调整的数据，包括obj的transform等等一系列属性。\n这是一个最为常见的场景，也是游戏引擎需要实现的最为基础的功能了。\n你也可以在代码中直接设置数据，但是这样做很明显十分麻烦，因为数据肯定是一个需要实时调整的值，所以引擎需要实现不动代码的情况下去对一些数值进行设置，这样再简单不过的一个动作本身其实涉及了很复杂的反射系统。\n曾经对反射系统长期感到困惑，因为没有意识到引擎运行本身就是程序在运行，错把“游戏开始”和“引擎开始”搞混了。\n\n也正印证了反射的定义——满足“动态”获取对象属性方法等一系列需求。\n&nbsp;\n其他应用场景\n游戏引擎在反射上的获益其实非常多，只不过大部分都在程序员不知不觉中完成了。\n\n蓝图属性映射C++属性，修改蓝图属性引用到运行时。\nSocket数据包的序列化与反序列化。\n调用Lua方法，Lua代替蓝图逻辑，Lua调用C++方法。\n运行时动态加载库。\n根据字符串找到类。\n.......\n\n\n&nbsp;\n实现思路\n1、在程序打包之前，将程序中相关类信息、类中属性信息、属性类型、成员函数信息等等以元数据的方式存储下来。\n元数据：描述数据的数据\n\n2、初始化类之前利用元数据生成了类型对象，这个类型对象包含实现实例对象反射的一系列方法，也包含了一些其他方法。\n3、实例化实例对象，一个类型的所有实例对象都含有一个指针指向唯一的类型对象。\n几乎所有的具有反射功能的语言实现反射都是用的这一套思路，一般的文章介绍到这里也就结束了，这里直捣黄龙把反射实现具体功能的一套流程都整理出来。\n以上面说的动态调整属性为例：\n4、选中相应对象后，绘制器可以直接获取到这个对象所代表的类的标识，并通过这个标识在元数据中查到这个类的相关信息。\n5、通过类信息获取到这个类的对象，也就是当前操作对象，绘制器直接将这个类（组件）的所需要打印的属性打印出来。\n6、获取到对象的属性后，即可以实时通过反射实时更新这个对象的属性了。\n对于UE来说，可以通过UObject的GetClass来获取某类的实例，这个是通过直接存储这个类实例的指针来做到的。不同语言都会有一个类似的直接获取到实例的方式，不过会有一定限制条件，例如至少要先获取到类信息才能获取到具体对象。\n对于反射来说，反射本身也包装了一套获取实例的方式，例如java中的Class AClass = A.class;本身就运用反射获取到了A的类信息，然后底层可能就调用了类似GetClass的方法获取到了类实例对象。\n在UE中，针对继承自 UObject 的类，可以通过 GetClass() 来获取 UClass 实例，但是如果想直接获取某个类型的 UClass，则可以通过 StaticClass&lt;UObject&gt; 或者 UObject::StaticClass() 来获取。\n\n&nbsp;\n原因\n写这篇文章的时候是2024年，Java、C#都早早实现了官方的反射功能，早些年为了让可执行文件足够“小”，编程时不会想着使用额外的内存空间将类的相关信息提前存储好，毕竟C++的结构体满足可以无需序列化直接传输的功能。\n不过C++结构直接传输是不易读的，随技术发展，网络带宽与硬件内存限制不再是问题，这个时候的主要矛盾是数据需要序列化成xml或者json等文件来进行传输。序列化本身是一件比较麻烦的事，所以Java率先实现了反射功能，让类在序列化时可以直接通过类的元数据动态获取类的属性与值，而不需要一个个手动序列化。\nC++到底有没有保存类的信息，作为菜鸟的我不想去追究，但是可以知道的是虚幻引擎为了这个功能直接掀桌手动实现了一整套的C++反射功能，这也是虚幻当中最为重要最为复杂的一个系统了。\n&nbsp;\nUE反射系统流程\n\n标记\n分析\n生成\n编译\n使用\n\n\n&nbsp;\n标记\n也就是标签，对Class前添加UClass标签，对Function添加UFunction标签，让编译器把被标记的内容纳入反射系统中。\n对于文件来说，需要添加include文件。\n#include &quot;FileName.generated.h&quot;\n\nUENUM()、UCLASS()、USTRUCT()、UFUNCTION()、UPROPERTY()\n\n标签本身是一个空宏，仅提供标记功能，实际并不影响原代码编译过程。\n&nbsp;\n分析\nhttps://zhuanlan.zhihu.com/p/89220125\n我们要知道，我们写的UE4代码不是标准的C++代码，是基于UE4源代码层层改装了很多层的（如反射），所以，UHT将UE4代码转化成标准的C++代码，而UBT负责调用UHT来实现这个转化工作的，转化完以后，UBT调用标准C++代码的编译器来将UHT转化后的标准C++代码完全编译成二进制文件，整体上看，UHT是UBT的编译流程的一部分。\n\nUBT（UnrealBuildTool），管理编译配置调用编辑器来编译UE代码。如果任意一个头文件从上一次编译起发生了变化，就会调用UHT。\nUHT（UnrealHeaderTool），解析UE代码。\n标记本质上是一个宏，在分析阶段被替换成反射相关函数（todo）。\n&nbsp;\n生成\n生成含反射数据的C++代码(头文件.gen.cpp)\n生成各种帮助函数以及thunk函数(头文件.generated.h)\ntodo，，，\n&nbsp;\n编译\n生成的代码与源代码一起被编译，这个时候可以将类信息收集在二进制文件中。\n&nbsp;\n内存池分配\nBinned/Binned2，和C++内存管理类似。\n参考：C++内存管理 | Coding中。。。 (jiuriri.com)\n&nbsp;\n垃圾回收\n常用的垃圾回收算法：\n\n标记清除\n引用计数\n保守式GC\n\n\n&nbsp;\n标记清除\n分为标记、清除、合并三个阶段。\n在垃圾回收中，被引用的对象被视为“有用的”对象，没有被任何对象引用的叫做“不可达”对象。\n不可达对象也就是需要被清除的对象。\n标记阶段会从根对象开始，寻找根对象的引用并对引用对象进行标记，这个算法会遍历所有的被标记的对象寻找该对象的引用并做上标记，不断增加标记的对象的数量。直到所有该遍历的对象都被遍历完时遍历停止，此时剩下没被标记的对象就称作不可达对象。\n清除阶段会直接从整个堆开始遍历所有对象，如果遍历到没有标记的对象，就将它回收，并将这块空间连接到另一个“空闲链表”中。\n合并阶段就是在清除阶段中，如果发现某两块回收的内存是连续的，则将他们进行合并成一个大内存。当有对象需要分配内存时，遍历空闲链表，寻找到合适大小的块进行分配。\n\n优点：实现简单，就地GC\n缺点：容易生成碎片块，分配速度慢\n改进：多个空闲链表记录不同大小的块，根据对象大小进入不同的分块中，可以加快查找时间；把堆区分成不同大小的区间，每一个区间内只存有相同大小的块，对象直接更具大小匹配不同区间，提高内存使用效率。\n\n\n&nbsp;\n引用计数\n额外分配内存块为每个对象存储有哪些对象引用了自己，当引用数为零时，即刻回收对象内存。\n\n优点：即刻回收，不需要等待GC判断；不需要遍历链表\n缺点：计数器频繁计算占用CPU效率；占用额外空间；实现复杂；循环引用无法回收\n改进：延迟引用，只记录引用数的变化存在某表中而不立即计算他，待到一定条件的时候去遍历变化表来释放0引用内存；减少计数器位数，哪怕数量溢出也不管他，把他剔除引用技术的GC体系，可以考虑等待利用标记清除来GC他。\n\n\n&nbsp;\nGC复制算法\n把有效的对象全复制到另一块内存当中，然后清除原内存的所有对象，这样不会产生碎片，遍历次数也少，具体就不展开了。\n&nbsp;\nUE中的GC利用的是标记清除算法\n\n&nbsp;\n智能指针\n减轻内存分配和追踪的负担\n\n\nTSharedPtr\nTUniquePtr\nTWeakPtr\nTSharedRef(和TSharedPtr的唯一区别就是不能为空)\n\n\n虚幻引擎的智能指针库不能与UObject系统同时使用。——UObject本身就配置了GC\n和标准C++智能指针不同的是配备了枚举类ESPMode来控制智能指针是否线程安全。\nTSharedPtr&lt;int, ESPMode::ThreadSafe&gt;\n使用Reset()来重置指针，原来的内存不一定会立即析构，重置共享指针，会影响到所有指向它的弱指针。\nUE自己实现一套指针的原因：\n\n保证智能指针类型方法和名称与UE代码体系标准一致，其他容器无缝协作\n可选的线程安全，保证性能，具有灵活性\n\n\n\nweaptr补充：\n进程控制块内有sharedcount也有weakcount，sharedcount为0时对象析构，但只有sharedcount与weakcount同时为0时，进程控制块才能释放。\nweakptr没有访问对象的能力，只用使用lock来将其转化为sharedptr，如何对象已经销毁，则返回一个空sharedptr。\n\nTSharedRef必须要指向一个非空对象，必须初始化。\n\t所以它不需要有Reset和Isvalid。其他特征和TSharedPtr一模一样。\n\t使sharedptr的使用更加方便化，比如由于sharedptr可能为空，所以得多做一步判空。\nTUniquePtr的赋值拷贝构造函数被delete标记，只能通过MoveTemp转移内存所有权。\n&nbsp;\n方法\n\nMakeShard/MakeUnique：对于进程控制块，一次性将其与对象需要的空间申请出来，而不是正常情况下的分两次。\nMakeShareable：将一个普通指针转换为智能指针\n\n\n\nTSharedFromThis：允许类的对象能够在自身成员函数中安全地创建 TSharedPtr 指向自身，使用时类需要继承TSharedFromThis&lt; T&gt;，在类中一般定义方法来调用AsShared()来返回出去。\n\n当一个类对象希望将自身以 TSharedPtr 的形式传递给其他对象或系统。\n当需要确保对象在其他地方仍有引用时不会被意外销毁。\n\n\n\n\n\n\n","categories":["虚幻引擎系列"]},{"title":"Unity/UE/C++","url":"/2024/11/15/Unity-UE-C/","content":"\n\n\n\n\n1022例行八股复盘\n\nUE的Actor与Unity的GameObject有什么区别？\n两者都是通过Component的组件架构形式来进行游戏对象功能上的搭建，可以说两者都是两个引擎“基础游戏对象”的一个概念。\n从继承角度上讲，Actor的继承层次比GameObject复杂得多，比如有掌管数据相关的无实体Actor子类AInfo，也有表示在游戏场景中的实体Pawn，如果向做一个人型的Actor，还需要继承对象Pawn的Character对象。而在Unity中很少会听说有继承GameObject类的情况出现。\n从功能角度上讲，Actor自带一个网络复制功能，虚幻引擎也可以自动处理网络延迟和丢包，而GameObject需要以Component的形式加额外组件并利用外部网络框架才行。\n从更新角度上讲，Actor是直接参与Component的tick流程的，因为Actor自己也有一些功能逻辑需要tick实现，在调用完component的tick之后，就会调用Actor的tick，而Unity的GameObject不具有类似tick的update流程，component的update直接由mono生命周期托管。\n构造函数初始化列表\n为什么使用？因为类中有常量类型的数据成员、引用类型的数据成员，这样的数据只能进行初始化而不能赋值，非初始化列表的方式是以赋值的方式来进行初始化的。其次存在无默认构造函数的内嵌对象的情况。\n(内嵌对象的)构造函数只能在(组合类的)构造函数的初始化列表中调用，不能在(组合类的)构造函数体中调用。\n因为编译器规定了子类以及成员类的构造函数会在本类的构造函数调用后自动调用，所以不能在函数体中重复进行调用。\n\n主要问题是编译器在默认情况下只会调用内嵌对象的默认构造函数，因为这个函数没有参数。\n如果要调用这个对象的有参构造函数，又不能在构造函数的函数体中调用，所以只能在初始化列表中显示调用构造函数来传递参数。\n#include &lt;iostream&gt;\nusing namespace std;\n \nclass Base&#123;    public:        Base(float xx, float yy) : x(xx), y(yy)        &#123;            cout &lt;&lt; &quot;Constructor of Base&quot; &lt;&lt; endl;        &#125;    private:        float x, y;&#125;;\nclass Derived : public Base&#123;    public:        Derived(float xx, float yy) : Base(xx, yy)        &#123;            cout &lt;&lt; &quot;Constructor of Derived&quot; &lt;&lt; endl;        &#125;&#125;;\nint main(int argc, char **argv)&#123;    Derived d(0, 0);\nreturn 0;\n\n}\n单例模式和静态类\n首先从原理上分析，静态类是在程序开始时立马初始化的，而单例类可以实现延迟初始化，也就是懒汉模式。由此看单例模式在这方面上有很大的自主性，可以定制一些需求。\n再从功能角度上，单例类可以实现多态，也就是可以提前写一个模板单例，而静态类只能提前制定一个具体的单例。\n\n","categories":["面试查漏补缺"]},{"title":"Unity中的C#脚本","url":"/2023/06/27/Unity%E4%B8%AD%E7%9A%84C-%E8%84%9A%E6%9C%AC/","content":"\n\n\n\n\n脚本概述\n\n脚本概述\nunity中的脚本定义了对象运行的逻辑，包括用户输入、游戏事件等。脚本的本质是新创建组件，在unity内置组件无法完成应实现的功能时，脚本文件为其提供补充。通常所说的“unity编程”或者说“C#编程”，其实本质就是编写脚本。\n创建脚本时，系统会自动在脚本中创建一个由MonoBehaviour的内置类派生而来的类，此类包含一些用于链接unity内部架构的函数，此外，类名和文件名必须相同才能时脚本附加到游戏对象中\n新建的脚本默认文件如下：\nusing UnityEngine;\nusing System.Collections;\n\npublic class NewBehaviourScript : MonoBehaviour &#123;\n// Use this for initialization\nvoid Start () &#123;\n\n&#125;\n\n// Update is called once per frame\nvoid Update () &#123;\n\n&#125;\n\n}\n其中，Start()函数就类似于构造函数，用于对对象的各种变量进行初始化。\n而Update()用于放置具体的实现代码，用于游戏对象的帧更新，包括移动等。\nStart()函数在组件激活时调用，所以适用于初始化，Update()每一帧都会调用，所以适用于帧更新\n此外，还包括Awake()最早调用函数，FixedUpdate()固定频率调用函数，OnDestroy()销毁时调用函数等等等等，不过初学者可以先只关注Start于Update\n\n如果有没用到update的情况，那么最好及时删除，因为空调用update也会造成一定开销\n以上函数，统称为脚本的“生命周期方法”\n&nbsp;\nDebug命令\n可以在start函数中添加以下代码：\nvoid Start () \n&#123;\n    Debug.Log(&quot;Hello world!&quot;);\n&#125;\n\nDebug.Log()用于将消息输出到Unity控制台，作用是检测对象是否正确初始化，若成功，则在窗口底部打印Hello world\n此外\nDebug.Lob(String str)也用于标准输出\nDebug.LogWarning(object obj)用于输出警告信息\nDebug.logWarning(object obj)用于输出错误信息\n\n//等等，unity中的Debug命令还有很多很多。。。。//\n&nbsp;\n变量\n类似C++中的调试，Inspector作为一个变量查看器，只能查看声明为public的变量\nUnity 实际上允许您在游戏运行时更改脚本变量的值。此功能很有用，无需停止和重新启动即可直接查看更改的效果。当游戏运行过程结束时，变量的值将重置为按下 Play 之前所处的任何值。这样可确保自由调整对象的设置，而不必担心会造成任何永久性损坏。\n&nbsp;\n脚本执行顺序\n单个脚本中存在一个隐含的生命周期函数执行顺序Awake()-&gt;OnEnable()-&gt;Start()-&gt;Update()\nOnEnable()是一个每次激活脚本都会调用一次的方法\n\n理论上每个脚本会严格按着这个顺序调用方法，所以在执行简单的脚本程序时，初始化的语句放在Awake()或者Start()中都是可行的。不过当一个对象中运行多个脚本时，具体的调用顺序就会变成逐个执行每个脚本的优先方法，所以说如果有非常紧急的事务，可以直接放在最优先的Awake()方法\n此外，可以在Unity中自行设置全部脚本执行顺序方法\n&nbsp;\n脚本组件与对象\n在官方的Unity文档中，对象的数据更改定义了有两种方式\n\n一是通过Inspector来更改属性，这种方式相当于为脚本提供一个更方便的接口，Inspector窗口直接放在脚本内容下，游戏窗口旁边，在调试过程中动动手就能更改，十分方便：\n\n\n\n详细解析如下\n\n在具体的脚本代码中，public的变量都会自动显示在Inspector中并随时提供更改，如果要显示private变量，那么就在前面增加一行[SerializeField]\n[SerializeField] private LayerMask _groundLayer;\n[SerializeField] private int _detectorCount = 3;\n[SerializeField] private float _detectionRayLength = 0.1f;\n\n如上对应图片中COLLSION项以下部分变量，而如果要增加像图片中的小标题，则用以下格式：\n[Header(&quot;COLLISION&quot;)]\n\n拖动条的代码如下（其实就是增加了Range关键字）：\n[SerializeField] [Range(0.1f, 0.3f)] private float _rayBuffer = 0.1f;\n\n此外，还有[Space]关键字用于隔行，[HideInInspector]关键字用于隐藏不想显示在面版中的变量\n&nbsp;\n\n二是通过脚本自身定义方法来对游戏对象进行数据操控，这种方式最为常用，因为这种方式可以在游戏运行时进行，并能响应用户输入，以用于完成例如游戏对象摧毁等任务\n\n\n&nbsp;\n游戏对象内组件的访问\n游戏对象内的多个组件往往需要相互交流，例如经典格斗游戏中跳跃时与站立时同一个招数是不同效果的。\n组件就是类的实例，所以第一步是获取所需要组件的实例引用，使用GetComponent函数来完成\nvoid Start () \n&#123;\n    Rigidbody rb = GetComponent&lt;Rigidbody&gt;();\n&#125;\n\n这个例子中，用Rigidbody声明的变量rb来储存实例引用游戏对象刚体组件，尖括号意思是引用该类型的所有引用\n根据官方文档提示，带有类型的的访问是最优于性能的（这里先排除一些某类型用不了的情况），所以这里先只使用这种方式，其他重载仅限了解即可:\n\nGetComponent()\nGetComponent(typeof(T))\nGetComponent(string)\n\n\n引用过后，我们就可以通过这种方式来访问相应变量辣\n rb.mass = 10f;\n\n另外，还可以直接调用引用实例的函数，这是Inspector中所没有的\n若未找到相应引用，则该函数返回NULL，这会导致主要开销\n&nbsp;\n游戏对象间的组件访问\n一个玩家需要知道另一个玩家的位置，这种情况经常发生，尽管对象经常孤立运行，但对象是没有隐私的。\n现在直接public一个游戏对象变量\npublic class Enemy : MonoBehaviour\n&#123;\n    public GameObject player;\n    \n// 其他变量和函数...\n\n}\n这个变量的类型是游戏对象，它甚至可以在Inspector中显示出来。于是乎这个变量成为一个接口，一个用于操控其他目标对象的接口\n你可以直接拖拽将想要的对象对接给他，也可以在Inspector里面调，哪样都行\n对接上后就可以直接通过变量.这样的方式来直接调用了。同样的，这个“对接”过来的变量也可以被GetComponent函数引用\n此外，如果在脚本中声明组件类型的公共变量，则可以拖动已附加该组件的任何游戏对象。这样可以直接访问组件而不是游戏对象本身\npublic Transform playerTransform; \n\n小tips：GameObject是Unity的一个关键类，Transform是GameObject属下的一个脚本API，掌管物体的大小位置旋转等信息\n\n以上是游戏组件对象的最基本运行逻辑，以下介绍批量化处理方法\n&nbsp;\n子游戏对象\n从以上方式中可得知，每进行一次对象间的信息链接，就要重新声明一个对象变量，但游戏对象往往是批量化的，如果我们删除一个对象，那么引用这个对象的相关变量都要一个个删除，十分麻烦。\n所以我们使用子游戏对象的概念来管理游戏对象\nusing UnityEngine;\n\npublic class WaypointManager : MonoBehaviour &#123;    public Transform[] waypoints;\nvoid Start() \n&#123;\n    waypoints = new Transform[transform.childCount];\n    int i = 0;\n    \n    foreach (Transform t in transform)\n    &#123;\n        waypoints[i++] = t;\n    &#125;\n&#125;\n\n}\n示例创建数组来对子游戏对象进行储存，方法对各个对象遍历，有意思的是与C++比起来C#的数组声明的尖括号居然是放在类型后面的，另外，查找子对象的可以使用Teansform.Find函数（记得加双引号）\n在场景层级视图中查找任意可以识别的对象，可以用GameObject.Find\n\n&nbsp;\n时间和帧率管理（子弹时间的实现）\n//待补充//\n&nbsp;\n&nbsp;\n\n","categories":["Unity基础概念"]},{"title":"lua快速入门","url":"/2024/02/25/lua%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"\n\n\n\n\nLua快速入门\n\nLua快速入门\n变量\nlua中声明变量不需要事先声明，只需要直接赋值一个变量\na=1\nb=2\na,b=1,2\n\n这两个变量默认全局变量，除非\nlocal a=1\n\n这样，在别的文件中就不能使用了——变为局部变量\n&nbsp;\nnil\n指没有被声明过的变量，类型为nil，如：\nprint(c)\n\n其实c并没有被声明，则输出打印为nil\n&nbsp;\nnumber\n类型c中的int，float等等，在lua中统一为number类型（支持16进展、科学计数法。。。）\n&nbsp;\n运算符\n+、-、*、/、^、左移右移等\n&nbsp;\n字符串\n使用“”或者‘’都视为字符串,支持转义字符\na=&quot;123&quot;\nb=&#39;123&#39;\n\n另外，使用双中括号保证字符串原始值\nc=[[123/n123]]\n\n字符串链接使用两个点\nc=a..b\n\n转换(失败输出nil)\nc=tostring(10)\nn=tonumber(&quot;abc&quot;)\n\n字符串加井号输出长度\nprint(#a)\n\n&nbsp;\n函数\nfunction function_name(函数参数)\n    --body\nend\n\n–或者\nf &#x3D; function(函数参数)    –bodyend\n返回值默认为nil,支持一次性返回多个值\nfunction f(a,b,c)\n    return a,b\nend\nlocal i,j = f(1,2)\nprint(i)\nprint(j)\n\n&nbsp;\ntable\na=&#123;1,&quot;ac&quot;,&#123;&#125;,function() end&#125; --类似c中的数组，但不一样的是第一个下标为1\na[5] = 123 --赋值第五个元素，否则第五个元素为nil\nprint(#a) --打印table下表\ntable.insert(a,&quot;d&quot;) --插入\ntable.insert(a,2,&quot;d&quot;) --从第二个位置插入，后面的往后移一位\ntable.remove(a,2) --移除特定位置元素且返回\n\n字符串下标table\na=&#123;\n    a=1,\n    b=&quot;1234&quot;,\n    c=function()\n        end,\n    [&quot;,;&quot;]=123\n&#125;\nprint(a[&quot;,;&quot;]) --读出a与[&quot;,;&quot;]的值\na[&quot;abc&quot;]=&quot;abcd&quot; --声明特定下标\n\n&nbsp;\n全局表\n特殊的table\n\n称为_G，用于存储所有全局变量\na=1\nprint(_G[&quot;a&quot;])\n\nprint(_G[&quot;table&quot;][&quot;insert&quot;]) –打印出全局变量table中的函数insert（table类型也就是table）\n&nbsp;\n布尔\nC中!=在lua中为~=\n\na=true\nb=false\n\nprint(a and b) –falseprint(a or b) –trueprint(not a) –false\n–lua中只有nil与false代表假，其他都代表真，包括数字0a&#x3D;nil –为假b&#x3D;0 –为真print(a and b) –nil(返回a值) –若a为false，则返回a，否则bprint(a or b) –0（返回b值） –若a为true，则返回a，否则bprint(b&gt;10 and &quot;yes&quot; or &quot;no&quot;) –no\n&nbsp;\nif\nif 1&gt;10 then\n    print(&quot;1&gt;10&quot;)\nelseif 1&lt;10 then\n    print(&quot;1&lt;10&quot;)\nelse\n    print(&quot;no&quot;)\nend\n\nend代表代码块\n\n&nbsp;\n循环\n\nfor\nwhile\nrepeat（同while）\n\n\nfor i=1,10 do\n    print(i) --1,2,3,4,5,6,7,8,9,10\nend\n\nfor i&#x3D;1,10,2 do    print(i) –1,3,5,7,9end\nfor i&#x3D;1,10 do    print(i) –1,2,3,4,5,6,7,8,9,10    i&#x3D;1 –不能对循环值进行更改，在lua中默认新声明一个local iend\nfor i&#x3D;1,10 do    print(i) –1,2,3,4,5    if i&#x3D;5 then break endend\nlocal n=10\nwhile n&gt;1 do\n    print(n)\n    n=n-1 --lua不支持n--、n-=1等自减\nend\n\n&nbsp;\n&nbsp;\n\n","categories":["lua相关"]},{"title":"Untiy相关C#常用API","url":"/2023/07/31/Untiy%E7%9B%B8%E5%85%B3C-%E5%B8%B8%E7%94%A8API/","content":"\n\n\n\n\nUnity常用API\n\nUnity初级常用API\n&nbsp;\n碰撞检测\n对于一个触发器，碰撞事件的三个状态：\n\nOnTriggerEnter2D: 开始碰撞\nOnTriggerStay2D: 碰撞中\nOnTriggerExit2D: 碰撞分开\n\n\nvoid OnTriggerEnter2D(Collider2D collider)\n    &#123;\n        Debug.Log(&quot;撞到啦...&quot;);\n        Debug.Log(collider.gameObject.tag);\n    &#125;\n// 碰撞检测函数,进入的时候执行\n\nvoid OnTriggerStay2D(Collider2D collider)    &#123;        Debug.Log(&quot;一直停留在碰撞状态…&quot;);    &#125;&#x2F;&#x2F; 停留的时候执行\nvoid OnTriggerExit2D(Collider2D collider)    &#123;        Debug.Log(&quot;退出碰撞状态…&quot;);    &#125;&#x2F;&#x2F; 退出的时候执行\n使用条件：检测的对象必须拥有col相关组件碰撞脚本，而且这个适用于触发器\n\n如果检测器不是触发器，即需要有具体的物理系统，则使用如下对应函数：\n\tprivate void OnCollisionEnter(Collision collision)\n    &#123;\n        print(collision.gameObject.name);\n    &#125;\n     private void OnCollisionExit(Collision collision)\n    &#123;\n        print(collision.gameObject.name);\n    &#125;\n\n&nbsp;\n非物理碰撞检测（Bounds 外包围盒）\n有时候由于脚本冲突，比如对象不是按照官方的物理逻辑在编写碰撞的，则直接检测是否经过而不是判断物理碰撞来检测碰撞\n使用BoundsAPI\nbounds.center\nbounds.size\nbounds.min\nbounds.max\nbounds.center.x\nbounds.center.y\n\n其中center和size只读\n常用方法：\npublic bool Contain(Vector3 point);//判断点是否在内部\npublic void Encapsulate(Vector3 point);//自动扩充大小来包括这个点\npublic void Encapsulate(Bounds bounds);//自动扩充大小来把这个bounds包括\npublic bool IntersectRay(Ray ray);//判断这个射线是否与包围盒相交\npublic Vector3 ClosestPoint(Vector3 point);//包括盒最近的点\npublic void SetMinMax(Vector3 min,Vecor3 max);//设置边界框的最小最大值\n\n与Collider的区别：Bounds不会跟着模型旋转，只会跟着变大变小，作为五向的，精度更小 \n\n包围盒的类型\n\nAABB包围盒（Axis-aligned bounding box）\n包围球（Sphere）\nOBB包围盒（Oriented bounding box）\n凸包包围盒（Convex Hull）\n\n\nAABB：构造简单，存储空间小，紧密性差，对于不规则体荣誉空间大，两个点描述（立方体对角线）\n从算法角度上看，其实就是计算两点在坐标轴上的投影，然后对比两个对象的投影在坐标轴上的描述，如果xyz轴（如果是2D则xy轴）都有交叉段，则判断相撞\n与OBB差别：不可旋转\n\n&nbsp;\n判断某点是否在Bounds内\n Vector3 pos = someRenderer.transform.position;\n Bounds bounds = myBoxCollider.bounds;\n bool rendererIsInsideTheBox = bounds.Contains(pos);\n\n带碰撞的\n Bounds rendererBounds = someRenderer.bounds;\n Bounds colliderBounds = myBoxCollider.bounds;\n bool rendererIsInsideBox = colliderBounds.Intersects(rendererBounds);\n\nget与set属性访问器（其实是刚好了解到这个东西才写进来的）\n&nbsp;\n一般情况下在C#中编写脚本声明变量时：\nprivate float num;\npublic int index;\n\n其实隐藏了get与set：\npublic float Num\n&#123;\n    get &#123; return Num; &#125;\n    set &#123; Num= value; &#125;\n&#125;\n\nget与set内的定义其实就是上述，get返回Num的值，调用Num时返回Num本身，也就拿到了Num值，set让Num附上value值，所以说这两个相当于“读”和“写”，其具体作用其实也是在声明读和写\n一般声明变量，unity默认为读写，也就是默认这两个访问器都能用，但如果自行编写这两个访问器的其中之一，那么就相当于编写成“只读”或“只写”\nprivate float num//只读属性，只能读取该属性的值\n&#123;\n    get &#123; return num; &#125;\n&#125;\nprivate float num//只写属性，只能给该属性设置值\n&#123;\n    set &#123; num = value; &#125;\n&#125;\nprivate float num//可读可写的属性\n&#123;\n    get &#123; return num; &#125;\n    set &#123; num = value; &#125;\n&#125;\n\n在C++中，我们为变量赋值时，可能会遇到变量有一定范围的需求，于是我们一般创建一个新变量来做判断以限定范围：\nint a;//假如a范围为0~10\nint b;\ncin&lt;&lt;b&lt;&lt;endl;\nif(b&gt;=0&amp;&amp;b&lt;=10)\n&#123;\n  a=b;    \n&#125;\n\n这样的目的是保持变量安全性，a永远不可能被外界设置成0到10以外的值\n这个方式和C#中使用get与set保护变量有异曲同工之妙：\nprivate float num;\n \npublic float Num&#123;    get &#123; return num; &#125;    set &#x2F;&#x2F;value小于等于10    &#123;        if (value&gt;10)            &#123;                value &#x3D; 10;            &#125;\n    num = value;\n&#125;\n\n}\n建立新值num来为Num赋值，看似多此一举，其实就是防止Num溢出\n不过最标准的命名变量的方式可能是如此：\nprivate float num&#123;get;set;&#125;;\n\n用来强调可读可写\n\n","categories":["从C++开始的C#"]},{"title":"lua进阶","url":"/2024/10/01/lua%E8%BF%9B%E9%98%B6/","content":"\n\n\n\n\nLua进阶\n\nLua进阶\n&nbsp;\nLua表深拷贝\nLua的表是一种类似引用类型，这种类型赋值的时候会直接将对象地址赋值过去。\nlocal t10=&#123;1,2,3,4,5,6&#125;\nlocal t9=t10\nt9[1]=10\nprint(t10[1]) --- 输出为10\n\n\n递归拷贝\n\n\n最简单的方式就是新建表，然后遍历要复制的表元素一个个复制过去。由于表本身也可以存表，所以使用递归实现。\nfunction deep_copy(tbl)\n    local new_tbl = &#123;&#125;\n    for key, value in pairs(tbl) do\n        if type(value) == &quot;table&quot; then\n            new_tbl[key] = deep_copy(value)\n        else\n            new_tbl[key] = value\n        end\n    end\n    return new_tbl\nend\n\n由于存储的表也有可能是表本身或者是表本身的表元素，所以可能产生循环引用的现象，优化过后的深拷贝函数对已经克隆过后的对象进行了存储。\nfunction clone(object)\n    local lookup_table = &#123;&#125;\n    local function _copy(object)\n        if type(object) ~= &quot;table&quot; then \n            return object \n        elseif lookup_table[object] then\n            return lookup_table[object]\n        end\n        local new_table = &#123;&#125;\n        lookup_table[object] = new_table\n        for key, value in pairs(object) do\n            new_table[_copy(key)] = _copy(value)\n        end\n        return setmetatable(new_table, getmetatable(object))\n    end\n    return _copy(object) -- 返回clone出来的object表指针/地址\nend\n\nipair与pair\n\nipair遇到不连续的数据停止输出，遇到nil停止输出，会按照key的顺序输出；而pair会无序输出所有数据。\nipair和pair都会优先输出没有key的数据。对于pair，同样会无序输出带key的值，但是会按顺序输出不带key的值；对于ipair，在key值方面，他会补充不带key值的key，按顺序输出key。\n\n\n例子：\nlocal t = &#123;[1]=1,2,[3]=3,4,[5]=5,[6]=6&#125;\nprint(&quot;------ipairs------&quot;)\nfor k,v in ipairs(t1) do\n    print(k,v)\nend\n \nprint(&quot;——pairs——&quot;)for k,v in  pairs(t1) do    print(k,v)end\n结果为：\n------ipairs------\n1       2\n2       4\n3       3\n------pairs------\n1       2\n2       4\n3       3\n5       5\n6       6\n\n首先无论pairs还是ipairs都会将无key的元素优先遍历，也就是{2,4}。\n此时要注意输出的这个k与实际的key值不是一个值，也就是按顺序开2就是第一个，4就是第二个，所以都直接输出12和24。\n之后遍历会沿着2往后找，也就是说在原表内不会再关注1了，而是直接看key=3的键值对，也就是33。\n此时再次发生分歧，因为原表中找不到key为4的键值对了。\n所以ipairs断开，pairs继续遍历。\n理论上从3开始pairs就要随机输出了，但是因为哈希算法排序样本较小，只有三个的话还看不出随机，当数量多了之后就随机了。\nlua表中可以用table来表示key\n\n&nbsp;\n全局变量泛滥\n设置_G的元表，在其中进行检测，在触发__ newindex或者__ index时判断元素是否有显式声明过。\n&nbsp;\n典型元方法\n\n_add处理对象相加，用于重载+\n_index定义表索引，访问不存在的索引时触发\n_newindex为不存在的索引赋值时触发\n_pairs、_ipairs定义对象迭代器行为\n\n\n&nbsp;\nluaGC与C#GC\nunity中的内存管理分为托管内存和非托管内存，GC只影响托管内存。\nlua采用增量回收的方式，性能更高。\n\nlua中需要gc的数据类型——表、用户数据（指用于表示C语言中任意数据的类型）、函数、线程。\n\n\nlua的gc是基于引用计数，利用标记-清除法来处理循环引用。\n&nbsp;\nlua长短字符串\nlocal shortStr1 = &#39;This is a short string.&#39;\nlocal shortStr2 = &quot;This is another short string.&quot;\n\nlocal longStr &#x3D; [[This is a long string.It can contain multiple linesand special characters like \\n and \\t.]]\n短字符串和string很像，需要转义字符，而长字符串不需要。\n长字符串总是存在堆内存中，此外，任何字符串长度超过一定阈值都会存在堆中。\n\n","categories":["lua相关"]},{"title":"lua面向对象","url":"/2024/09/19/lua%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","content":"\n\n\n\n\nLua实现面向对象\n\nLua实现面向对象\n首先Lua本身是面向过程语言，不存在封装、多态等特性，但是提供了元表元方法供技术人员自己实现面向对象。\n&nbsp;\n元表与元方法\nLua中的每一个值都可以拥有一个元表，元表中定义了这些值在一定条件下的特定方法，如__add等。元表本身的内容是以键值对的形式存储的，“事件”为键，“元方法”为值。\n对于面向对象模拟，关键要找__ index这个元方法，这个方法的意思是，如果在查找表中不存在的字段时，会查询元表中是否含有__ index，如果含有，则调用__ index。\n__ index本身可以赋值为值，也可以赋值为函数，也可以赋值为表。\n为值则返回值，为函数则调用该函数，为表则向这个表中查找字段。\n&nbsp;\n从CPP面向对象向Lua发展\n首先Lua的一大特性就是只有值和表，表包含万物，所以我们可以将表作为面向对象中的封装单位，下意识将成员与方法都放在表中。\nlocal tb = &#123;a=0,b=1&#125;\n\n对于函数，在C++中成员函数可以直接放在类中的，然而总所周知在编译器层面C++成员函数实际是这样定义的\nClass::Function()&#123;&#125;;\n\n也就是说实际上函数是写在类外的，这个和C++的内存结构是一致的，因为对象中的成员参数要么存放在栈区，要么堆区，而函数是存放在代码段的，八竿子打不着。\nC++通过这种方式可以调用到类本身的函数，实际是运用了隐藏的一个this指针：\nClass::Function(Class *this)&#123;&#125;;//这个this是隐藏的，和下面的&amp;a一样，编译器会自动填上\n\nClass a;a.Function(&amp;a);\n这样，函数调用的时候就会得知到是要处理哪一个对象的参数了。\n在Lua中，this指针的传递成为了可选项。（lua中this指针叫做self）\nlocal tb = &#123;a=0,b=1&#125;\nfunction tb.add(a,b)\n    return a+b\nend\nprint(tb.add(tb.a,tb.b)) --直接传递参数\n**********************\nfunction tb.add(self)\n    return self.a+self.b\nend\nprint(tb.add(tb)) --传递表自己\n**********************\nfunction tb:add()\n    return self.a+self.b\nend\n\nprint(tb:add())\t–用冒号省略self指针–print(tb.add(tb))\t\tprint(tb.add(tb1))\t\t\n&nbsp;\n这样的话，在lua中就可以模拟C++定义成员函数的方式来定义函数了。\nlocal a = &#123;name=&quot;lisi&quot;&#125;\t\n\nfunction a:MyPrint()\t\t    print(self.name)end\n–当然等同于local a &#x3D; &#123;    name&#x3D;&quot;lisi&quot;,    function MyPrint(self)\t\t        print(self.name)    end&#125;\t\n&nbsp;\n这个类是需要能够继承的，特点是子类会继承父类的所有属性和函数，那么我们可以使用元表元方法来实现，我们将子表的元表设置成父表，再将父表的__ index设置为父表自己，这样就能实现当子表查不到属性的时候查到父表的__ index，然后直接就开始查父表中的属性了。\n-- 定义父类 a\nlocal a = &#123;name = &quot;lisi&quot;&#125;\n\nfunction a:new(o)    o &#x3D; o or &#123;&#125;    setmetatable(o, self)    self.__index &#x3D; self    return oend\nfunction a:MyPrint()    print(self.name)end\n– 定义子类 b，继承自 alocal b &#x3D; a:new()  – 子类 b 继承父类 ab.name &#x3D; &quot;zhangsan&quot;  – 子类有自己独立的属性\n– 创建子类实例local obj &#x3D; b:new()\nobj:MyPrint()  – 输出 &quot;zhangsan&quot;\n这样的面向对象还是比较牵强的，因为“类”b本质上也可以视为类a的对象，具备a对象的所有功能。\nlua多继承\n多继承意味着不能直接通过单个基类来直接派生出子类，所以要单独使用一个额外的不与任何类关联的函数（A）来处理继承。\n这个函数中首先是收集要继承的所有父类，存在一个表（B）里，然后再走单继承的流程，先定义子类，再设置子类元表，此时这个元表先设置为空，在空元表中将__index设置为另一个函数search，这个函数在A函数内的表现是查找表B的key值，如果找到了就将value返回。\n\n&nbsp;\nlua面向对象的封装\n常用的处理方法是定义两个表，一个表存私有成员，一个表存调用私有成员的方法。\n方法直接控制私有成员值，或者返回出去，而只有方法表才暴露在外界供调用，这样来模拟面向对象封装。\n闭包\nlua中的闭包也是其一个独有的特性，最明显的就是lua中的函数是可以通过返回值的方式来返回的。\nfunction createCounter()\nlocal count = 0  -- 外部局部变量\n\n– 返回一个闭包，持有 count 变量的引用return function()    count &#x3D; count + 1    return countend\ncount是一个局部变量，返回的函数持有这个count的引用。理论上退出createCounter这个作用域后count也会失效，但是他被返回的函数持有，当其他地方调用createCounter得到这个函数的时候也就得到了count，这个得到的count未被析构，他仍然能够被访问甚至修改。\nlocal counter1 = createCounter()\nprint(counter1())  -- 输出 1\nprint(counter1())  -- 输出 2\nprint(counter1())  -- 输出 3\n\nlocal counter2 &#x3D; createCounter()  – 创建新的闭包print(counter2())  – 输出 1print(counter2())  – 输出 2\n更复杂的例子：\nfunction createAdder(x)\n    return function(y)\n        return x + y  -- 这里的 x 来自外部作用域\n    end\nend\n\nlocal add5 &#x3D; createAdder(5)  – 创建一个闭包，x 固定为 5print(add5(3))  – 输出 8 (5 + 3)print(add5(10))  – 输出 15 (5 + 10)\nlocal add10 &#x3D; createAdder(10)  – 创建另一个闭包，x 固定为 10print(add10(3))  – 输出 13 (10 + 3)print(add10(10))  – 输出 20 (10 + 10)\n除了使用两个表来模拟封装外，也可以使用闭包来实现，将属性作为局部变量封装在某函数内，然后设置返回函数为控制该属性的函数，这样就能更实际地实现这个属性的封装。\n&nbsp;\nlua面向对象的多态\nlua中子类重写父类函数，调用函数会直接执行重写过后的逻辑。\nC++中经常说静态多态，也就是不同参数列表，lua中其实也不支持这样做，不过可以强行从逻辑层面对重写函数进行参数列表的if判断（是否为nil），来实现逻辑重载。\n从另一个角度上讲，因为lua本身就支持函数直接接受任意类型的参数，所以lua本身就支持多态。\n\n","categories":["lua相关"]},{"title":"一个麻木的夜晚","url":"/2023/12/24/%E4%B8%80%E4%B8%AA%E9%BA%BB%E6%9C%A8%E7%9A%84%E5%A4%9C%E6%99%9A/","content":"\n\n\n\n\n\n\n现在是2023/12/24星期日平安夜晚上22.07\n&nbsp;\n一个月前字节一面，面试官问的问题一个也答不出，涨红了脸语无伦次道了半个小时歉\n&nbsp;\n一面挂后几周得知字节放弃游戏部门，把占了游戏业很大比例的相关人员全部裁光\n&nbsp;\n前天早上腾讯的复试流程也结束了，原因大概是面试的时候引导失误\n&nbsp;\n星期六早上发现开拓芯的冬训营测试问卷，要求做一款小游戏，尽管很简单，但只有两天时间，而且恰逢我还有一整个学期的实验报告堆积在这两天，所以时间很匆忙，我可能甚至连睡觉的时间都要压缩。\n&nbsp;\n星期日中午我终于完成了大部分课内任务，甚至连打印报告的时间都安排在第二天早八之前，于是马不停蹄的重新启动unity极限挑战。\n&nbsp;\n现在是晚上22点，我终于完成了最后的收尾工作，正准备录视频上传，发现ddl其实是18:00而不是24:00\n&nbsp;\n第二天一起床还有期末考试，考完试马上就要进行C#论文汇报，然而我现在还没开始动笔\n&nbsp;\n我不知道这样的状态还要持续多久，真的\n\n","categories":["孩子写着玩的"]},{"title":"string类方法","url":"/2023/08/01/string%E7%B1%BB%E6%96%B9%E6%B3%95/","content":"\n\n\n\n\n从C字符串到C++的string类（in\n\n从C字符串到C++的string类\nC字符串以空终结符（‘\\0’）结尾，使用时底层逻辑是暴露的，一般用于代码人员了解字符储存机制而使用。而string类则隐藏了字符串的底层储存，代码人员不需要去了解细节。\nstring类很好的体现了类的性质，在使用string类时，能更好的理解类、面向对象思想的应用\n例如：\nstring s = &quot;welcome to C++&quot;\n这句形似C字符串的字符创建方式其实略微浪费了计算机系统资源，因为他是先是利用&quot;welcome to C++&quot;建立字符串对象，然后再将这个对象拷贝给s，其实是两个步骤\n后面给gpt检查的时候说这个思想不一定正确，因为编译器的返回值优化策略会避免这个问题，不过也不用在乎这个了\n\n一下方式是更符合类的行为逻辑的：\n\nstring s(&quot;Welcome to C++&quot;)括号显然是利用类的构造函数\nstring s这里使用了无参构造函数，建立空字符串s\nstring s(s1)是第一种的变体，s1是C字符串，而s是字符串对象\n\n\n&nbsp;\nstring类操作\n追加：\n\ns1.append(&quot;1234&quot;) s1后追加1234\ns2.append(&quot;1234&quot;,0,2) s2后追加12（从0个字符开始）\ns3.append(&quot;1234&quot;,2) s3后追加12\ns4.append(2,&#39;1&#39;) s4后追加11（注意这里是单个字符，和下面的赋值一样）\n\n\n赋值：\n\ns1.assign(&quot;1234&quot;) s1变成1234\ns2.assign(&quot;1234&quot;,0,2) s2变成12（从0个字符开始）\ns3.assign(&quot;1234&quot;,2) s3变成12\ns4.assign(2,&#39;1&#39;) s4变成11\n\n\n处理：\n\ns1.at(1) 返回s1字符串下标1的单个字符char\ns2.erase(1,2) 删除s2从下标1开始的两个字符\ns3.clear() s3被清空\ns4.empty() 以bool格式返回，检查s4是否为空\ns5.c_str() s5以C字符串char[]的形式返回\n\n\n查看：\n\ns1.size()和s1.length() 都是返回s1长度int值\ns2.capacity() 返回分配的存储空间大小\n\n\n系统为string分配的存储空间字节大小大于本身大小，初始会设置一个阈值，若建立的字符串表面量大小小于这个阈值，则会在栈中直接分配这个阈值大小的存储空间，叫做小型字符串优化；若大于这个阈值，string对象内部会隐式new操作在堆中根据字符串大小分配内存。\n这个阈值和编译器相关，常用的Visual C++是15\n当使用push_back操作扩容时，若超出初始分配的大小，则会对堆内存进行扩容\n\n比较：\n\ns1.compare(s2) s1与s2进行ASCII码比较，返回正数、0、负数\n\n\n获取子串：\nstring s1(&quot;1234&quot;)\n\ns1.substr(0,1) 返回1\ns1.substr(1) 返回234\n\n\n搜索：\nstring s1(&quot;12341&quot;)\n\ns1.find(&quot;23&quot;) 返回下标1\ns1.find(&quot;23&quot;,3) 返回string::npos（从下标3开始找，没找着）\ns1.find(&quot;1&quot;,3) 返回下标4\n\n\n插入与替换：\nstring s1(&quot;1234&quot;)\n\ns1.insert(2,&quot;66&quot;) s1变为123664\ns1.insert(2,2,&quot;66&quot;) s1变为12366664\ns1.replace(1,2,&quot;8&quot;) s1变为184\n\n\nstring对象在使用append、assign、erase、replace、insert之后，这些方法本身也会返回为结果字符串，例如以上s1.insert()=s1\n\n迭代器：\n\nbegin()：指向容器第一个元素的位置（可读可写）\nrbegin()：指向容器最后一个元素的位置（可读可写）\ncbegin()：指向容器第一个元素的位置（只读）\ncrbegin()：指向容器最后一个元素的位置（只读）\nend()：指向容器最后一个元素的下一个位置（可读可写）\nrend()：指向容器第一个元素前面的位置（可读可写）\ncend()：指向容器最后一个元素的下一个位置（只读）\ncrend()：指向容器第一个元素前面的位置（只读）\n\n\n迭代器失效：当容器扩容缩容时容易导致迭代器指向的对象错位，需要及时更新\n\n数字、浮点数与字符串之间的变化\n\nC字符串中的atoi与atof 方法同样适用\n更方便的方法是使用&lt;sstream&gt;头文件中的stringstream类\n\n\n示例：\nstringstream ss;\nss&lt;&lt;1.255;\nstring s == ss.str();\n\n上面是官方书给的示例代码，不过我更喜欢这样用：\nstringstream ss;\nstring s;\nss&lt;&lt;1.255;\nss&gt;&gt;s;\n\n&lt;sstream&gt;类会利用C++的类型系统和运算符重载来处理不同类型的数据，更加安全\nstringstream类特有的输入输出流特点还方便了字符串抽取单词，因为这个方法会自动分割空格，将单词一个个存入输入流中\n\nstring text(&quot;abcd abc ab&quot;);\nstringstream ss(text);\nstring word;\nwhile(!ss.eof())&#123;\n    ss &gt;&gt; word;\n    cout &lt;&lt; word &lt;&lt; endl;\n&#125;\n\n输出：\nabcd\nabc\nab\n\n\n","categories":["从C开始的C++"]},{"title":"二叉树经典遍历","url":"/2023/11/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%8F%E5%85%B8%E9%81%8D%E5%8E%86/","content":"\n\n\n\n\n深度优先遍历\n\n该篇总结了基础的二叉树遍历方式\n深度优先遍历\n包括前序、中序、后序三种\n\n递归形式的遍历\n// 前序遍历\nvoid preorderTraversal(TreeNode* root) &#123;\n    if (root == nullptr)\n        return;\n    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;\n    preorderTraversal(root-&gt;left);\n    preorderTraversal(root-&gt;right);\n&#125;\n\n&#x2F;&#x2F; 中序遍历void inorderTraversal(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr)        return;    inorderTraversal(root-&gt;left);    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;    inorderTraversal(root-&gt;right);&#125;\n&#x2F;&#x2F; 后序遍历void postorderTraversal(TreeNode* root) &#123;    if (root &#x3D;&#x3D; nullptr)        return;    postorderTraversal(root-&gt;left);    postorderTraversal(root-&gt;right);    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;&#125;\n但是递归占用太多计算机资源，还经常超时，所以下面的手写非递归形式遍历，要借助其他数据结构\n&nbsp;\n前序遍历(Preorder)\n\n访问根节点。\n递归地对左子树进行前序遍历。\n递归地对右子树进行前序遍历。\n前序遍历的访问顺序为「根-左-右」。\n\n\n// 前序遍历\nvoid Preorder(TreeNode* root)&#123;\n    stack&lt;TreeNode*&gt; a;\n    TreeNode* node=root;\n    while(node!=NULL||!a.empty())&#123;\n        while(node!=NULL)&#123;\n            //结点操作\n            a.push(node);\n            node=node-&gt;left;\n        &#125;\n    \n    //遍历代码精髓就是当一直向左遍历到空的时候再依靠栈返回到父节点，由此对父节点以及右节点进行遍历\n    if(!a.empty())&#123;\n        node=a.tap();\n        a.pop();\n        node=node-&amp;gt;right;\n    &#125;\n&#125;\n\n}\n中序遍历(Inorder)\n\n递归地对左子树进行中序遍历。\n访问根节点。\n递归地对右子树进行中序遍历。\n中序遍历的访问顺序为「左-根-右」。\n\n\n// 前序遍历\nvoid Preorder(TreeNode* root)&#123;\n    stack&lt;TreeNode*&gt; a;\n    TreeNode* node=root;\n    while(node!=NULL||!a.empty())&#123;\n        while(node!=NULL)&#123;\n            a.push(node);\n            node=node-&gt;left;\n        &#125;\n        \n    //和前序遍历一样的，只不过结点操作点放在出栈之后了\n    if(!a.empty())&#123;\n        node=a.top();\n        a.pop();\n    //结点操作\n    node=node-&amp;gt;right;\n    &#125;\n&#125;\n\n}\n后序遍历(Postorder)\n\n递归地对左子树进行后序遍历。\n递归地对右子树进行后序遍历。\n访问根节点。\n后序遍历的访问顺序为「左-右-根」\n\n\n//后序遍历\nvoid Postorder(TreeNode* root) &#123;\n    if (root == nullptr) &#123;\n        return;\n    &#125;\n\nstack&amp;lt;TreeNode*&amp;gt; s;\nTreeNode* prev = nullptr;\ndo &#123;\n    while (root != nullptr) &#123;\n        s.push(root);\n        root = root-&amp;gt;left;\n    &#125;\n    while (root == nullptr &amp;amp;&amp;amp; !s.empty()) &#123;\n        root = s.top();\n        //其他结构不变，仍然是保证“先遍历左节点再遍历右结点”，那么难点就在于如何遍历中间结点了，只需要在遍历“出栈”结点时将其标记，这样这个结点回到父节点时可以直接对中间结点进行操作\n        if (root-&amp;gt;right == nullptr || root-&amp;gt;right == prev) &#123;\n            cout &amp;lt;&amp;lt; root-&amp;gt;val &amp;lt;&amp;lt; &amp;quot; &amp;quot;;\n            s.pop();\n            prev = root;\n            root = nullptr;\n        &#125; else &#123;\n            root = root-&amp;gt;right;\n        &#125;\n    &#125;\n&#125; while (!s.empty());\n\n}\n&nbsp;\n&nbsp;\n广度优先遍历(Level)\n最基础的就是经典层序遍历，在实际运用中可能会更改遍历顺序等\n\n\n从根节点开始，逐层遍历二叉树。\n从左到右依次访问每个节点。\n层序遍历按照层级顺序逐个访问节点。\n\n\n//bfs\nvoid bfs(TreeNode* root)&#123;\n    if(root==NULL)&#123;\n        return;\n    &#125;\n    Queue&lt;TreeNode*&gt; q;\n    TreeNode* node=root;\n    q.push(node);\n    while(node!=NULL&amp;&amp;!q.empty())&#123;\n        node=q.front();\n        q.pop();\n        //遍历操作\n        if(node-&gt;left!=NULL)\n            q.push(node-&gt;left);\n        if(node-&gt;right!=NULL)\n            q.push(node-&gt;right);\n    &#125;\n&#125;\n\n&nbsp;\n\n","categories":["数据结构与算法"]},{"title":"二维矩形装箱算法","url":"/2024/12/16/%E4%BA%8C%E7%BB%B4%E7%9F%A9%E5%BD%A2%E8%A3%85%E7%AE%B1%E7%AE%97%E6%B3%95/","content":"\n\n\n\n二维矩形装箱问题\n\n\n图集打包策略\n二维矩形装箱问题\n除了小图集打包入大图中，最近还遇到一个类似的应用情况，那就是三角洲行动里面的背包系统。这个游戏的整理功能非常强大，可以手动触发也可以在拾取物品时自动触发整理，而且三角洲行动中的背包种类多样，形式也不一定是一个完全矩形，此外每个物品还会有优先级问题，比如消耗品要优先放在子弹挂中，珍贵的收藏品要优先放在保险柜中等。而且最牛的是在游戏中这个算法运行起来都是一瞬间发生的，所以我认为这是一个很值得研究的算法。\n&nbsp;\n经典实现——二叉树&amp;第一次适配算法\n启发式算法的一种，理论上不一定为最佳适配\n\n\n在每次循环起始，将一个最大的矩形放置在左上角，然后空间就会这样分成两个小矩形。再次针对小矩形进行递归，这样的算法可以通过二叉树来进行实现。\n如果说待排布的矩形按照大小排列，那么就能保证在递归的过程中一直保持二叉树的结构性质。当然排序本身就是一件十分消耗性能的事情，所以也有一些其他的用准确度换性能的算法。\n对于二叉树划分本身，可以分为“水平划分（如图）”、“垂直划分”和“最小残余划分”策略。将矩形左上角的点位坐标，空位宽度、长度都存储为一个数据结构当初树的实际存储结点。\n在进行二叉树遍历的时候会涉及到选择哪一个矩形来放置的问题，这里也使用启发式的方式来进行推断：\n\nBest-Fit：贪心算法，优先选择可以容纳新矩形且剩余空间最小的槽\nWorst-Fit：直接选择剩余空间最大的槽，来减少空间碎片\nBest-Wfit：先尝试贪心算法，如果没用合适位置，那么就采用Worst-Fit算法\n\n\n三角洲行动里面的物品格子是标准化的矩形，不会出现图集这样的非常极限长宽数据。所以这里推测只占一格或者比较小的物品应该是单独进行了补充排列，设置了补充机制来进行排布。\n对于已经排列好矩形大小顺序的算法，这种策略叫做离线打包，而实时拿到一个矩形直接进行装箱的算法，这种叫做在线实时打包。离线式的方式，以矩形长宽来划分又分为多种分支策略：\n\nBssf：最短边匹配，最短边排列，依次筛选最短边匹配的矩形优先排列，这样的做法能减少空间碎片。\nBaf：最佳空间适配，排列面积，选择剩余空间面积最匹配的位置进行放置，适合大面积填充。\nBlsf：最长边匹配，对长方形适应性友好。\n\n\n&nbsp;\n性能优化算法——天际线算法\n原网站https://jvernay.fr/en/blog/skyline-2d-packer/implementation/?utm_source=uwl.me\n\n\nskyline算法不需要对原图像进行提前排列，他是一种在线打包算法。\n该算法只关注矩形上界轮廓，所以叫做天际线算法。\n数据结构\n天际线为一个坐标数组，记录一系列可容纳空间的左下角点位。\n更新与特殊情况\n初始点位默认为空位矩形的左下角点位，新加入的矩形有一个长宽数据，此时几乎每一个天际线点位都能成为矩形的锚点位。此时需要开始进行点位筛选：\n\n排除经计算后矩形过界的点位。\n如果发生天际线碰撞，则升高矩形以适配最高天际线。\n\n\n\nfor(int i = 0;i&lt;count;i++)&#123;\n    int x = sky[i].x;\n    int y = sky[i].y;\n    //省略过界判断\n    int xM = x + width;\n    int i2 = i+1;\n    //检测是否发生天际线碰撞\n    for(i2 = i+1;i2&lt;count;++i2)&#123;\n        if(xM&lt;=sk[i2].x)&#123;\n            break;\n        &#125;\n        if(y&lt;sk[i2].y)&#123;\n            y = sk[i2].y;\n        &#125;\n    &#125;\n&#125;\n\n\n如果新矩形只覆盖一个天际线点，说明是一个“好点位”，那么不需要做更多处理，将此点位纳入候选点位。如果最终被选中，则更新点位为新矩形的左上点位。\n\n如果新矩形覆盖两个或以上点位，说明发生了天际线越界或者天际线碰撞的情况\n\n天际线越界的情况不需要做更多处理，可以纳入候选点位。如果被选中。则更新点位为新矩形的左上点位，并将所有覆盖的点位全部去除，更新一个新点位为矩形右边界的下部天际线位置。\n天际线碰撞的情况做矩形上升。如果被选中，则更新点位为新矩形的左上点位。\n\n\n\n点位更新后，还需要判断点位是否和天际线重合，如果是，则去除该点位。\n\n\n\n\n从伪代码中得知该算法有两个嵌套循环，但是循环的次数取决于矩形的宽度，如果宽度越大，则说明点数越小，循环次数可能越少。\n\n","categories":["数据结构与算法"]},{"title":"介质访问控制子层","url":"/2023/11/14/%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/","content":"\n\n\n\n\n介质访问控制子层\n\n介质访问控制子层\n确定多路访问信道下一个使用者的协议，属于数据链路层底部\n\n&nbsp;\n静态信道分配\n这种方法其实就是多路复用技术（FDM），试想一下多个电话用户，但只有一条通话信道，那么FDM的做法就是将其频谱直接平均分为N份（N为用户数量）。当然这是一个很理想的状态，比如说实时通话的人远远少于N，带宽的浪费是难以想象的。\n&nbsp;\n动态信道分配假设\n关键假设\n流量独立：传输的站都是独立的，独立阻塞\n单信道：所有通信都用一个信道\n冲突可观察：所有的站都能检测到冲突事件的发生\n时间连续或分槽：任何时刻都能开始传输帧/时间分成一段一段，传输只能从某一段开始的时候发生\n载波侦听或不听：载波侦听——在传输之前就知道信道时候在被使用\n&nbsp;\n****《多路访问协议》*****\nG=每帧平均帧数\n\n&nbsp;\nALOHA系统——最好的情况是G=0.5，信道利用率=18%\n当用户有数据需要发送时就传输\n\n在ALOHA中，每个站在给中央计算机发送帧之后，中央计算机把帧重新广播给所有站，作为发送者当然能检测到是否能成功。\n发生错误时，发送方必须以随机时间在重新发送帧，以避免规律发送从而再次造成冲突。\n帧时——指传输一个标准固定长度帧所需要的时间（长度除以比特率）。\n很显然，超过两个站在同时发送帧或者还等待其他站帧时过去就再次发帧，就很容易产生冲突。\n很遗憾纯ALOHA系统可没法在别人正在发送的时候侦听信道，所以这种冲突很容易发生。\n&nbsp;\n分槽ALOHA——最好的情况是G=1.0，信道利用率=37%\n时间分成离散的间隔——时间槽，每个槽对应一帧\n\n使得所有站都必须遵守一个统一的时间槽边界，于是专门有一个特殊的站在每个间隔起始时发出一个脉冲信号。\n&nbsp;\n**《载波侦听多路访问协议》****\n站点实际上可以检测其他站点是否在发送数据\n\n在这个协议中，站监听是否存在载波——是否有传输。\n&nbsp;\n坚持和非坚持CSMA\n当一个站有数据要发送时，它首先侦  听信道，确定当时是否有其他站正在传输数据；如果信道空闲，它就发送数据。否则，如  果信道忙，该站等待直至信道变成空闲；然后，站发送一帧。\n如果发生冲突，该站等待一  段随机的时间，然后再从头开始上述过程。\n可以叫做1-坚持，因为发现信道空闲时，传输数据的概率为1\n带宽延迟积——如果信道容纳帧很大，带宽延迟积就越大，这样的话侦听信道本身就会产生影响。\n非坚持CSMA同样会侦听信道并在其空闲时发送，不同的是，这个协议不会一直监听信道，以至于避免在信道“空闲”那一瞬间马上发出自己的信息——他会自己随机等待一段时间再次监听，可以说是一位不紧不慢的绅士。\np-坚持CSMA适用于分时间槽的信道，当一个站准备好要发送的数据时，它就侦听信道。如果信道是空闲的，  则它按照概率P发送数据。推迟概率q=l-p，将此次发送推迟到下一个时间槽。如果下一  个时间槽信道也是空闲的，则它还是以概率p发送数据，或者以概率q再次推迟发送。这  个过程一直重复，直到帧被发送出去，或者另一个站开始发送数据。\n&nbsp;\n带冲突检测的CSMA\n经过上面一系列改进，协议仍然还留下一个硬骨头，那就是极限情况下两个站同时满足能发送的条件，这个冲突几乎无法避免。\n冲突检测可以检测到发送冲突时，将传输帧立即“撤回”以节省时间和带宽。\n冲突检测的最小时间是将信号传播到另一个站所需要的时间，如果在这段时间内还没检测到冲突，说明信道确实是空闲的，并让其他站知道自己在占用信道。\n&nbsp;\n****《无冲突协议》***\n以不可能产生冲突的方式解决信道竞争问题\n\n在这一类协议中N个站被标记成0~N-1\n&nbsp;\n位图协议\n每一轮竞争期都含有N个槽，在每一个站要传输数据时，在自己的槽内传输一个信号称为“声明”。N个槽都接收后，每个站点就都知道哪些站要传输数据了，于是按照要传输的数据站的顺序来依次占用信道，这样提前“说好”的方式当然不会产生竞争。——也可以说是“预留协议”\n&nbsp;\n令牌传递\n和位图协议很像的方式，令牌从一个预定义的顺序每一个站都传输一次，当存在令牌的站才具有资格传输，如果没有要传输的，则单纯将令牌传输给下一位。\n&nbsp;\n二进制倒计数\n如果一个站想要使用信道，就以二进制位串的形式广播自己的地址。\n传输协议如下：\n假如站0010、0100、1001、1010都想要获得信道，他们都先发送第一位也就是0、0、1、1，那么OR之后为数为1，则前两位退出竞争，因为他们知道有更高位的站参与竞争。以此类推最终的胜者就是1010.\n&nbsp;\n****《有限竞争协议》******\n在低负载的情况下采用竞争实现较短延迟，在高负载的情况下采用无冲突技术获得良好的信道效率。\n\n将所有的站分组，几号组的成员才能竞争几号的时间槽，以此减少每个时间槽的竞争“人数”\n所以这种协议需要一种将站分配到时间槽的方法\n&nbsp;\n自适应树遍历协议\n这种协议很像二叉树的遍历，首先允许所有站进行竞争，如果发生冲突，则只允许某一叶子树进行竞争，以此递推，直到信道成功被某一站占领为止，然后这个槽在运行完毕后会被另一个叶子树竞争。\n这种方式用简单的话来说就是“核酸检测混合样本”，如果发生冲突，也i就是说发现样本异常，则取半继续检测，直到找到那个唯一的“阳性”。\n&nbsp;\n**《无线局域网协议》*****\n无线电通信。也就是无线局域网。\n\n类似蜂窝电话系统，他们在一定的范围内提供接入服务（AP接入点），但区别是一个“蜂窝”共享一个信道。\n无线LAN最大的缺点是每一个接入点——或者说每一个站的覆盖是有一定范围的，而且范围不一定是规律的圆形，这样就容易导致接收站发生冲突，比如ABC站点连成一线，AC相互接收不到而AB与BC能接收到，而无线LAN使用的方法是CSMA，也就是监听是否有其他站在传输，这样导致AC相互听不到，容易造成比如A和C同时向B发送信号造成冲突的情况，容易扰乱信号。\n这种”竞争者太远而无法检测潜在的竞争者“，叫做隐藏终端问题。\n与此同时也有一个叫暴露终端问题，例如现在是ABCD一条线，B向A发送信息，C本该向D发送信息，结果发现B在发送信息就不发了，这种也是错误的。\n&nbsp;\n冲突避免多路访问（MACA）\n同样是拿ABCD举例，现在B向C发送信息，会先发送一个RTS帧，这个短帧包含以后要发送的数据帧长度，然后C回应一个CTS帧，也包含数据长度，A在收到CTS后开始传输。\n现在看来，如果有站点接收到RTS而接收不到CTS，意味着它的发送不会影响到接收站，所以在B发送正式帧的时候不受限制——比如A站点；如果有站点接收到CTS（无论是否收到RTS），则必须全程保持沉默。\n&nbsp;\n以太网\nIEEE标准协会关键词：\n802.3——以太网\n802.11——无限局域网\n蓝牙——无线PAN\n802.15——无限城域网（本章不涉及）\n\n以太网分为经典以太网与交换式以太网，之后会依次讲述到。\n&nbsp;\n二进制指数后退的CSMA/CA\n经典以太网使用CSMA/CD，也就是说监听介质到空就立马发送，如果有冲突则等待一段随机时间重新发送。\n问题是这个“随机时间”怎么确定。\n有一个算法叫二进制指数后退，简单地说就是第一次冲突就在0，1个时间片中选一个等待，第二次就0，1，2，3，第i次就0，.......，2的i次方-1个时间片中随机选一个等待。作用是动态适应发送站的数量。\n例子：如果冲突到了1023个时间片里面选，那么两个站几乎不可能冲突；反过来如果让100个站在100个固定的时间片里面一直随机，那发生冲突的次数难以计数\n\n&nbsp;\n经典以太网与802.11物理层\n前者包含多个电缆段和多个中继器，后者使用短程无线电传输信号\n&nbsp;\n经典以太网MAC子层协议\n发送帧的方法：CSMA/CD与二进制指数退避算法\n然后是是帧格式：\n\n数据段限制帧长度的原因：RAM太贵，限制帧长度也就是限制内存大小；也不能太短，要求帧要和垃圾帧有区分，所以不能小于64字节，期中数据不能小于46字节，太小就填充。还有一个原因是保证往返的时间，因为需要避免错误帧比”警告帧”传播地还快，所以帧长点有助于延缓传播速度。\n&nbsp;\n802.11MAC子层协议\n然后是帧格式：\n\n与802.3相比，地址字段为三个，。第一个地址是接收方地址，第二个地址是发送方地址，第三个地址是一个远程端点——其实就是一个中继点\n802.16在教材中出现，但我个人就不深入学习了😇\n\n&nbsp;\n数据链路层交换\n网桥：能把多个局域网联结起来组成更大的局域网的设备\n路由器：检查数据包的地址，并基于这些地址路由数据包\n后向学习算法（backward learing）：用来阻止不需要发送的流量\n生成树算法（spanning tree）：用来打破不管三七二十一把交换机线缆连接起来而可能形成的环路\n&nbsp;\n学习网桥\n如果LAN技术是以太网，则网桥就是广为人知的以太网交换机\n\n\n网桥只管与之密切相连的端口，比如说a图，A向B发送帧，B1也会收到，但对于B1看来A向B发送帧对他来说是没什么大不了的事，于是将帧抛弃；如果A向D发送帧，那么必然经过B1，于是B1将帧转发到端口2，再传送到正确的站。\n为什么说“只管自己的端口”，可见图b，如果A向D发送帧，那么对于B1来说他要做的就是把帧从端口1转发到端口4，仅此而已。\n这些个网桥是怎么知道帧的传送路径的呢？，就好比b中的B1端口是怎么知道转发到4而不是2或3呢？这就涉及到一个算法叫泛洪算法（flooding algorithm），首先所有“与自己相关的端口”，网桥都是通过哈希表储存的，这样一来就可以储存多个站“属于”某端口的信息了，然后哈希表一开始也是空的，在网桥不知道的情况他会直接一口气把所有端口都发个遍（除了发送端），然后必然将正确的那个端口与目的地对应的信息存在哈希表内。\n而后向学习法（backward learning）则是用来学习发送端的算法，比如网桥知道发送站点A发送到1端口，那么1端口肯定和A对应。这两个算法也印证了“学习”这两个字。\n泛洪算法会不断运行，同样也会有某个特殊进程将“错误出现的信息“剔除，比如某台电脑关机，换了个地方又开机，那么电脑在几分钟之内就会重新回到正常状态。\n直通式交换/虫孔路由：帧还没输入完，刚输入地址信息就可以进行转发\n\n&nbsp;\n生成树网桥\n网桥和网桥之间允许冗余多个链路，也就是出现多个目的一致的端口用于增加容错，但前提是解决泛洪算法带来的拓扑环路。\n泛洪算法能分辨发送方但分辨不出端口，多个冗余端口会导致信息在两个端口之间不断发送不断”泛洪“\n\n解决方法自然是避免这种拓扑结构出现，有一种思路是”默认拓扑结构的存在，但不承认拓扑结构的存在“——物理上用冗余连接网桥，但实际传输的时候约定好不走某几条路，并让剩下能走的路组成一颗树的形式。这种构造生成树的算法便被标准化为IEEE802.1D。\n这种算法需要关注的方面还包括：站点之间的最短路径、路径的最低标识、”忽略“的路径等等。\n&nbsp;\n虚拟局域网WLAN\n试想一座大楼，一个大公司共用一个局域网，网络的级别已经远远大于公司不同组织部门级别了。网络当然是相互连接的，但网络管理员有义务将用户分为不同的组，以便完全性与网络负载分配考虑。还有一个原因是网络广播，试想一下泛洪算法在处理大型LAN的时候的流量损失量，网络管理员需要将网络分组以限制这些”广播“所产生的流量。\n&nbsp;\n\n","categories":["计算机网络"]},{"title":"光栅化与抗锯齿浅入","url":"/2023/09/19/%E5%85%89%E6%A0%85%E5%8C%96%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF%E6%B5%85%E5%85%A5/","content":"\n\n\n\n\n9.17\n\n定义透视投影视锥两概念：长宽比、垂直的可视角度\n知道这两个规则后，一个视锥的所有数值都能相互转换\n\nMVP矩阵\n\n\n模型（Model）、观察（View）、观察（Projection）\n局部坐标（局部空间） → 世界坐标 → 观察坐标 → 裁剪坐标 →屏幕坐标\n物体的储存是依赖于自身的坐标系的，如果要将物体摆放在世界坐标上，就要将物体的坐标转换到世界的坐标上，这就是局部坐标到世界坐标的转换，具体如下：\n矩阵缩放——物体模型大小在世界坐标中不一定是原来建模时的尺寸，要按照新建规矩来调整\n矩阵旋转——和缩放一样是依照模型原点为中心的\n矩阵平移——将物体坐标系与世界坐标系对齐\n以上顺序不能改变\n除了这两个矩阵，还有一个重要的矩阵是视图矩阵，粗糙地说就是摄像机矩阵，是以观察者为原点的\n首先是构造世界相机，规定正对方向g，向上方向t，再构造相机坐标系（t×-g），t，-g，也可以说是u，v，w基向量，v向上，方向为w的负向（向上方向未知，其实可以先随便设置，算出叉积后再反过来叉积得出向上向量）\n相机显示出来物体是什么位置，这个时候需要依靠世界坐标和物体坐标的关系，以及世界坐标和相机坐标的关系来计算出相机与物体的关系\n我们不妨这样想：假如世界坐标就是相机坐标，那么现在物体在世界坐标上的位置是已知的，这个位置其实就是需要传给相机的关键信息。那么现在开始将相机坐标系与物体绑定做运动，也就是说物体对于相机来说是不动的，然后将相机移动到原来的需要求的位置上，再将物体移动回去，这样的话整个相机和物体的任何数值都是没变的。有没有发现关键点，那就是在这整个“从未知到已知”的过程中，从相机视角上看就只是“物体本身发生了相机移动的逆运动”。那么这样思路就很清晰了，计算出物体在相机上的位置其实就是把相机移动的逆矩阵乘以物体的世界坐标。又由正交矩阵的逆就是它的转制这个定理，其实就是将相机坐标的转至乘以物体坐标得来。\n这就是将世界坐标转换到观察坐标\n然后到裁剪坐标这一步，这个上一篇已经讲过，其实就是在规定相机的眼睛大小，能看到多少地方，然后将这些“地方”按照一定的规矩展示出来，也就是正交变换或者投影变换\n\n接下来是显示在屏幕上的一些规矩\n&nbsp;\n光栅化\n无论是正交还是透视投影，最终都要转换到[-1,1]的三次方矩阵上，转换后要将这个矩阵在屏幕中显示\n首先定义一下屏幕（光栅成像设备）数据：\n\n一个二维数组（数组中元素是像素）\n屏幕大小（分辨率）——像素多少\n光栅化的类型\n\n\n光栅化：将图片展示在屏幕上\n像素：抽象理解——一个个内部颜色分别一致的单位，不同像素颜色也许不同\n假如说屏幕是一个xy轴，现在有width个x轴上的像素，height个y轴上的像素，那么光栅化的第一步就是将[-1,1]矩阵乘以这样一个数值将它拉到这么屏幕上\n\n这也是视口变换的一步\n\n然后就是将这个物体的二维形态“打散成像素”\n选择三角形作为基本图形的原因：\n\n图形最为简单\n确定的三角形肯定在一个平面之内，内部外部定义非常清楚\n\n\n&nbsp;\n采样法\nfor(int x=0;x&lt;xmax;++x)\n    for(int y=0;y&lt;ymax;++y)\n        image[x][y]=inside(tri,x+0.5,y+0.5);\n\n&quot;判断是否在三角形内&quot;：首先规定三角形的三边方向，然后分别用三边和点进行叉积\n&nbsp;\n采样带来的问题\n\n锯齿——空间采样\n摩尔纹——图片质量问题\n车轮倒转效应——时间采样\n\n\n信号变化太快导致采样速度更不上变化速度\n\n&nbsp;\n走样定义：采样两种完全不一样的函数，得到的确实一个同样的结果\n\n滤波：把某特定频段去除\n首先，先了解一下一张彩色图片的像素成分\n\n从0~255，从黑色到白色，这个叫做像素灰度\n为不同灰度像素赋予颜色，就获得了颜色深度不同的色块，彩色图片比灰色图片多一个维度，也就是颜色的不同，一般的彩色图片都由三原色构成，也就是常说的RGB三原色，深度为3（不过过多了就不涉及了）\n图像的频率，正是图片某段灰度变化剧烈的指标\n一般图片在什么地方灰度变化剧烈呢？那肯定就是图形边缘的部分了，这部分又恰好是锯齿化最为严重的部分\n\n反走样\n\n增加采样率——负担过高，受制于物理限制，不现实\n\n抗锯齿——模糊化后再进行采样\n模糊操作： \n根据每个像素中三角形的覆盖面积来求平均值，最终结果作为本像素的统一颜色（这就是卷积操作）\n\n\n\n\nMSAA：在像素内增加几个采样点，这几个采样点是为单个像素本身来服务的，而不是单纯为了增加采样点。像素内的多出来的像素点用于计算边界覆盖面积平均值，比如像素点内部有四个采样点（4x），其中一个采样点被覆盖，那么这个像素点的覆盖率就是25%，理应计算25%的颜色平均值。\nFXAA：快速近似抗锯齿，后处理，形变抗锯齿，注重性能，和采样无关在图像层面上进行操作\nTAA：时间相关抗锯齿，静止物体上，多次采样求平均分摊到多帧\n&nbsp;\n超分辨率\nDLSS：深度学习方法——将一个小图拉大，会出现锯齿，这个时候用计算机“猜出来”，适用于深度学习方法\n&nbsp;\n\n","categories":["计算机图形学"]},{"title":"传输层","url":"/2023/12/29/%E4%BC%A0%E8%BE%93%E5%B1%82/","content":"\n\n\n\n\n传输层\n\n传输层\n向它的用户（应用层的进程）提供高效的、可靠的和成本有效的数据传输服务\n\n相对于网络层而言，传输层更加注重可靠的传输服务。\n网络层也有定义“负责网络包的传输”，但网络层更加关注的是不同网络之间的包传输，比如分组算法和路由选择最佳路径、寻址等。\n所以说传输层更像是“专注的”用于研究传输的过程的层级，在传输层中往往理解为传输的实体都是“固定的”，传输路径也是“固定的”。在这一章节当中，将会揭示传输层使用什么方式保证可靠连接，以及用途与做法。\n&nbsp;\n\n\n原语发出的包含义\nLISTEN无阻塞，直到某个进程试图与之连接CONNECTCONNECTION REQ主动尝试建立一个连接SENDDATA发送信息RECEIVE无阻塞，直到到达一个DATA包DISCONNECTDISCONNECTION REQ请求释放连接\n\n一个简单的传输服务原语\n\n&nbsp;\n\n\n原语含义\nSOCKET创建一个新通信端点BIND将套接字与一个本地地址关联LISTEN声明愿意接受连接；给出队列长度ACCEPT被动创建一个入境连接CONNECT主动创建一个连接SEND通过连接发送一些数据RECEIVE从连接上接收一些数据CLOSE释放连接\n\nTCP套接字原语\n\n&nbsp;\n寻址\n计算机A上的应用程序a想访问计算机B上的应用程序b，那么他在发出CONNECT请求的时候，必须要知道程序b关联在计算机B上的端口，也叫做TSAP（传输服务访问点），并将自己与计算机A上某个端口关联。\n找到b在B上的TSAP号，就是寻址的过程。\n端口映射器存储了应用程序与端口的对应关系，程序a想要知道程序b的端口，那么先于端口映射器建立连接，返回到b的端口的时候再重新建立连接。\n\n新的服务（应用程序）创建时需要向端口映射器注册\n端口映射器的TSAP必须是广为人知的\n\n\n&nbsp;\n可靠性连接/断开\n某些情况下网络必须做到完全可靠，例如银行汇款、短信传输等，就算并不完全可靠，包可能发生丢失，也需要至少在发生错误的时候进行警告。\n&nbsp;\n三次握手\n\n同步初始序列号\n避免打开历史连接请求\n\n\n过程：\n客户端发送SYN j\n服务端回应SYN k,ACK j+1\n客户端回应ACK k+1\n什么叫“同步初始序列号呢”，首先序列号是按照字节流/数据包排列的，比如第一个发送出去的数据包为1，第二个就是2，接收端知道这样的规律之后就可以分辨认出是否发生错误，在发生错误之后再根据ACK机制回应发送方错误发生了。三次握手就保证经过一次交流之后双方都知道了必须的序列号规律\n\n传输的时候有可能发生丢包现象，也有可能发生延迟现象，想象一下如果第一次握手发出的数据包延迟到达，触发了客户端的重传，此时服务端会接收两个时间不同的数据包。三次握手规定服务端需要接收客户端的回复才开启服务，所以对他来说这两次并无所谓。但试想如果服务端直接开启服务，但开启的这一份服务对客户端来说已经是无效的，客户端一直在等待第二次连接的回应，那么服务端就一直像忘记关闭的电灯泡一样销毁资源。此外，如果服务端一收到SYN就开启服务，那么他接收到这两次重传的SYN之后可以会直接建立两个连接，其中一个永远也接收不到消息，这样就造成了资源浪费。\n总而言之三次握手遵循的就是“在得到对方已经接收到我的信息之前不会开启服务”这样一个谨慎了对策。\n&nbsp;\n四次挥手\n《计算机网络》一书举了一个很巧妙的例子，设想有俩军交战，蓝军从南方和北方将白军包围，现在的设定是白军可以战胜任何一边的蓝军，但两边蓝军同时进攻能战胜白军。\n在可靠连接建立之前消息发送都是不可靠的，也就是说南北方蓝军派出的传信兵随时都可能被白军捕获，试想南边的部队成功发出“明天进攻”的消息，但北方的部队的回应传信兵被白军捕获，这个时候南边部队是不能随意出动的，因为“消息是否成功到达”这个消息对南边部队来说是未知的。\n\n这个例子理论上是没有解决方案的，因为就算我们拥有三次握手协议，甚至四次五次六次无限次，最后一个消息发出方始终是不知道自己发出的消息是否被转达到位，于是始终会犹豫行动（现在终于知道抗战时期电报的重要性了）。\n连接建立的时候只需要三次握手，因为三次握手之后，尽管第三次的消息的传达对于客户端来说是未知的，但其实对于传输的影响不大。试想一下客户端开启服务开始传输数据，而此时服务端由于未接收到第三次握手所以无法开启服务，自然也不会对客户端回应，此时客户端超时，自然也就了解到连接建立失败了，所以连接阶段只要保证服务端不会无限等待下去就行。\n服务端真的会无限等待吗？其实TCP设立了保活计时器来避免这样的意外情况发生，比如连接已经建立之后服务端却突然故障。保活计时器会对服务端接收到的消息计时，如果一定时间内（一遍为两小时）没接收新信息则会强制断开。\n\n而断开连接的时候比连接建立时要多想一层，因为断开连接时需要保证所有数据都传输到位，而不会因为某一方贸然断开连接而产生大量数据丢失。\n过程：\n客户端在发送完最后一个数据后接着发送一个释放请求，并停止发送数组FIN = 1，seq = u\n服务端收到请求后立马发送一个确认ACK = 1，seq = v，ack = u + 1\n服务端等待自己发送完所有数据，在最后一个数据尾接上释放请求FIN = 1，ACK = 1，seq = w，ack = u + 1\n客户端接收到请求，发送确认消息ACK = 1，ack = w + 1，于是服务端释放，客户端在等待2 MSL（Maximum Segment Lifetime，最大报文存活时间）后也释放资源。\n客户端总是比服务端晚释放，等待2MSL的原因是客户端需要确保服务端成功接收到ACK，并等待服务端有可能的重传，如果这段时间客户端收到了重传信息，客户端会重置2MSL的时间；其次，2MSL时间为了考虑最坏情况的发生，既服务端的超时时长\n\n其实三次握手本身就是四次握手，只不过“累积确认”机制使确认帧和序列号帧同时传出，所以合为一次握手。此外四次握手将确认帧和请求帧分开，其实就是保证自己的数据也完全传出，这个时候如果服务端本身就完成了所有数据的传出，那么确认帧和请求帧就可以合并为一次挥手。\n&nbsp;\n可靠性传输\n不错（无比特差错）、不丢（不丢包）、不乱（包按顺序到达）\n\n总览：\n\n流量控制\n拥塞控制\n差错控制\n\n\n&nbsp;\n滑动窗口\n数据链路层中的滑动窗口和传输层中的滑动窗口很像，只不过传输层传输的是报文段或数据包，而数据链路层中传输的是帧。\n滑动窗口协议建立在接收方与发送方各自维护的缓冲区上，缓冲区最初是针对等停协议来建立的，因为数据传输的时候完全等待确认帧到来之后再发送下一个帧是完全不现实的。\n那么就来详细规定一下滑动窗口：\n\n接收方维护一个缓冲区，窗口值等于可以继续接收字节流的大小，维护一系列数据包基序号，检查缓冲区中的数据包序号是否与基序号相匹配。\n发送方维护一个缓冲区，窗口值等于可以继续发送字节流的大小，维护一系列已发送但未收到确认的包列表。\n窗口大小通常以数据包的数量或以字节数来表示。较大的窗口大小可以提高传输效率，但也会增加缓冲区的需求和延迟。较小的窗口大小可以减少缓冲区的需求和延迟，但会降低传输效率。\n两个缓冲区的作用使得字节流根据区域分成了四类：\n\n\n\n\n状态描述\n4发送方尚未发送数据包，接收方未做好准备来接收数据3发送方尚未发送数据包，接收方已做好准备来接收数据2发送方已发送数据包，但尚未收到接收方的确认1发送方已发送数据包，并已收到接收方的确认\n\n如果运行正常，字节流的状态会由2变为1，由3变为2，看起来就好像在向上滑动。\n滑动窗口允许同时发送多个包，提高了利用率，控制滑动窗口的大小以控制数据传输的拥塞情况，也可以通过滑动窗口实现包的选择性重传，这些就是滑动窗口协议的优势\n\n&nbsp;\n流量控制\n流量控制的目的主要是防止发送方速率过快使接收方过载，有停止-等待和滑动窗口控制两者方式，通过控制滑动窗口大小，就能方便地进行流量控制。\n接收窗口会时不时向发送方通知自己还剩多少空间够缓存，这段空间就叫做“通知窗口”，通知窗口为0的时候会发送零窗口通告，直到非0为止。同样，为了防止非零窗口通告丢失，发送方会维护一个定时器用于在等待期间时不时主动查询通知窗口大小。\n此外，还有Clark算法（设置每次非零通告发出的最小等待时间）与Nagle算法（空间存到一定量再发送非零通告）也有助于流量控制。\n&nbsp;\n拥塞控制\n流量控制注重于点对点局部控制，拥塞控制注重于网络报文全局控制\n\n拥塞就是指比如发送方发送速率过快导致网络资源（带宽、缓冲区）无法容纳流量数据的现象，容易导致据包的丢失、延迟增加和网络性能下降。主要控制发送方速率来实现。\n拥塞窗口是发送方缓冲区中的一个参数，拥塞控制基本上就是通过调整这样一个参数来实现的。思路可以从两个方面来进行，那就是拥塞避免与拥塞恢复，分别对应拥塞控制的慢开始与快重传。\n\n慢开始——设置拥塞窗口为一个较小的值——指数增长——到达阈值时线性增长（拥塞避免）——出现超时（发生拥堵），设置阈值为超时窗口的一半——重新慢开始\n快重传：基于慢开始的算法，试想若接收窗口接收到一系列包中存在丢失情况，此时由于等待包更新导致接收窗口一直拥塞。快重传就是当遇到这种情况时立即发送多个冗余确认，使得发送方不需要等待计数器就立马发送丢失的包。报文丢失的情况下很容易发送拥塞，所以在快重传的基础上将拥塞窗口设置为收到三个冗余重传时拥塞窗口的一半，此时的拥塞窗口成为新的慢开始阈值。\n\n\n比如M1、M2、M4，此时接收方收到M4的时候还是会重传M2的ACK，包括M5、M6冗余重传3次，这就是冗余重传\n\n\n\n差错控制\n分为检错重发法、前向纠错法、反馈校验法\n&nbsp;\nTCP\nTCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、有序的、基于字节流的传输层通信协议。\n\n比如连接时需要三次握手，释放时需要三次挥手，这个前文都介绍过。\nTCP是面向字节流的传输协议，即1比特为一组传输数据。其段（一分组）结构如下所示：\n\n\n\n端口：寻址到发送/接收端口的应用进程\n\n序号：即序列号，本帧数据数列号\n\n确认号：即ACK确认机制接收方期望接收到的序列号\n\nTCP头长度：即用来直观显示TCP头长度的（20~40字节），占四位，会随着选项长度改变\n\n标志：\n\nCWR：为1时即告诉发送方拥塞了，需要减少拥塞窗口\nECE：为1说明发送方可以进行显式拥塞通知机制\n\n\n\nURG：需要发送紧急数据是为1，与紧急指针配合使用\nACK：为1说明确认号合法，为0说明无确认信息\nPSH：为1时说明本段不需要等待缓冲区填满，尽快发出\nSYN：为1时申请建立连接，可以说建立连接时发送一个SYN请求\nFIN：为1时申请释放连接，即发送方没有数据发送了\n\n\n\n接收窗口：用于存储接收方缓存的大小量，即还能存多少数据，方便告诉发送方进行流量控制\n\n校验和：与差错检测相关，比如汉明码\n\n紧急指针：指向一个报文段紧急数据位置（偏移量）\n\n选项长度：TPC传输过程中有一些用于功能或者性能优化的选项（选择确认、时间戳等），选项长度就是用来指明选项选择情况的长度（可变）\n\n填充：末尾添加额外字节，用于整个报文段达到一定长度或者对其需求，也可能为了安全性处理。\n\n\n\n&nbsp;\nUDP报文结构较为简单，可以参考UDP协议报文结构_udp报文结构-CSDN博客\n\n&nbsp;\nTCP中的计时器\n重传计时器、持续计时器、保活计时器\n\n重传计时器\n很常提起的一个计时器，比如发出一个段的时候就会立即启用，被确认的时候就会停止计时，超时的时候就会重发，这就是典型的超时重传。\n持续计时器\n上文提到过接收窗口为0的情况，如果零窗口通告丢失的，则发送方和接收方就会发生死锁。那里提到的计时器就是持续计时器，当发送方接收到零窗口通告时会设定一个计数器，比如等待60s进行一次窗口探测。\n保活计时器\n也提到过，就是若某一方发生致命错误崩溃，那么另一方就长时间接收不到消息但仍然处于活跃状态。保活计时器就是通过及时检测长时间收不到消息就会启用调查，若发现另一方不回应则主动直接关闭连接。\n&nbsp;\n总结\n\n回退N和选择重传协议属于差错恢复的两个基本方法，即滑动窗口协议、\nTCP实现可靠性传输的方式有：序列号和确认应答、超时重传、滑动窗口、拥塞控制，UDP想实现可靠性传输就往这方面靠\n传输层面向的是不同主机之间不同进程（应用程序）之间的传输，网络层面向不同主机提供通信服务（选择网络路径）\nUDP特点：面向无连接、尽最大可能交付， 面向报文， 没有拥塞控制， 支持单播、多播、广播的交互通信。\nTCP特点：面向连接 的，提供可靠交付，有 流量控制，拥塞控制，提供 全双工通信，面向 字节流，每一条 TCP 连接只能是 点对点 的（一对一）的传输层通信协议。\n\n\n\n自动重传协议除了滑动窗口的两个基本方法，还包括停等式协议\n\n\n&nbsp;\n图片来自网络侵删\n\n&nbsp;\n\n","categories":["计算机网络"]},{"title":"光线追踪其一","url":"/2023/11/10/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%B6%E4%B8%80/","content":"\n\n\n\n\n光线追踪\n\n光线追踪\n游戏内的光线定义——光线追踪模拟的性质：\n\n光沿直线传播\n光线没有碰撞体\n光线从光源出发到达眼睛\n\n\n光路：光源发出光线的同时，也可以让摄像机发出“感应光”检测到光线（光线的可逆性）\n\n&nbsp;\n光线投射\n1.从摄像机投射一条光线\n2.将光线打到的点与光源进行连线，如果这个点被光源也能看到，则着色\n类似深度缓存，这个交点的“深度”也会被记录\n\n&nbsp;\nWhitted-Style光线追踪\n光线折射——在任意一个交点，只要计算出折射方向，就可以继续传播\n也就是模拟光线不断弹射的过程\n\n\n\n光源会将所有单个点吸收到的光相加，再反应到着色上。\n&nbsp;\nRay-Surface Interface\n首先求光线表面的交点\n\n首先光线定义如下：\n\n那么方程出来了，也就是说在那物体方程与光线方程解方程就行了：\n\n当然，游戏内的光线打入物体这个场景大部分都是在研究三角形\n应用：判断点是否在物体内\n和2D一样的，一个点射出任意射线，如果与封闭物体有奇数个交点，则在物体内，如果有偶数个交点，则在封闭物体外\n\n那么现在开始设想如何让我们知道光线是不是打到物体上了——有一种思路是把物体的所有三角形分别和光线进行计算是否相交，然后取“最近”的点。\n很显然实在太慢了。\n那么先把问题缩小到三角形和光线求交，这个比较简单，有一个很好的方法：\n那就是转换成光线和三角形所在平面相交，然后再计算交点是不是在三角形内。\n首先定义平面——中学知识，法线和固定点定义平面：\n\np为平面内任意点。\n全部过程如下：\n\n&nbsp;\nMT算法（Moller Trumbore算法）\n立即计算出交点是否在三角形内\n\n射线方程与三角形方程写成这个形式，其中三角形方程和重心坐标插值相关\n\n未知数只有t、b1、b2，目的是计算出是否有解，有解则说明有交点\n//解法过程todo\n&nbsp;\n光线表面求交优化（加速）\n&nbsp;\n包围盒\n\n如图所示——如果光线连包围盒都没碰到，那么里面更复杂的物体更不用算了\n看起来很简单，但十分有效\n所以还有什么理由不去学一下包围盒的原理呢？\n&nbsp;\n最常见的包围盒——长方体，也可以叫轴对齐包围盒（AABB）\n生成逻辑：AABB包围盒本质是x轴上的一段距离，y轴上的一段距离，z轴上的一段距离相切出来的长方体\n&nbsp;\n光线与AABB\n先看二维上的：\n\n本质上还是先算光线与形成包围盒的大平面进行相交计算，然后对比不同的线段的交集，回到三维，方法如下：\n1.当光线进入三个对面的所有空间，说明进入盒子了\n2.当光线跳出任意一个对面，说明退出盒子了\n然后记录进入和退出的时间t(enter)=max{t(min)},t(exit)=min{t(max)}.\nt(min)与t(max)意思是单对对面的进入时间与退出时间\n\n判断条件：t(enter)&lt;t(exit)说明光线在盒子里面待了一段时间\n&nbsp;\n问题考虑\n上面都是正常在里面的情况，如果t&lt;0这种情况出现怎么办\n\n如果t(exit)&lt;0说明盒子在关线背后！\n如果t(exit)&gt;=0&amp;&amp;t(enter)&lt;0说明光线起点在盒子里面！\n如果t(enter)&lt;t(exit)&amp;&amp;t(exit)&gt;=0说明光线穿过了盒子！\n&nbsp;\nQ：为什么用AABB\nA：算起来简单——如果光线出现和某一个平面平行的情况（可以把N消掉）\n\n","categories":["计算机图形学"]},{"title":"内存基本概念","url":"/2023/06/04/%E5%86%85%E5%AD%98%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"\n\n\n\n\n按字编址与按字节编址\n\n按字编址与按字节编址\n如今计算机分为32位和64位，其实就是代表总线进行数据传输时一块数据的内存大小，即字的大小\n32位计算机：32位(bit)=4字节(byte)=1字(word)\n64位计算机：64位(bit)=8字节(byte)=1字(word)\n\n很显然一字等于几个字节不是固定的，只和计算机硬件有关\n作为一些基础的编程语言数据类型单位，设定如下(b-&gt;bit,B-&gt;byte)\nbyte：1字节\nshort：2字节\nint：4字节\nlong：8字节\nfloat：4字节\ndouble：8字节\nchar：2字节\nboolean：1字节\nASCII：英文字符（1字节）、中文汉字（2字节）\nUTF-8：英文字符（1字节）、中文汉字（3字节）\nUnicode：英文字符（2字节）、中文汉字（2字节）\n1byte=8bit,1024byte=1KB,1024KB=1MB,1024MB=1GB,1024GB=1TB\n1KB=2的10次方B，1MB=2的20次方B\n\n存放一个机器字的存储单元，通常称为字存储单元，相应的单元地址叫字地址。\n存放一个字节的存储单元，称为字节存储单元，相应的地址称为字节地址。\n如果计算机中可编程的最小单位是字存储单元，则该计算机称为按字寻址的计算机。\n如果计算机中可编程的最小单位是字节，则该计算机称为按字节寻址的计算机。\n一个机器字可以包含数个字节，所以一个存储单元也可以包含数个能够单独编制的字节地址。\n不过题目中一般都是按字节编址，只有按字节编址才利用相应考察\n\n\n例题.某存储器按字节编址，容量为1MB，cache为256B，块大小为4个字，一个字为4个字节。\n（1）cache地址为几位？有多少块？\n（2）主存地址为几位？有多少块？\n\n    答案\n    1MB=2的20次方B，256B=2的8次方B，一个块=16个字节=2的4次方个字节\n    按字节编址，则cache地址位数为8，主存地址位数为20\n    2的八次方/2的四次方=16个块\n    同理主存有2的16次方个块\n\n在写多点就到计组了，让我们回到操作系统内存\n\n三种程序地址装入方式\n\n绝对装入：编译时直接转换（前提是提前知道程序装入模块中的地址）\n静态重定位：编译、链接时地址都是从0开始，装入过程中完成地址转换， 必需分配其要求的全部内存空间，在运行时不能移动\n动态重定位：动态运行时装入，地址转换推迟到程序真正要执行时才进行\n\n\n回顾程序从编译到运行的阶段\n预处理-&gt;编译-&gt;汇编-&gt;链接\n具体详情见“从0开始的C++”栏目//目前还没有！//\n\n总之，装入发生在链接之后，毕竟生成的可执行文件装入到内存中开始运行\n同时，链接也有三种方式\n\n静态链接：程序运行之前将所有所需库函数链接成完成可执行文件（装入）\n装入时动态链接：边装入边链接\n运行时动态链接：执行时需要目标模块时才进行链接\n\n\n&nbsp;\n内存管理\nF&amp;Q：操作系统作为系统资源的管理者，需要对内存进行管理，要管理什么呢？\n\n负责内存空间的分配与回收\n需要提供某种技术从逻辑上对内存空间进行扩充\n需要提供地址转化功能，负责程序的逻辑地址与物理地址的转化\n\n\n三种方式的后两种\n\n\n提供内存保护功能\n\n\n设置上下限寄存器和利用重定位寄存器、界地址寄存器进行判断\n\n&nbsp;\n覆盖与交换\n覆盖：将程序分为多个段，常用的常驻内存，不常用的需要时调入，分为“固定区”与“覆盖区”\n缺点：程序员必须声明覆盖结构，对用户不透明，增加编程负担，且是一直用调用时间交换空间的方式\n\n交换：把不需要的整个进程换出外存，把已具备运行条件的进程换入内存\n中级调度就是这个意义，另外，暂时换出外存等待的进程的状态叫挂起状态\n\nQ&amp;A：1、外存什么位置保存被换出的进程？2、什么时候交换？3、换出什么进程？\n\n换入磁盘中的对换区，所以说对换区采用连续分配方式，输入输出速度比文件区快很多\n在进程运行很多且内存吃紧是进行，例如频繁缺页时\n优先换出阻塞进程，优先级低的进程，驻留时间等。。。（PCB常驻内存）\n\n\n&nbsp;\n连续分配管理方式 \n这种方式的前提是分配的内存空间必须是连续的\n\n\n内存分区历史：\n\n单一连续分配：优点：实现简单，无外部碎片；缺点：只能单任务，空间利用率低，有内部碎片（未利用的内存区）\n固定分区分配：分为相同分区大小与不同分区大小（需要分区说明表）；优点：实现简单，无外部碎片；缺点：会产生内部碎片，内存利用率低\n动态分区分配：不会预先划分内存分区，根据进程大小动态建立分区\n\n\n\n很显然动态分区分配为现代常用的最优分配方式\n所以接下来会以动态分区分配为核心探讨研究\nQ&amp;A：1、每个分配的分区用什么方式来储存？2、多个分区都满足需求时，选哪个？3、如何分配/回收分区？\n\n空闲分区表/空闲分区链\n见“空闲分区算法”\n对于空闲分区表/链，一般情况下修改数据/删除结点（表）就可，不一定会按照地址递增顺序来排列，同时需要将处理过后相邻的空闲分区合并\n\n\n内部碎片：分配给进程的内存区域没用上的部分\n外部碎片：内存中某些空闲分区太小哦啊难以利用(解决方式：“紧凑”技术)\n对于动态分区分配，无内部碎片，有外部碎片\n\n&nbsp;\n动态分区分配算法\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\n#include&lt;functional&gt;\n#include&lt;cstdlib&gt;\n#include&lt;map&gt;\n#include&lt;set&gt;\nusing namespace std;\ntypedef struct//分区\n&#123;\n    static int PartitionNum;//分区数量 \n    int m_PartitionId;//分区首地容量址\n    int m_PartitionSize;//分区\n    int m_BlockId;//空白分区首地址\n&#125;Partition;\n\ntypedef struct&#x2F;&#x2F;进程控制块&#123;    static int PCBNum;&#x2F;&#x2F;进程数量    string m_PidName;&#x2F;&#x2F;进程名称    int m_PidSize;&#x2F;&#x2F;进程大小&#125;PCB;\nvoid ReadData();&#x2F;&#x2F;读入数据void Display1();void Display_Partition();void Display();&#x2F;&#x2F;输出分区完后各个分区的状态void Display_PCB();&#x2F;&#x2F;显示进程的状态void FirstFit();&#x2F;&#x2F;首次适应算法void NextFit();&#x2F;&#x2F;循环首次适应算法void BestFit();&#x2F;&#x2F;最佳适应算法void WorstFit();&#x2F;&#x2F;最坏适应算法\nint main()&#123;    int choose;    while (1)    &#123;        cout &lt;&lt; &quot;请选择实现的算法：&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;*****  1 - 首次适应算法     &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;  2 - 循环首次适应算法 &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;  3 - 最佳适应算法     &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;  4 - 最坏适应算法     &quot; &lt;&lt; endl;        cout &lt;&lt; &quot;  0 - 结束             *****&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;输入你的选择 ： &quot;;        cin &gt;&gt; choose;        switch (choose)        &#123;\n        case 0:exit(0); break;\n        case 1:FirstFit(); break;\n        case 2:NextFit(); break;\n        case 3:BestFit(); break;\n        case 4:WorstFit(); break;\n        default:cout &amp;lt;&amp;lt; &amp;quot;请输入正确的序号：&amp;quot; &amp;lt;&amp;lt; endl;\n    &#125;\n&#125;\nsystem(&amp;quot;pause&amp;quot;);\nreturn 0;\n\n}\n首次适应算法（First Fit）\n每次从低地址开始查找，找到第一个能满足大小的空闲分区\nvoid FirstFit()//首次适应算法\n&#123;\n    bool flag = false;\n    int i, j;\n    string choose;\n    ReadData();\n    //cout &lt;&lt; &quot;输入MIN:&quot;;\n    //cin &gt;&gt; MIN;\n    //Display_PCB();\n    do\n    &#123;\n        Display_Partition();\n        pcb = (PCB*)realloc(pcb, sizeof(PCB)*(PCB::PCBNum + 1));\n        cout &lt;&lt; &quot;输入进程名称：&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidName;\n        cout &lt;&lt; &quot;输入进程大小:&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidSize;\n\n    i = PCB::PCBNum - 1;\n\n    for (j = 0; j &amp;lt; Partition::PartitionNum; j++)\n    &#123;\n        if (pcb[i].m_PidSize &amp;lt;= partition[j].m_PartitionSize)\n        &#123;\n            partition[j].m_PartitionSize -= pcb[i].m_PidSize;\n            partition[j].m_BlockId += partition[j].m_PartitionSize;\n            if (partition[j].m_PartitionSize &amp;lt;= MIN)\n            &#123;\n                partition[j].m_PartitionSize = 0;\n            &#125;\n            flag = true;\n            break;\n        &#125;\n    &#125;\n    if (flag)\n    &#123;\n        flag = false;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配到分区&amp;quot; &amp;lt;&amp;lt; partition[j].m_PartitionId &amp;lt;&amp;lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配失败！&amp;quot; &amp;lt;&amp;lt; endl;\n    &#125;\n    Display1();\n    cout &amp;lt;&amp;lt; &amp;quot;继续分配按Y&amp;quot; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; choose;\n\n&#125; while (choose == &amp;quot;Y&amp;quot;);\n\n}\n最佳适应算法（Bext Fit）\n空闲分区链中分区大小递增排列，每次从链首开始查找，这样就能找到最合适的来分配内存\n缺点：每次都会留下很多越来越小的外部碎片\nvoid BestFit()//最佳适应算法\n&#123;\n    int pos = 0;\n    bool flag = false;\n    int i, j;\n    multimap&lt;int, Partition*&gt; m;\n    multimap&lt;int, Partition*&gt;::iterator ip;\n    string choose;\n    ReadData();\n    //Display_PCB();\n    /*cout &lt;&lt; &quot;输入MIN:&quot;;\n    cin &gt;&gt; MIN;*/\n    do\n    &#123;\n        Display_Partition();\n        pcb = (PCB*)realloc(pcb, sizeof(PCB)*(PCB::PCBNum + 1));\n        cout &lt;&lt; &quot;输入进程名称：&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidName;\n        cout &lt;&lt; &quot;输入进程大小:&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidSize;\n        i = PCB::PCBNum - 1;\n\n    m.clear();\n    for (j = 0; j &amp;lt; Partition::PartitionNum; j++)//按从小带大排序\n    &#123;\n        m.insert(make_pair(partition[j].m_PartitionSize, partition + j));\n    &#125;\n\n    for (ip = m.begin(); ip != m.end();)\n    &#123;\n        if (pcb[i].m_PidSize &amp;lt;= ip-&amp;gt;first)\n        &#123;\n            ip-&amp;gt;second-&amp;gt;m_PartitionSize -= pcb[i].m_PidSize;\n            ip-&amp;gt;second-&amp;gt;m_BlockId += ip-&amp;gt;second-&amp;gt;m_PartitionSize;\n            /*if (ip-&amp;gt;second-&amp;gt;m_PartitionSize &amp;lt;= MIN)\n            &#123;\n            ip-&amp;gt;second-&amp;gt;m_PartitionSize = 0;\n            &#125;*/\n            flag = true;\n            break;\n        &#125;\n        else\n        &#123;\n            ip++;\n        &#125;\n    &#125;\n    if (flag)\n    &#123;\n        flag = false;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配到分区&amp;quot; &amp;lt;&amp;lt; ip-&amp;gt;second-&amp;gt;m_PartitionId &amp;lt;&amp;lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配失败！&amp;quot; &amp;lt;&amp;lt; endl;\n    &#125;\n    Display();\n    cout &amp;lt;&amp;lt; &amp;quot;继续分配按Y&amp;quot; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; choose;\n\n&#125; while (choose == &amp;quot;Y&amp;quot;);\n\n}\n最坏适应算法\n和最佳想法优先使用最大的空闲区，每次排序时按大小递减，所以链首肯定符合\n缺点：大空闲区消耗更快，导致将来的大进程可能难以使用\nvoid WorstFit()//最坏适应算法\n&#123;\n    int pos = 0;\n    bool flag = false;\n    int i, j;\n    multimap&lt;int, Partition*, greater&lt;int&gt;&gt; m;\n    multimap&lt;int, Partition*&gt;::iterator ip = m.begin();\n    string choose;\n    ReadData();\n    //Display_PCB();\n    /*cout &lt;&lt; &quot;输入MIN:&quot;;\n    cin &gt;&gt; MIN;*/\n    do\n    &#123;\n        Display_Partition();\n        pcb = (PCB*)realloc(pcb, sizeof(PCB)*(PCB::PCBNum + 1));\n        cout &lt;&lt; &quot;输入进程名称：&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidName;\n        cout &lt;&lt; &quot;输入进程大小:&quot;;\n        cin &gt;&gt; pcb[PCB::PCBNum - 1].m_PidSize;\n        i = PCB::PCBNum - 1;\n\n    m.clear();\n    for (j = 0; j &amp;lt; Partition::PartitionNum; j++)//按从大到小排序\n    &#123;\n        m.insert(make_pair(partition[j].m_PartitionSize, partition + j));\n    &#125;\n\n    for (ip = m.begin(); ip != m.end();)\n    &#123;\n        if (pcb[i].m_PidSize &amp;lt;= ip-&amp;gt;first)\n        &#123;\n            ip-&amp;gt;second-&amp;gt;m_PartitionSize -= pcb[i].m_PidSize;\n            ip-&amp;gt;second-&amp;gt;m_BlockId += ip-&amp;gt;second-&amp;gt;m_PartitionSize;\n            /*if (ip-&amp;gt;second-&amp;gt;m_PartitionSize &amp;lt;= MIN)\n            &#123;\n            ip-&amp;gt;second-&amp;gt;m_PartitionSize = 0;\n            &#125;*/\n            flag = true;\n            break;\n        &#125;\n        else\n        &#123;\n            ip++;\n        &#125;\n    &#125;\n    if (flag)\n    &#123;\n        flag = false;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配到分区&amp;quot; &amp;lt;&amp;lt; ip-&amp;gt;second-&amp;gt;m_PartitionId &amp;lt;&amp;lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配失败！&amp;quot; &amp;lt;&amp;lt; endl;\n    &#125;\n    Display();\n    cout &amp;lt;&amp;lt; &amp;quot;继续分配按Y&amp;quot; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; choose;\n\n&#125; while (choose == &amp;quot;Y&amp;quot;);\n\n}\n邻近适应算法\n从上次查找结束的位置开始检查，可以减小查找的开销，而且可以防止小空闲分区聚合在链头。另外，空闲分区只需要按地址递增的顺序排列了（可以考虑用循环链表）\n这个方法会将前言所有优点甚至缺点都聚合。。。属于是摆烂算法\nvoid NextFit()//循环首次适应算法\n&#123;\n    int pos = 0;\n    bool flag = false;\n    int i, j;\n    string choose;\n    ReadData();\n    //Display_PCB();\n    /*cout &lt;&lt; &quot;输入MIN:&quot;;\n    cin &gt;&gt; MIN;*/\n    do\n    &#123;\n\n    Display_Partition();\n    pcb = (PCB*)realloc(pcb, sizeof(PCB)*(PCB::PCBNum+1));\n    cout &amp;lt;&amp;lt; &amp;quot;输入进程名称：&amp;quot;;\n    cin &amp;gt;&amp;gt; pcb[PCB::PCBNum - 1].m_PidName;\n    cout &amp;lt;&amp;lt; &amp;quot;输入进程大小:&amp;quot;;\n    cin &amp;gt;&amp;gt; pcb[PCB::PCBNum - 1].m_PidSize;\n    i = PCB::PCBNum - 1;\n\n    for (j = pos;; j++)\n    &#123;\n        if (pos &amp;gt;= PCB::PCBNum)\n        &#123;\n            pos = 0;\n        &#125;\n        if (pcb[i].m_PidSize &amp;lt;= partition[j].m_PartitionSize)\n        &#123;\n            partition[j].m_PartitionSize -= pcb[i].m_PidSize;\n            partition[j].m_BlockId += partition[j].m_PartitionSize;\n            if (partition[j].m_PartitionSize &amp;lt;= MIN)\n            &#123;\n                partition[j].m_PartitionSize = 0;\n            &#125;\n            flag = true;\n            pos = j + 1;\n            if (pos == PCB::PCBNum)\n            &#123;\n                pos = 0;\n            &#125;\n            break;\n        &#125;\n    &#125;\n    if (flag)\n    &#123;\n        flag = false;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配到分区&amp;quot; &amp;lt;&amp;lt; partition[j].m_PartitionId &amp;lt;&amp;lt; endl;\n    &#125;\n    else\n    &#123;\n        cout &amp;lt;&amp;lt; &amp;quot;进程&amp;quot; &amp;lt;&amp;lt; pcb[i].m_PidName &amp;lt;&amp;lt; &amp;quot;分配失败！&amp;quot; &amp;lt;&amp;lt; endl;\n    &#125;\n    Display1();\n    cout &amp;lt;&amp;lt; &amp;quot;继续分配按Y&amp;quot; &amp;lt;&amp;lt; endl;\n    cin &amp;gt;&amp;gt; choose;\n\n&#125; while (choose == &amp;quot;Y&amp;quot;);\n\n}\n&nbsp;\n分页存储管理\n内存空间被分为一个个大小相等的分区，每个分区就是一个“页框“，编号为”页框号“，从0开始。\n页框=页帧=内存块=物理块=物理页面\n页框号=页帧号=内存块号=物理块号=物理页号\n\n进程的逻辑地址空间也被分为与页框大小相等的”页“或”页面“,“页号”从0开始.\n这样就有了一一对应关系\n各个页面不必连续存放，也不必放到相邻页框中\n\n页表\n存放在PCB中,本质是数组\n\n由页号和块号组成，代表了每个页与每个块的一一对应关系\n对于页号，不占用储存空间，因为页号按照数字顺序排列，在数据结构中相当于隐藏数据了\n对于块号，哪怕在题目中，通过内存块的数量推算出页表项中块号所占字节也是一个很重要的考点\n块号不是地址，x号块起始地址为“x*内存块大小”\n\n\n例题：假设某系统物理内存大小为4GB，页面大小为4KB，则每个页表项至少为多少个字节？\n\n    答案\n    内存块大小=页面大小=4KB=2的12次方B\n    4GB会被分为2的20次方个内存块\n    用二进制表示地址，那么要用20bit来表示内存块号\n    按字节编址，则要至少用3B来表示块号\n    每个页表占3B，则储存整个页表至少需要3*（n+1）B\n\n\n地址转换\n进程各个页面是离散存放的，但页面内部是连续存放的\n\n先说结论：\n逻辑地址A对应的物理地址=P号页面在内存中的起始地址+业内偏移量W\n\n例题：页面大小50B。某进程逻辑地址空间大小为200B，则逻辑地址110对应的页号、页内偏移量是多少？\n\n    答案\n    首先易得有四个页\n    页号=110/50=2……10\n    则页号为2\n    偏移量为10\n\n\n由于计算机地址是用二进制表示的，也就是说其实一般情况下题目的计算在计算机中很少发生，而若把页面大小设置为2的整数幂，则可以快速将逻辑地址拆分为页号和页内偏移量\n例如页面大小为4KB，即2的12次方幂B，末尾12位则为页内偏移量\n0号页的逻辑地址范围用二进制表示为：\n00000000000000000000000000000000~00000000000000000000111111111111\n1号页表示范围为：\n00000000000000000001000000000000~00000000000000000001111111111111\n红色即为页号，黑色即为页内偏移量\n此外，最终的物理地址也可以直接通过将物理块号拼接上页内偏移量就能得到物理地址\n如：页表中，1号页面存放的内存块号为9（1001）\n则起始地址为：00000000000000001001000000000000=9*4096=x乘以内存块大小\n总结：对于二进制逻辑地址结构\n有K位表示“页内偏移量”，说明一个页面大小是2的k次方个内存单元\n有M位表示“页号”，说明一个进程最多允许有2的m次方个页面\n\n&nbsp;\n基本地址变换机构\n该机构的具体作用就是在计计算机层面上借助页表将逻辑地址转换为物理地址\n主要核心工具：页表寄存器，存放页表在内存中的起始地址F和页表长度M\n进程未执行时这些东西都是放在PCB中的\nPCB:进程控制块\n\n进程被调度时，内核会把他们放到页表寄存器中，计算过程如下：\n\n根据逻辑地址计算出页号、页内偏移量\n根据页表长度判断页号是否越界\n查询页表，找到页号对应的页表项，确定页面存放的内存块号\n用内存块号和页内偏移量得到物理地址\n访问目标内存单元\n\n\n越界中断：包括对数组的大小进行越界。在这里，判断条件为“P&gt;=M”，则越界，P为页表中的逻辑编号，由于P初始值为0，所以当两者相等时也算越界\n\n总结公式：页表项地址=页表起始地址F+页号P*页表项长度\n即：E=b*L+W\n一些名词区分：\n页表长度：页表中总共有几个页表项\n页表项长度：页表项占的存储空间\n页面大小：一个页面占多大的存储空间\n页表是TMD表，页面是进行具体工作的页面\n\n\n例题：页面大小1K，页号2对应的内存块号b=8，将逻辑地址A=2500转换为物理地址E\n\n    答案\n    一个页面大小1K=2的10次方字节\n    先看是否越界：2500/2的10次方=2余452（偏移量）\n    不满足“P&gt;=M”，不越界\n    再由公式E=b*L+W=8*2的10次方+452=8644为物理地址\n\n页式管理中地址是一维的\n其实在真正的计算机中，每个页面大小和逻辑地址结构其实是物理已知量，不可能有变动的，所以对于系统来说，只要给出逻辑地址，就能自动算出物理地址\n\n&nbsp;\n快表（TLB）\n又称“联想寄存器”，实质是高速缓存而不是内存，用来存放最近访问的页表项的副本\n相应的，内存中页表叫“慢表”\n\nTLB速度很快，但不适合存页表，因为价格太贵，相当于用名牌书包取书本很快，但用一个书包存一整个图书馆的书是很不理智的\n快表的大致内容和慢表是一致的，都有页号和内存块号，而快表的具体作用中“存放最近访问的页表项的副本”以为着存储最近访问的页号和对应内存块号，所以在多次查询相同页号的内容时，只要先查询快表是否命中，若命中则直接使用相应内存块号与内存偏移量相计算，就能快速得出结果。\n所以说，若快表命中，则只需进行一次访存\n若未命中，则需两次访存，当然，查询完慢表后须将内容复制到快表中\n（这里一般会出现一个有关访问逻辑地址平均耗时的问题，注意有时候会出现“系统支持同时查找的情况”）\n为什么快表存放很少的内容会使得速度大幅度提升，这里还是和著名的局部性原理 有关\n\nTLB与Cache：TLB只存有页表项的副本，Cache中可能有其他数据的副本\n&nbsp;\n两级页表\n还是局部性原理\n\n单级页表的问题：\n1、页表必须连续存放，当页表很大时，需要占用多个连续页框\n2、页表没必要常驻内存，进程在一段时间内可能只需要访问某几个特点页面\n解决方法1：将页表进行分组，离散地分入一个个内存块中，为这些分组再建立页表”页目录表&quot;\n解决方法2：需要访问页面时再调入内存（虚拟内存技术）\n\n一些小细节：\n\n多级页表中，各级页表的大小不能超过一个页面,超过的话建立多一级页表\n两级页表的访存次数分析（默认没有快表机制）N+1\n\n\n\n&nbsp;\n分段存储管理方式\n和分页比，离散分配时地址空间的基本单位不同\n\n分段\n按照程序自身逻辑来分为若干个段，每段都有段名，从0开始编址\n分配规则：每个段在内存中占据连续空间，但各段之间可以不相邻\n由于是按逻辑功能划分，所以用户编程更方便，程序可读性更高\n\n段表\n哎，这不是和分页差不了太多吗，头晕了摸了不想看了，有神能评论区指点两下就更好了\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n*\n总结了两天10个小时给累昏了，打游戏都没这么累\n————————————————\n字与字节原文链接：https://blog.csdn.net/qq_43627631/article/details/106456371\n算法代码原文链接：https://blog.csdn.net/weixin_43886592/article/details/107581653\n\n","categories":["操作系统"]},{"title":"光线追踪其二","url":"/2023/11/15/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%85%B6%E4%BA%8C/","content":"\n\n\n\n\n光线追踪其二\n\n。。。继光线打中包围盒之后\n光线追踪其二\n需要更细节的算法来优化包围盒内的光线追踪！\n\n&nbsp;\n统一空间分区（grid网格）\n1.找到包围盒\n2.划分网格\n3.预处理——将每一个找到的对象都存在格子里面（把格子染色）\n\n4.遍历光线经过的“小格子”，若遍历到某些小盒子内含有物体，则在深入检测这个格子内的光线情况\n\n最简单的遍历方法是按照光线方向来进行格子遍历，从而不需要找每一个格子\n\n&nbsp;\n比较有意思的研究方向是可以算出来这种方式对算法的”加速情况“怎么样\n考虑两个极端情况——只有一个格子与全是格子\n只有一个格子——没有加速\n全是格子——遍历格子反而导致算法减速\n所以肯定是在中间有个特殊值可以让算法最优\ncell=C*objs\nC约等于27\n物体分布严重不匀的情况不使用于这个方法——足球场中的茶壶很难找到\n\n&nbsp;\n空间划分\n比如如上物体严重不均的情况下，可以使用空间划分来使物体分布不均的地方格子密度也不一样\n\n&nbsp;\n八叉树\n\n由于在空间当中，所以每一次都是将空间切分为八块，形如二叉树，物体分布越多的地区分的越多——如果格子内的物体小于一定程度，则停止迭代。\n&nbsp;\nKD树\n\n形如八叉树，但是切分规则不同，特点是每一次迭代只砍一刀，而且每一次的”刀口“都不规则。\n&nbsp;\nBSP树\n\n和KD树比起来方向也不一样，缺点是与KD树比起来方向不一样所以根本不方便计算，所以常用的而且研究价值高的是KD树\n&nbsp;\nKD树的数据结构\n\n划分的方向——x轴还是y轴还是z轴\n划分的位置——在这个轴上划分的地方\n子结点——两个子节点\n实际的三角形只存在叶子结点上而不是中间结点上——类似B+树\n\n\n&nbsp;\n光线与KD树\n本质上就是”只和光线相交的叶子结点“进行”不对中间结点进行操作“的二叉树查找\n会发现沿着光线查找的现象和沿着二叉树进行查找的动作是一致的\n\n难以解决的事：很难判定KD树的”刀口“是否与物体真的有交集，或者说”刀口“导致格子直接被物体包含\n\n&nbsp;\nObject Partitions &amp; Bounding Volume Hierarchy（对象分区域边界卷层次结构）——BVH\n划分物体而不是空间\n\n\n核心是：递归地把物体分为几堆，重新计算包围盒\n从代码层面上，每一个物体是不可能出现在不同的包围盒内——不用判定三角形与包围盒求交了\n&nbsp;\n建立BVH的方法\n\n选择划分的尺寸\n要求一：选择最长的那个轴\n要求二：划分点在物体”中间“的位置——指数量上能平衡的点（涉及到快速选择算法）\n\n\n与光线的算法和KD树差不多，不在赘述\n用自己的话说一遍：检测光线射入第一次相交的结点，如果不相交，则直接退出，如果结点本身就是叶子结点，则让光线与该结点的所有物体求交，求出第一次接触的点并退出递归；如果不是叶子结点，算法返回第一次接触的结点，并递归前述过程。\n&nbsp;\n辐射度量学\n与光照强度相关的学问\n\n在前面的学习过程中，例如布林冯模型，光照强度只看作一个简单的常数，现在就开始解析这个数的含义\nRadiant flux（辐射流）\nintensity（强度）\nRadiant Intensity——光源发出的光线强度\n\nirradiance（辐射）——光线汇聚到一个点上的强度\nradiance（光芒）——单个光线传播中能量的度量\n 建议直接看英文\n\n辐射度量学(Radiometry)的基础知识辐亮度拂面清风三点水的博客-CSDN博客\n立体角定义：\n\n面积除以距离平方，也可以得出一个球总的立体角为4🥧\n\n立体角公式：\n如果一个点光源均匀地朝四面八方射出光线，那么从任何一个方向对应的intensity=总power/4🥧\n&nbsp;\n\n","categories":["计算机图形学"]},{"title":"几何学","url":"/2023/09/30/%E5%87%A0%E4%BD%95%E5%AD%A6/","content":"\n\n\n\n\n纹理应用\n\n//补\n纹理应用\n特征：是一块数据，可以做各种查询\n\n\n环境光照（环境贴图/环境映射）\n\n\n纹理可以用来表示环境光，就是将四面八方的光都记录下来\n\n一张房间光照展开\n\n\nSpherical Environment Map\n\n\n将整个环境光记录在一个球上——展开后易产生扭曲问题\n\nCube Map\n\n\n将球的光线打印在它的包围盒上\n\n\n纹理可以影响shading\n\n\n可以通过应用纹理来定义像素间相对高度——导致法线发生变化，使得光线发生变化(法线贴图)\n\n法线贴图/凹凸贴图\n\n\n\n求n方法：先求切线dp=c*[h(p+1)-h(p)]，再将法线逆时针方向旋转90度（dp是高度差，c是法线贴图影响程度，由于计算的是相邻所以只除以1）\nn(p)=(-dp,1).normalized()——这里居然忘了切线法线公式了。。中学数学全还给老师了，其实就是x和y交换，然后x加负号\n在3D中\ndp/du=c1*[h(u+1)-h(u)]\ndp/dv=c2*[h(v+1)-h(v)]\nn=(-dp/du,-dp/dv,1).normalized()\n缺陷：1.边缘无法给出光线影响，会露馅 2。凹凸贴图造成的突起影响不会影响自身，只会单纯反射出本像素的影响过后的光线\n而真正造成位移的叫位移贴图\n\n位移贴图\n\n\n动态曲面细分（openGl）\n\n三维纹理\n\n\n定义了空间中任意一个点的值，使得纹理图不再是单纯的一张2D图，空间中的每一个点值通过经过处理后的三维噪声来计算后得\n\n保存阴影信息\n\n\n纹理可以记录一些之前已经计算好的信息，比如阴影（环境光遮蔽计算），然后将计算好后的值与纹理原本提供的颜色值来相乘计算\n\n体积渲染\n\n\n将存储在空间中的信息存储在纹理中——比如典型医学例子X光片等\n&nbsp;\n&nbsp;\n几何学\n\n隐式几何\n\n\n不会直接的给出几何上面所在的点，而是点满足于特定的关系。\n\n数学公式\n\n\n比如x^2+y^2+z^2=1，表示空间球\n比如f(x,y,z)=0，一般就是指这样的规定关系\n\n但是复杂图形很难给出数学公式\n\n立体几何（CSG）\n\n\n\n\n距离函数\n\n\n空间中的任何一个点到物体表面的最小距离，可以正或者负\n有点像正负点电荷电场图、地理等高线的感觉\n\n具体量化表示方式用水平集表示\n\n如果是寻找单个点是否在图形中，那很方面，但这个方法很难找到所有在图形上的点\n\n显式几何\n\n\n比如使用三角形面片直接把所有顶点表示出来。\n又或者根据映射的方法，对每一个UV都有对应的xyz坐标输出。\n\nf(u,v)=(cosusinv,sinusinv,cosv) 这个函数直接表示xyz点，且uv是已知且一个个都是知道的，可以一个个算出来成图，所有可以说是显示的\n\n缺陷是难以计算点是否在图形上\n&nbsp;\n\n","categories":["计算机图形学"]},{"title":"初识黑红树","url":"/2023/06/01/%E5%88%9D%E8%AF%86%E9%BB%91%E7%BA%A2%E6%A0%91/","content":"\n\n\n\n\n初识黑红树\n\n初识黑红树  \n234树  \n234的含义指一个节点可能含有的子节点个数  \n规则：非子结点的子节点数总是比它含有的数据项多1  \n结点所含数值编写规则有点类似普通树的中序遍历    \n234树的插入  \n\n当插入节点没满数据，时，直接插入，可能需要移动一到两个数据  \n若插入节点已满，则需要进行节点分裂来保证234树的平衡//AVL树//  \n\n\n一般情况下，分裂的规则一句话概括就是“将中间数据往上提”  \n   \n但是在多次插入或者插入已知树时，遇到没满节点，需要先插入满其子节点，自身节点需要靠子节点分裂来补充  \n//代码在代码特殊训练中补//  \n##黑红树与234树  \n黑红树就是234树的另类表示方法  \n黑色节点与红色节点结合起来表示234树中的节点  \n规则如下：  \n\n2节点-&gt;黑色单节点  \n3节点-&gt;黑色节点接红色节点（在我目前学习过程中默认左倾）  \n4节点-&gt;黑色节点接两红色节点  \n\n\n特殊黑红树：23树所建立的黑红树（都为左倾红节点，在很多地方简化黑红树的复杂性，所以一般情况下的黑红树优先考虑23树）  \n\n黑红树特性（官方特性）  \n\n节点颜色有黑有红（不是废话？）\n根节点必为黑色（感觉也是废话）  \n所有叶子节点都是黑色（实际情况下这种节点是空节点）  \n任意节点到叶子节点经过的黑色节点数目相同  \n\n\n在23树中，对应黑红树的黑红节点是同一层的，所以只有黑色节点在贡献高度，反应在黑红树中就是黑色完美平衡  \n\n\n不会有连续的红色节点  \n\n\n会产生以下效果：\n\n对于二叉树来说，进行查找插入删除的时间复杂度为O(logn)，但是不足以抵消维护AVL树的成本\n时间复杂度是基于树的高度来的，所以说理论上减少树的高度能低成本降低时间复杂度\n在结点中增加数据显然能降低树高，比如23树，理论上哪怕345678树，结点越高越省\n难点在于从代码层面上生成富数据结点树，于是将23树转化成黑红树\n黑红树具有和二叉树一样的结构，能以O(logn)的时间复杂度进行操作，任何不平衡只需三次旋转\n\n\n插入时  \n黑红树将待插入节点涂成红色  \n\n红色节点的意义：与父节点进行关联  \n\n若出现双红色子节点的情况（即4节点树的情况），黑红树需要在插入后进行调整  \n即树的涂色与旋转  \n\n旋转与AVL树中“上提平衡”如出一辙，所以不再多言  \n\n先说统计结果（基于左旋黑红树）：  \n1、两红子节点,父节点染红，两子节点染黑  \n2、连续红节点，若出现与父节点同属性情况，则将三节点上提右旋，并使新父节点染红，再染黑子节点（与1出现交叉定义）  \n3、连续红节点，若出现与父节点反属性情况，则将两红连续节点左旋，再按照2处理  \n类似结果在23树中有对应插入方式   \n\n删除时  \n删除首要遵循的规则和二叉查找树通用的删除策略一样，即删除后用前驱节点/后继节点来填充  \n删除结点导致的最大后果就是有可能改变了树的黑高，前面已经提到过黑红树一种维持黑色结点平衡的情况，所以说删除后的维护也同样重要。\n注意代码层面上作为叶子结点的空结点NULL视为黑色\n\n这里分多种情况进行操作，设定要删除结点为v，删除后用来填充的结点为u\n先易后难，首先是比较简单的不会改变黑高的情况，那就是u或者v是红色  \n\n直接将替换后的结点染回黑色\n\n然后是复杂的v和u都是黑色结点的情况了，这里会改变黑高，所以分多种情况表示\nv和u都是黑色结点的复杂情况\nu是双黑结点且不是根结点\n先设定u的兄弟结点为s\ns为黑且s的孩子结点至少有一个红色\n(1)s和红色子节点（或者孩子都是红色）按照“LL”排列\n将s的对应红色孩子染黑，然后右旋转（上提）\n\n“双黑结点”即受到删除后待处理结点，处理完后变为单黑结点   “双黑”即占用两黑高位\n\n&nbsp;\n(2)s和红色子节点（或者孩子都是红色）按照“LR”排列\n先将相应红色结点染红，然后小左旋，形成LL的情况\n\n然后和LL一样进行大右旋，平衡黑高\n\n&nbsp;\n(3)s和红色子节点（或者孩子都是红色）按照“RR”排列\n和LL情况相对称,染完色后如图\n\n(4)s和红色子节点（或者孩子都是红色）按照“RL”排列\n和LR情况相对称，染完色后如图\n\n\ns是黑色且s的两个孩子结点都是黑色\n删除后首先将s染红，此时对于父节点来说这个子树达成黑色平衡，但对于整体树来说这个子树少了一树高，所以将父节点标记为双黑结点，即现在开始处理父节点，问题就向上转移向上递归了\n\n若爷爷结点仍然为黑，则把父节点当作问题结点按黑红树标准规则处理，若一直出现题中情况，则直到递归到红色结点停止（直接将该结点染红，则整体树达到黑红平衡！）\n\ns是红色结点\n(1)s是父节点左孩子，对父节点进行右旋操作\n\n注意此时s结点改变对象\n\n发现双黑结点此时形成了 s 是黑色且 s 的两个孩子结点都是黑色的情况  \n那么直接作相应处理就好，而且父节点恰好就是红，可以不用递归\n\n(2)s是父节点右孩子（和上面情况对称罢了）\n\n\nu是双黑结点且为根结点\n直接变单黑就行\n\n","categories":["数据结构与算法"]},{"title":"几何学其二","url":"/2023/11/04/%E5%87%A0%E4%BD%95%E5%AD%A6%E5%85%B6%E4%BA%8C/","content":"\n\n\n\n\n几何学2\n\n点云\n某个坐标系下的点的数据集——XYZ、颜色、分类值......\n&nbsp;\nObject File\n定义空间中点、法线、纹理坐标的文件\n\n\nv——表示每一次加一个点\nvn——六种不同的法线\nvt——十二个纹理坐标\nf——点与点之间的连接关系（哪三个点能形成三角形）\n\n\n&nbsp;\nCurves（曲线）\n不会出现突转的曲线——常用于摄像机移动或特殊模型\n\n&nbsp;\n贝塞尔曲线——用一系列控制点来定义曲线\n\n例如：p0p1定义起点方向，p2p3定义终点方向\n&nbsp;\nde Casteljau算法——给点一系列任意多个的控制点画出曲线\n首先试想一下计算机会如何处理画线，比如用一个t当作实时时间，那么计算机会沿着t的变化而一点一点地将点给找出来。de Casteljau算法的作用就是从任意一个t找出点的算法。\n\n假设t是位于0~1之间大概三分之一的位置，那么b01就是b0与b1之间三分之一位置，b11同理，然后b02就是b01与b11之间三分之一的位置，这个b02点就是要找的点\n\n&nbsp;\n\n四个点的例子\n经过推导后适合于计算机理解的式子：\n\n\n伯恩斯坦多项式：\n\n\n&nbsp;\nSummary贝塞尔：\n\n曲线必须过起点和终点\n起始位置方向和结束方向和第一段线段和最后一段线段方向一致\n贝塞尔曲线做仿射变换可以直接对控制点做，然后重新画出来——投影不行\n画出的曲线一定在几个控制点的凸包内\n\n\n&nbsp;\n逐段贝塞尔曲线\n多个控制点的情况下的贝塞尔曲线效果并不好，于是分几段来定义贝塞尔曲线\n\n&nbsp;\n\n这个场景属性吗？其实就是画图里面的钢笔工具，就是利用贝塞尔曲线的原理，只不过是将四个点中的中间两个点中的连线给省去了，这种方式在常规贝塞尔曲线中也得到广泛应用\n\n&nbsp;\n逐段连续贝塞尔曲线\n第一段的终值点与第二段的起点是一个点——C0连续\n\n如果在这一个点中的切线也同时连续，则称作C1连续\n也有更多的C2等等...\n&nbsp;\n样条\n&nbsp;\n曲面\n&nbsp;\n贝塞尔曲面\n用贝塞尔曲线延申出贝塞尔曲面\n\n方式是在两个方向上同时运用贝塞尔曲线——类似于之前的双线性插值\n所以两个控制时间就称之为U，V\n&nbsp;\n几何处理\n\n网格细分\n网格精简\n网格正规化\n\n\n\n","categories":["计算机图形学"]},{"title":"几何学其三","url":"/2023/11/09/%E5%87%A0%E4%BD%95%E5%AD%A6%E5%85%B6%E4%B8%89/","content":"\n\n\n\n\n几何学其三\n\n几何学其三\n&nbsp;\n几何处理\n\n网格细分\n网格精简\n网格正规化——delaunay\n\n\n&nbsp;\n网格细分\n相对高度场、凹凸贴图-&gt;制造凹凸效果\n&nbsp;\nLoop 细分：\n1.每一个三角形分为四个\n\n2.调整新三角形以及顶点的位置\n\n\n无论是新顶点还是旧顶点，都要看该点与周围点的权重比。\n&nbsp;\nCatmull-Clark 细分：\n多边形面与三角形面的细分\n\n\n\n对于不是四边形的面叫Non-quad face\n所有度不是4的顶点称为奇异点\n每个面中都添加一个点，每条边的中点也都添加一个点，所有新顶点连接所有边上的新顶点：\n\n\n\n回答：\n\n有几个非四边形面，就会多出几个奇异点，所以现在一共有2+2 = 4个\n新多出来的奇异点的度数与原来所在面的边数相等，如这里就是3度\n第一次细分之后所有面都会变成四边形，且往后奇异点数目不再增加\n\n\n&nbsp;\n如下看：\n\n&nbsp;\n网格简化\n边坍缩（相邻顶点和为一个顶点）与二次误差度量（检查哪几个顶点要合并）\n\n坍缩之后顶点所在位置与原来的边平面垂直距离之和就是误差，如果能在减少顶点的情况下使这个误差尽量小是最好的。\n用例图只是一个2D启发图，实际的情况是这个点与其所相连的所有三角形面片平面\n\n在实际操作过程中，我们想要达成目的大致分为两步\n\n确定收缩哪条边——误差度量\n确定收缩过后新顶点的位置——收缩\n\n\n具体算法可见\n【几何处理】基于二次误差测量的网格简化（二）_garland提出的二次误差测度简化算法-CSDN博客\nLod技术:利用二次误差度量的曲面简化(一) - 知乎 (zhihu.com)\n关键是贪心算法对于顶点对的选择\n&nbsp;\n补充：光栅化过程中的几何阴影\n为实时光线追踪做铺垫\n\n&nbsp;\nShadow Mapping\n点不在阴影里==摄像机能看到这个点，而且光源也能看到这个点\n\n从简单的开始，首先处理点光源产生的光——这种光阴影边缘十分锐利，称作硬阴影\n做法：\n1.从光源角度看场景，记录看到的点，但不着色，只是对图信息做记录\n2.摄像机看场景，将点都投影到光源上，这样就能分辨出看到的点是否被光源看到——实际是查看投影过后同一点对于光源的深度，如果深度相同，则说明是实际看到的。\n&nbsp;\n硬阴影与软阴影\n\n软阴影怎么来的？边缘部分看到的是部分光源，所以光照强度是一个过渡态\n很遗憾点光源肯定没办法软阴影，因为实现软阴影肯定要保证光源有体积\ntodo：要怎样实现软阴影呢\n\n","categories":["计算机图形学"]},{"title":"动态规划","url":"/2023/06/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"\n\n\n\n\n\n\n动态规划の一句话解释\n要点：列出额外空间（通常是哈希表等）来储存计算后的结果，当再次遇到相同计算时直接查表，这样就能剩下大量重复计算的时间，是一种空间换时间的算法。\n实现方法：将待求解的问题分解成若干子问题，先求子问题的解，在反过来得出总问题的解。\n实现步奏：\n\n找出最优解的性质，并刻画其结构特征\n递归定义最优解\n以自底向上的方式计算最优解（求出最优值）\n构造最优解（求出最优解）\n\n\n简单引入例\n一列序列如下，找出最长的递增的子序列长度：\n1，5，2，4，3\n先用肉眼观察，最长的子序列应该是123或者124\n人脑子算起来很方便，对于处理这种简单数据，人脑会本能地自动对123这个顺序列“标记重点”，但对于机器他只能一个一个数去进行对比\n反正，最终得出的答案肯定是某个从第i个数开始到第j个数截止（那么肯定包括i和j）的从小到大的顺序列，所以直接定义从i开始到j的递归函数\nint L(nums,i)&#123;//定义输入操作数组本身和操作数i\n    if(i==sizeof(nums)) return 1;\n    int max_len=1;//最小为1，所以最大的长度为1\n\n    for(int j=i+1;j&amp;lt;sizeof(nums);j++)&#123;//重复检查i之后的所以数据\n\n    if(nums[j]&amp;gt;nums[i])&#123;//找到第一个符合条件的数\n\n            max_len=max(max_len,L(sizeof(nums),j)+1);\n            //将这个数设为操作数i并重新引用自身函数进行递归，找出下一个符合条件的数\n\n            &#125;\n\n    &#125;\n\nreturn max_len;//返回的就是下一个递归的i\n\n}\n上述函数的作用是给出从i开始的数组最长子序列，所以之后我们再将所有数i代入计算出最大的哪个数就是答案\nint length(nums)&#123;\n    int max_len=1;\n    for(int i=0;i&lt;sizeof(nums);i++)&#123;\n        max_len=max(L(nums,i),max_len);\n    &#125;\n    return max_len;\n&#125;\n\n从上述函数可知，我们用L函数得出从i到后面所有数的“最优解”，再用length函数改变i的值，从而算出所有从i到j的所有结果！\n写算法确实爽，计算机开算CPU可能真得烧了，因为这两个函数叠一起时间复杂度竟到达了惊人的\n\n\n这是一个非常恐怖的时间函数，以正常使用的计算机算法中，n^2已经算是比较缓慢的算法，而这个暴力拆解居然达到了恐怖的指数级！\n这个反常识的时间算法是怎么得出来的呢？从所有的i到所有的j的计算，计算机会尝试将所有的i和j给代入然后运算出来，意味着计算机会出现大量的重复计算，比如从第三个到第五个数的计算中包含从第三个数到第四个数的计算，但计算机计算第三个数到第四个数的时候，不会对计算结果进行记忆，还是会傻兮兮地再算一遍😂\n那我们再通过人工干预让他记住计算结果呗，于是我们引入二维数组A【i】，用于记忆从i开始的最长长度。\n#int A[5];\nint L(nums,i)&#123;\n    #if(A[i]!=NULL)&#123;\n        return A[i];\n    &#125;\n    if(i==sizeof(nums)) return 1;\n    int max_len=1;\n\n    for(int j=i+1;j&amp;lt;sizeof(nums);j++)&#123;\n\n    if(nums[j]&amp;gt;nums[i])&#123;\n\n            max_len=max(max_len,L(sizeof(nums),j)+1);\n\n            &#125;\n\n    &#125;\nA[i]=max_len;\n\nreturn max_len;\n\n}\n加#号为增添的代码\n\n\n由于递归对计算机的性能有较大要求，现再写一份非递归的\nint length(nums)&#123;\n    int n=sizeof(nums);\n    int L[5]=&#123;1,1,1,1,1&#125;;\n    for(int i=4;i&gt;0;i--)&#123;\n        for(int j=i-1;j&gt;0;j--)&#123;\n            if(nums[j]&gt;nums[i])&#123;\n                L[i]=max(L[i],L[j]+1);\n            &#125;\n        &#125;\n    &#125;\n    return *max_element(L,L+5);\n&#125;\n\n\n非递归的算法显然地表示了时间复杂度为O（n^2）\n以上例子，明显可以看出解出问题的结构是符合一般结构的\n\n是某个数i到某个数j之间的顺序数列（数字特征，列出后可以用机器方式量化数据）\n递归法写出算法\n迭代法写出算法\n\n\n当然如果需要更详细的信息，则进行步奏4\n基本要素以及01背包\n\n最优子结构\n\n\n在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的最优解逐步构造出整个问题的最优解。在算法中，其子问题往往规模非常小，例如上例所说的“比大小”为最小算法层次，整个算法比了n^2次大小，则时间复杂度就为O（n^2）\n\n重叠子问题\n\n\n即反复重复计算的子问题只解一次，然后将解存入表格中。当再次需要解此子问题时，只需要用常数时间查看一下表格即可\n&nbsp;\n\n","categories":["数据结构与算法"]},{"title":"堆基础","url":"/2023/12/05/%E5%A0%86%E5%9F%BA%E7%A1%80/","content":"\n\n\n\n堆\n\n//很好奇为什么一年前学过数据结构的我为什么对堆没有一点概念\n\n&nbsp;\n大根堆与小根堆\n堆的本质就是以二叉树的顺序存储方式来存元素，从逻辑上看就是一颗二叉树，从结果上看是一颗完全二叉树。堆具有完全二叉树的所有性质，在次基础上规定了一系列新的规则，所以说堆就是一颗特殊的完全二叉树，但是在实际储存是通过动态数组来实现而不是类似二叉树的结点实现。\n// 最大堆的结构体定义\ntypedef struct &#123;\n    int* heapArray;  // 存储堆元素的数组\n    int capacity;    // 堆的容量\n    int size;        // 堆中当前元素的个数\n&#125; MaxHeap;\n\n&#x2F;&#x2F; 二叉树节点的结构体定义typedef struct TreeNode &#123;    int value;                 &#x2F;&#x2F; 节点的值    struct TreeNode* left;     &#x2F;&#x2F; 左子节点指针    struct TreeNode* right;    &#x2F;&#x2F; 右子节点指针&#125; TreeNode;\n&nbsp;\n新的规则：\n大堆指所有子节点都小于他的父节点；小堆指所有子节点都大于他的父节点。\n&nbsp;\n再进入代码层面之前，先回忆/预习一下相关堆性质的知识，比如大堆小堆的意义何在？大堆/小堆在每次进行数据变动的时候都会保持这么一个特性，这个特性在找到某个序列中的前某几个最大值或者最小值中起到了很好的作用，也就是堆排序。\n&nbsp;\n堆排序\n前面说过最大堆的性质就是一直能维护最大数到堆顶，将这个最大的数“剔出”并存起来，在代码层面就是将堆首与堆尾数值交换然后将这个最大值固定，之后再将剩下所有数再次进行堆维护，于是再次将剩下的数中的最大数也就是第二大的数与倒数第二位交换，重复此过程，最终能形成一个顺序数组。\n能这样操作的一个重要前提条件就是堆的实质物理存储其实是可变数组，只是逻辑上是二叉树，所以堆排序重点在于对目标结点的索引，毕竟没有了二叉树结点的指针。\n堆排序看起来很复杂，优势在哪呢？仔细看单个操作流程其实会发现很简单：\n固定最大值——堆首值与左右子结点比较\n固定最大值不用说，这个“比较”仔细一看其实很方便，因为堆的特性，只需要将这个值看作新插入的值，然后一直迭代向下比较就可，时间复杂度和二叉树同理，是O(树高)。\n单次排序是O(树高)，那么n次排序就是O(树高*n)，算上建立堆的时间，总时间复杂度为O(nlogn)。\n由于堆排序可能会导致相等元素改变相对位置，所以这种排序算法是不稳定的。\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid heapify(std::vector&lt;int&gt;&amp; arr, int n, int i) &#123;    int largest &#x3D; i;    int left &#x3D; 2 * i + 1;    int right &#x3D; 2 * i + 2;\nif (left &amp;lt; n &amp;amp;&amp;amp; arr[left] &amp;gt; arr[largest])\n    largest = left;\n\nif (right &amp;lt; n &amp;amp;&amp;amp; arr[right] &amp;gt; arr[largest])\n    largest = right;\n\nif (largest != i) &#123;\n    std::swap(arr[i], arr[largest]);\n    heapify(arr, n, largest);\n&#125;\n\n}\nvoid heapSort(std::vector&lt;int&gt;&amp; arr) {    int n &#x3D; arr.size();\n// Build heap (rearrange array)\nfor (int i = n / 2 - 1; i &amp;gt;= 0; i--)\n    heapify(arr, n, i);\n\n// Extract elements from heap one by one\nfor (int i = n - 1; i &amp;gt; 0; i--) &#123;\n    std::swap(arr[0], arr[i]);\n    heapify(arr, i, 0);\n&#125;\n\n}\n&nbsp;\n堆化与建堆\n\n堆化：指在已经是一个堆的基础上，对某个结点进行调整，使之能够达到堆的性质标准，分为向上堆化（上浮）和向下堆化（下沉）操作。堆化操作经常出现在堆结点增加或删除的过程中，其时间复杂度为O(logn)——堆高度\n建堆：将一个无序数组或者其他数据结构转化为一个堆，是一个整体的过程，时间复杂度为O(n)\n\n\n&nbsp;\n堆操作\n堆在进行数据添加与数据删除的过程中，需要时刻保持堆的性质。\n比较简单的操作是堆增加结点，规定直接在堆尾添加，并对其进行向上调整的堆化：\nvoid heap_insert(vector&lt;int&gt;&amp; heap, int value) &#123;\n    heap.push_back(value);  // 将新元素添加到堆的末尾\n    int index = heap.size() - 1;  // 新元素的索引\n\nwhile (index &amp;gt; 0) &#123;\n    int parent_index = (index - 1) / 2;  // 父节点的索引\n    if (heap[parent_index] &amp;lt; heap[index]) &#123;\n        swap(heap[parent_index], heap[index]);  // 交换父节点和新元素\n        index = parent_index;  // 更新索引为父节点的索引\n    &#125; else &#123;\n        break;\n    &#125;\n&#125;\n\n}\n堆的删除一般指删除堆顶元素，因为堆的目的就是维护一个优先队列，无论是大根堆还是小根堆，只有堆顶的元素是确定最大/最小的，所以实际运用情况一般都是删除堆顶元素，然后将堆尾元素放到堆顶，再对其进行向下调整堆化。\nint heap_delete(vector&lt;int&gt;&amp; heap) &#123;\n    if (heap.empty()) &#123;\n        return -1;  // 堆为空，返回一个错误值\n    &#125;\n\nint root = heap[0];  // 堆顶元素\nheap[0] = heap.back();  // 将堆的最后一个元素放到堆顶\nheap.pop_back();  // 删除堆的最后一个元素\nint index = 0;  // 当前节点的索引\nint size = heap.size();\n\nwhile (true) &#123;\n    int left_child_index = 2 * index + 1;  // 左子节点的索引\n    int right_child_index = 2 * index + 2;  // 右子节点的索引\n    int largest_index = index;  // 最大值的索引\n\n    if (left_child_index &amp;lt; size &amp;amp;&amp;amp; heap[left_child_index] &amp;gt; heap[largest_index]) &#123;\n        largest_index = left_child_index;\n    &#125;\n\n    if (right_child_index &amp;lt; size &amp;amp;&amp;amp; heap[right_child_index] &amp;gt; heap[largest_index]) &#123;\n        largest_index = right_child_index;\n    &#125;\n\n    if (largest_index != index) &#123;\n        swap(heap[largest_index], heap[index]);  // 交换当前节点和最大值节点\n        index = largest_index;\n    &#125; else &#123;\n        break;\n    &#125;\n&#125;\n\nreturn root;\n\n}\n//最后有空希望能再总结一下所有常用的排序算法的性质、时间复杂度、实现方法、稳定性等\n\n","categories":["数据结构与算法"]},{"title":"工厂模式详解","url":"/2023/12/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/","content":"\n\n\n\n\n简单工厂\n\n工厂模式是JAVA中常见的一种设计模式，有一定C++多态概念之下最适合优先理解这篇文章C++类多态 | Coding中。。。 (jiuriri.com)。所以这一篇会尽量从我最擅长的C++视角之下来一步步解析工厂各类模式。\n\n简单工厂\n工厂方法\n抽象工厂\n模板工厂\n单例工厂\n\n\n&nbsp;\n工厂\n在面向对象设计模式中，我们经常把代码实现需求形象得描述为工厂生成产品的过程，如果将产生产品的一整个流程代码称为“生产线”，又由于产品的种类有很多种，每一种产品之间又会有细微的区别，为每一件具有细微差别的产品都分配一条“生产线”是不理想的，就好比开一家早餐店，那么采购不同原料只需要交给一位师傅就可以，烹饪不同早点也只需要一位师傅就行，不必要为了单一产品给他单独分配不同的人来干，这样考虑的话，也算是对工厂模式具有了一定概念——也就是在编码过程中逐渐向开闭原则等一系列面向对象设计原则靠拢。\n&nbsp;\n简单工厂\n在学习多态时的第一个例子，其实就是简单工厂的具体实现，也可以使用虚函数说实现了最基础的多态的程序就可以视为简单工厂，所以简单工厂不存在任何现实意义，只能当作教学切入点。\nclass Compute\n&#123;\npublic:\n    virtual ~Compute()&#123;&#125;;\n    virtual void solve()=0; \n&#125;;\n\nclass Dell : public Compute&#123;public:    void solve()&#123;        cout&lt;&lt;&quot;Dell compute&quot;&lt;&lt;endl;    &#125;&#125;;\nclass Lenovo : public Compute&#123;public:    void solve()&#123;        cout&lt;&lt;&quot;Lenovo compute&quot;&lt;&lt;endl;    &#125;&#125;;\nenum COMPUTE_TYPE\n&#123;\n    Dell,\n    Lenovo\n&#125;;\n\nclass Factory\n&#123;\npublic:\n    Compute* produce(COMPUTE_TYPE type)&#123;\n        switch(type)&#123;\n            case Dell: return new Dell;break;\n            case Lenovo: return new Lenovo;break;\n            default: cout&lt;&lt;&quot;fault&quot;&lt;&lt;endl;\n        &#125;\n    &#125;\n&#125;;\n\nint main()&#123;\n    Factory fac;\n    Compute* com=fac.produce(Dell);\n    if(com!=NULL)&#123;\n        com-&gt;solve();\n        delete com;\n        com=NULL:\n    &#125;\n    return 0;\n&#125;\n\n简单工厂由工厂类、抽象产品类和具体产品类构成，他将产品实现的方法抽象化，交付给工厂进行制造的时候只需要给予产品名称就能开始制造。缺点是扩展性很差，增加产品类型的时候需要更改大量源代码。\n简单工厂最明显的缺陷就在于当抽象产品类通过用户接口获取产品的一切数据并交付给工厂之后，工厂对于产品的生产线是十分固执的，也就是说工厂内没有明确的业务流程分组，当需要进行业务调整的时候（增加新产品）需要对整个团队都进行调整（直接修改工厂类），这直接违背了开闭原则中的“对更改封闭”。\n&nbsp;\n工厂方法\n工厂方法模式也就是“经典工厂模式”，拿简单工厂与之对比就更能凸显工厂模式的优势了。\n虽然工厂模式本身还是有不少缺陷，但是我们可以先从最严重的问题开始，我们先整改工厂业务流程，让他至少能“对更改封闭，对扩展开放”。\nclass Factory&#123;\npublic:\n    virtual Compute* produce() = 0;\n    virtual ~Factory()&#123;&#125;;\n&#125;;\n\nclass DellFactory : public Factory&#123;public:    Compute* produce()&#123;        return new Dell();    &#125;&#125;;\nclass LenovoFactory : public Factory&#123;public:    Compute* produce()&#123;        return new Lenovo();    &#125;&#125;\nint main()&#123;\n    Factory* pDellFac = new DellFactory();//先建厂\n    Compute* pDell = pDellFac-&gt;produce();//建立生产线\n    pDell-&gt;solve();\n    delete pDellFac;\n    delete pDell;\n    //之后再想生产其他产品，直接添加新产品类和工厂类，再像这样建立生产线即可\n    return 0;\n&#125;\n\n经典工厂模式最大的特点就是像这样，符合开闭原则，是最精髓的工厂模式。\n再者，就是对这个经典工厂模式进行不断优化。\n&nbsp;\n抽象工厂\n经典工厂使用起来并不是这么顺手，因为生产新类型产品的时候需要重新建立新工厂，还要重新建立新生产线因为工厂理应能生成各种各样的产品，也就是说有没有可能将生产线放入同一个工厂当中呢。\n//略去产品类，这里的产品类新增一个父类，除了原有的compute加一个keyboard，并分别衍生出不同品牌的产品\n//直接开始建立工厂\nclass Factory&#123;\npublic:\n    virtual Compute* ProduceCom() = 0;\n    virtual Keyboard* ProduceKey() = 0;\n    virtual ~Factory()&#123;&#125;\n&#125;;\n\nclass DellFactory : public Factory&#123;public:    Compute* ProduceCom()&#123;        return new DellCompute();    &#125;    Keyboard* ProduceKey()&#123;        return new DellKeyboard();    &#125;&#125;;\nclass LenovoFactory : public Factory&#123;public:    Compute* ProduceCom()&#123;        return new LenovoCompute();    &#125;    Keyboard* ProduceKey()&#123;        return new LenovoKeyboard();    &#125;&#125;;\nint main()&#123;\n    Factory* pDellFac = new DellFactory();\n    Compute* pDellCom = pDellFac-&gt;ProduceCom();\n    Keyboard* pDellKey = pDellFac-&gt;ProduceKey();\n    pDellCom-&gt;solve();\n    pDellKey-&gt;solve();\n    delete pDellFac;\n    delete pDellCom;\n    delete pDellKey;\n    //这就是戴尔电脑和戴尔键盘的完整生产线，戴尔公司真不考虑考虑我吗？\n    return 0;\n&#125;\n\n这里最大的特点是Dell和Lenovo分开建厂了！代价是他们必须为自己的所有产品负责，因为在这种模式中同品牌的不同产品已不再遵循开闭原则。\n在实际生产过程中需要具体设计“抽象程度”，比如电脑肯定要搭配键盘，所以电脑生产线和键盘生产线放在一起看起来是如此理所应当。\n抽象工厂模式和经典工厂模式其实差不太多，可以说经典工厂和简单工厂就是抽象化的两种极端，而抽象工厂就是他们折中的地位。\n\n简单工厂——每次建立新产品生产线都需要修改工厂类\n经典工厂——每次建立新产品生产线都需要增加工厂类\n抽象工厂——建立新产品生产线视抽象程度而定\n\n\n但是还是不够，你见过哪个工厂因为某个产品直接单独建厂或者直接大动干戈换人吗？哪怕是台积电生产芯片也有不同型号的吧\n\n&nbsp;\n模板工厂\n前三种工厂模式能大致描述出整个工厂模式的思想，真正地将“生产产品”这个动作用面向对象的思维描述出来了，也就是从代码层面上真正有了“设计图”、“工厂”、“流水线”的概念。\n现在让我们回忆并总结一下前三种模式的工厂特点，因为我们需要从中发掘缺陷并进行优化。\n\n设计图重要性反而不重要，因为任何产品都需要至少一张蓝图，设计图类无非就是一个归属权的问题，所以在此应该难以进行优化。\n我们更具不同品牌开设了不同工厂（抽象工厂），尽管他们生产的产品是一样的，但可惜品牌之间并不共享生产技术，于是工厂之间完全切割。\n想要新增一些产品要么就改工厂类，要么就新增工厂。\n\n\n目前看来目的十分明确了，就是优化生产过程，因为拥有一张蓝图产出一种产品是理所应当的。所以有没有一种类似秘书助理类能帮助我们直接根据产品“参数”将生产任务发布出去呢？\ntemplate&lt;class AbstractProduct_t&gt;\nclass Factory&#123;\npublic:\n    virtual AbstractProduct_t* Product() = 0;\n    virtual ~Factory()&#123;&#125;\n&#125;;\n\ntemplate&lt;class AbstractProduct_t,class ConcreteProduct_t&gt;class ConcreteFactory : public Factory&lt;AbstractProduct_t&gt;&#123;public:    AbstractProduct_t *Product()    &#123;        return new ConcreteProduct_t();    &#125;&#125;;\n额实际上我还真不是很熟悉C++模板\n\nok现在是共产主义时代，所有工厂都共享其生产资料，所有客户都只需要提交表（含产品品牌、产品参数）给秘书姐姐模板（&lt;class AbstractProduct_t,class ConcreteProduct_t&gt;），让他帮忙辅助规划，就可以直接生产出你想要的产品了！\nint main()&#123;\n    ConcreteFactory&lt;Compute,DellCompute&gt; Factory;\n    Compute* pDellCompute = Factory.Product();\n    //很奇怪，明明工厂类都完全优化完了，\n    //但实际使用的时候要是要一个个将产品名号所对应的工厂或者方法给标识出来\n    pDellCompute-&gt;solve();\n    delete pDellCompute;\n    pDellCompute=NULL;\n    return 0;\n&#125;\n\n&nbsp;\n产品注册模板+单例工厂模板类\n工厂类优化完毕了，新增产品的时候不需要新增工厂类了，也不需要重写工厂类代码了。\n但编写模板工厂类的时候还是会有一个很大的疑惑——那就是我们在写main函数的时候，也就是直接响应用户需求的时候，不是还得要一个个把工厂、生产线都给创建出来然后再一个个按照产品名号去调用他们，也就是说虽然秘书小姐姐帮忙统筹规矩工厂生产规范，但是当我们想要某个品牌的某产品的时候，还是要一个个去汇报签名，这实在是太繁琐了！\n我们需要真正意义上的“万能工厂”，需要我们叫出产品名号后马上得到产品。\n也就是说我们给工厂输入产品名称之后马上得到产品类的对象——于是乎马上能够调用产品功能。\n从模板工厂开始入手，发现最终需要优化的地方在这几句：\nConcreteFactory&lt;Compute,DellCompute&gt; Factory;\nCompute* pDellCompute = Factory.Product();\npDellCompute-&gt;solve();\n\n先建立了某种产品的定制工厂，然后再通过该工厂进行生产。但是如果可以省去“建立工厂”这一步就好了，因为每次代码运行退出该段代码的生命周期之后工厂将会直接消失。\n没有工厂当然生产不了产品，于是我们可以直接将所有产品，或者说将所有需要生产的产品的工厂提前建立，而且永久建立，这里姑且叫他“工业园”，那么是不是可以省去建立工厂这一步呢？\n更为官方的说法，是将对应产品进行“注册”，定义注册类，所有真正需要生产的产品用注册类来完成，而工厂则使用单例模式定义，工厂的职责就是“进行注册”并使用注册类中的方法进行产品取出。\n//基类抽象产品注册类（接口）\ntemplate&lt;class ProductType_t&gt;\nclass IProductRegistrar&#123;\npublic:\n    virtual ProductType_t* CreateProduct = 0;//该类的主要作用，也就是直接进行生产\nprotected://构造函数和析构函数子类可以调用，防止用户进行构造\n    IProductRegistrar()&#123;&#125;\n    virtual ~IProductRegistrar()&#123;&#125;\nprivate://同样拷贝构造函数和运算符也需要保护起来\n    IProductRegistrar(const IProductRegistrar &amp;);\n    const IProductRegistrar &amp;operator=(const IProductRegistrar &amp;);\n&#125;;\n\ntemplate&lt;class ProductType_t&gt;//典型单例模式建立\nclass ProductFactory&#123;\npublic:\n    static ProductFactory&lt;ProductType_t&gt; &amp;Instance()&#123;\n        static ProductFactory&lt;ProductType_t&gt; instance;\n        return instance;\n    &#125;\n    \nvoid RegisterProduct(IProductRegistrar&amp;lt;ProductType_t&amp;gt;* registrar,std::string name)&#123;\n    m_ProductRegistry[name] = registrar;\n&#125;\n//产品注册\nProductType_t *GetProduct(std::string name)&#123;\n    if(m_ProductRegistry.find(name)!=m_ProductRegistry.end())&#123;\n        return m_ProductRegistry[name]-&amp;gt;CreateProduct();\n    &#125;\n    std::cout&amp;lt;&amp;lt;&amp;quot;No product found for&amp;quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;std::endl;\n    return NULL;\n&#125;\n//产品生产，用户对其直接进行调用\n\n//以下单例规定\n\nprivate:&#x2F;&#x2F;比如除了自己完全不让其他人构造    ProductFactory(){}    ~ProductFactory(){}    ProductFactory(const ProductFactory &amp;);    const ProductFactory &amp;operator&#x3D;(const ProductFactory &amp;);\nstd::map&amp;lt;std::string,IProductRegistrar&amp;lt;ProductType_t&amp;gt; *&amp;gt; m_ProductRegistry;\n//用于存储注册过的产品\n\n};\ntemplate&lt;class ProductType_t，class ProductImpl_t&gt;//具体产品注册模板\nclass ProductRegistrar : public IProductRegistrar&lt;ProductType_t&gt;\n&#123;\npublic:\n   // 构造函数，用于注册产品到工厂，只能显示调用\n   explicit ProductRegistrar(std::string name)\n   &#123;\n      // 通过工厂单例把产品注册到工厂\n    ProductFactory&lt;ProductType_t&gt;::Instance().RegisterProduct(this, name);\n   &#125;\n\n   // 创建具体产品对象指针\n   ProductType_t *CreateProduct()\n   &#123;\n      return new ProductImpl_t();\n   &#125;\n&#125;;\n\n抽象注册类定义了产品的生产接口，可以视为将模板工厂中的工厂基类，但原来的工厂类现在变为“管理生产”的类了，此时此刻继承抽象注册类的具体注册类也就对应了一个个的种类不同的产品。单例工厂类通过他们的统一接口来进行调用， 产品的挑选则由用户给出的产品名字来向map中进行寻找，map返回的正是相应接口。\n参考：C++ 深入浅出工厂模式（进阶篇） - 知乎 (zhihu.com)\n&nbsp;\n\n","categories":["设计模式"]},{"title":"吉比特动作游戏设计笔记","url":"/2023/08/16/%E5%90%89%E6%AF%94%E7%89%B9%E5%8A%A8%E4%BD%9C%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0/","content":"\n\n\n\n\n吉比特动作游戏设计\n\n吉比特动作游戏设计\n动作游戏两大重点——打击感（美术资产、动作编辑器）、好玩（游戏设计）\n这种笔记类暂时不供图\n\n&nbsp;\n打击感的设计\n\n策划——拆解竞品\n\n\n少谈“感觉”多谈“现象”\n\n由于每个人理解有差异，难以被量化，需要把重心放在客观存在的、可以被量化的“现象”。\n曾老师对打击感的观点：攻击-&gt;空挥和命中\n\n空挥-&gt;也要体现出角色的帅气和力量（美术、音效）\n命中-&gt;体现出打击瞬间的反应（程序设计）\n\n\n&nbsp;\n\n美术——让玩家感受到游戏的真实感\n\n\n举例——李小龙甩双截棍片段\n双截棍的特点：\n\n起手和收招明显\n武器运动是肢体运动的延申和放大\n武器的运动规矩是我完整的弧形\n\n\n肢体运动-&gt;武器运动-&gt;特效运动-&gt;敌人受击运动\n\n&nbsp;\n举例——《任天堂明星大乱斗》林克的攻击动画设计\n林克攻击分三阶段：\n\nIDLE前摇蓄力阶段\n伤害产生阶段\n后摇保持阶段\n\n\n&nbsp;\n举例——街霸2D到3D的变换\n抽帧动画：\n出腿的极限蓄力pose到极限的舒张pose并不是延续的，无论是2D还是3D，还是到后面多少代。（力量感）\n姿态差别变化：\n随着版本变化，出招姿态会越来越”有型“，越来越符合现实武打美学。\n&nbsp;\n举例——3D游戏的动作美学（挑选部分印象深刻的）\n蓝色协议：每一招都有”反向蓄力“\n鬼泣5（尼禄）：注重每一招的pose留存，每一个动作的运动夸张化，”反向蓄力“在鬼泣角色身上更加明显，更加夸张。\n打击特效的”维新派“与”守旧派“：各有取舍，但把打击特效放在攻击瞬间用于补充”抽帧“造成的视觉效果丢失是一个更广泛的选择。\n打击特效与游戏主题的关系：比如《原神》角色莫娜打出带星星的水花，跟符合角色”占星师“身份。\n打击感设计的”风格化“与”写实化“：谨慎对待”写实“，不能盲目排斥”风格化“。\n尊重游戏多样性：不要盲目”套模板“，《真人快打》系列动作逻辑几乎完全不符合上述经典格斗游戏动作设计，但仍然被市场认可。\n尚未发掘的我国文化遗产：举例bilibli@ZG止戈，动作完全可以搬入游戏，但问题在需求如何提出，动作转变为游戏如何实例化，由于真人武学家的每一个动作都有设计，无法适应游戏的”可操作性“。\n&nbsp;\n\n程序——敏捷开发、快速迭代\n\n\n每个人工种不同，各执所长，对于文化创意总监，稳定产品期望是很重要的。\n动作编辑器，业内常用并认可的一套系统，内含板块技能时间轴，大致含有以下板块：总时间轴、允许转向、转向辅助/位移辅助、指令缓存/动作跳转、攻击框、聚怪框。\n这些都是动作游戏提升手感的细节（取部分）\n\nroot motion：由美术制作的动画驱动逻辑体运动，防止滑步。\n允许转向：维吉尔连招只允许每一招出招瞬间进行改变方向。\n允许移动：盖伦转圈允许完全由程序来操控移动。\n转向辅助：第三人称动作游戏十分常见。\n位移辅助：同上。（不过容易造成滑步）\n持续面对对象：同上。\n指令缓存：玩家指令会储存起来，知道时间到了该运行的时候才开始运行指令。\n事件盒子：指接触受击后打中了角色的事件盒子（往往是一些动作的特殊时间段），就会触发一些新的事件（一般都是防反）。\n推挤：\n传统/新型盒子：各种攻击判定区域等。\n攻击结果判断：破盾等等等等。\n即时判定受击动作：被击中动画瞬间变化。\n硬直状态时长：\n击退击飞（位置发生变化）：\n顿帧：击中敌人后造成帧冻结。\n还有非常多游戏本身特性逻辑……\n\n霸体、受伤后再次受伤（被控制的时候容易出现bug）、拖拽/聚怪盒子、多方向受伤、使敌人改变朝向（前面一个没做好就会这样了）、各种视觉效果\n&nbsp;\n老师给的干货太多了……根本记不过来\n1k字其实并没有记录全面（上课时间太长精力集中时间太长溜号了），但其实也无所谓了，毕竟设计只是一门艺术……\n从曾老师这得到很多启发，非常感谢老师的指导😂\n\n&nbsp;\n游戏“好不好玩”的设计\n策划的核心才能是审美                  ——曾老师\n\n&nbsp;\n从DEMO到产品\n老师用了一个很生动的说法，就是到产品这个路上，其实是发际线脱落的过程（？\n\n在一开始设计Demo的时候，最好事先选择参考模型\n\n\n例子：\n无双：还原IP——成熟生产线、应付监修\n鬼泣：表现力——角色、武器、战斗流派\n黑魂：弱对强——精妙的关卡\n选择Demo的时候，有没有实现考虑一下有什么能力？能确定什么卖点？最重要的是，最好选择自己最喜欢最熟悉的类型，”力往一处使“，能极力体现出这种品类的魅力\n\n&nbsp;\n单次遭遇战\n“马斯洛需求金字塔”：如黑魂重点放在生存，鬼泣重点放在style风格化\n“combat loop”：陷入困境、思考、做出反应、得到反馈、再次陷入困境\n设计要点\n\n机制（开局“自我介绍”，视觉提示等都能暗示机制）、难度控制、（武器）类型契合的特性、代入感\n战斗谜题\n\n环境、怪物属性、数量、能力\n展示事物之间的联系：“技能”是角色和其他事物发生联系的能力（拒绝数值游戏），玩家的行动需要能够产生结果，至少有“好”和“坏”两种结果。\n&nbsp;\n生产线\n生成管线：设计规划\n例子：\n原神有多角色：满足多位玩家的不同喜好需求\n例子：\n夸张化、结合、变形容易导致同质化\n锤子、锯子、斧头已经足够破坏一块木头，如果要强行增加武器类型，增强乐趣味，很容易同质化。所以应该从“难题”入手，将木头换成其他的物体，来增加武器类型，增加乐趣。\n“流派”思维也是这样，一个“难题”需要有多种“解法”，而且这个“解法”最好任意一个都能有“解难题的方式”。\n《怪物猎人》是一个教科书式的例子，每种武器不同战斗模式，不同战斗体验，不同战斗策略，虽然不一定是最优解，但一定有”讨伐成功“的方法，这就是《怪物猎人》成功的一个原因。\n&nbsp;\n总结\n抓住游戏乐趣（策划）、保证生产质量（生产线）\n&nbsp;\n游戏摄像机\n\n多个优秀3D格斗摄像机案例\n\n\n猎天使魔女：攻击敌人进入状态，切换子虚拟摄像机，拉远距离又变回普通越肩视角。\n师傅：一打多，所以程序会计算所有单位位置，当作一个单位放在镜头中央，若打到只剩一个就缓慢进入经典格斗对角视角。\n蝙蝠侠：摄像机运动随着玩家动作决定，比如玩家开始攻击，摄像机才会慢慢转换视角。\n&nbsp;\n后面还有很多比如敌人AI这种，哎时间还是太短了 \n\n&nbsp;\n最后面也聊了很多有关战斗ch的自己的坎坷经历，希望我们这些学员，也希望老师自己能像老师所说的，能坚持作为ch最初的审美吧。\nok，重装前哨一定会买的\n\n","categories":["游戏设计杂谈"]},{"title":"实习总结，不聊技术向","url":"/2024/11/15/%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%8C%E4%B8%8D%E8%81%8A%E6%8A%80%E6%9C%AF%E5%90%91/","content":"\n\n\n\n\n11.11\n\n碎碎念\n本文作于煎熬的离职前二天\n\n决定做游戏\n决定做游戏是一个很伟大的选择。\n小时候就有很多梦想，画漫画、作曲、拍动画电影、做旅行博主，当然也有我现在当作终身职业的，也就是“做游戏”。小时候对游戏开发的印象可能很多停留在策划层面，比如说最近在玩一个什么游戏，那么就会下意识幻想自己想要设计的下一个新角色的技能模组。我一直认为游戏是一个站在文娱产品金字塔尖的存在，因为游戏不仅仅代表玩法本身，他还意味着文案功底、动画技术、工程设计、美术品味、编剧风格、音乐美感...聚集如此之多的维度，游戏是acg中唯一一个需要汇聚多个大工种顶尖人才才能实现的项目，除去优秀的全栈独立制作人以外，我认为低包容性的游戏团队做出来的游戏品质一定不怎么样。再后来接触了编程、计算机图形学等，我对游戏开发人员的仰慕程度再次上升，以致于我一度认为游戏开发学无止境。\n我大学的专业是软件工程，我对读研没有什么看法，因为学校科研氛围十分微妙，往外保研意味着做很多无意义的卷，我不想做这些与目标相违的事，所以早早就埋下本科就业的种子。大概是大二期间，我开始关注大量就业信息，牛客网、boss直聘，这些网站都是很不错的网站，绝大部分一线公司都会在上面发布招聘信息，我开始关注软件工程的市场需求也是从这里开始的。除去我不是很想去的嵌入式、硬件、芯片等行业，再排除算法、大数据、ds这种高要求行业，再排除一些不确定的新兴行业比如大模型ai等，软件行业也就剩下传统的前后端开发和测试开发了。但是谁又能强求一个刚脱离高考没多久的孩子能对生涯有多少规划呢，我对职业根本没任何概念，包括前端后端，我当时连前端后端都不知道是什么，更别提是否感兴趣了。我对钱兴趣也不大，虽然说现在看来薪资水平也从一定角度间接象征了个人能力水平，但是我更希望能去影响力更大的公司就职。\n后来我看到有游戏开发这个路线。\nUnity是我大一一入学就安装好的，但是从来没打开过，说白了还是没印象，Unity能干嘛，做游戏开发又需要干嘛。看就业信息的时候还是发现只对游戏开发感兴趣，哪怕应试教育背景下压抑了这么久的游戏喜好权力，我还是想去做游戏，因为从小养成的游戏鉴赏能力，我希望能和更多的玩家交流。\n我加入了学校的游戏开发社团，社团里有很多厉害的老前辈，也有很多职业老油条校友，大家都很善良。学校也没有所谓游戏开发课程，我不知道怎样才算“对游戏开发努力”，也不知道自己以后在游戏开发行业到底要以一种什么样的姿态站下去。就像小马过河，我根本不敢说“我梦想要干什么”，我害怕会说出太多稚嫩的话，社团里有前辈发某些游戏公开课的资料，学生思维的我也觉得“万事从上课开始”，于是写下了人生中第一份简历发给前辈。\n学校信息：XX\n相关课程与成绩：XX\n喜欢玩的游戏：XX\n我想遍了这辈子玩过的游戏，最后一个模块写了半页简历，但所有内容加起来仍然铺不满一张纸，我不知道是不是所有同学这辈子写的第一份简历也是这样子，忍俊不禁，后来前辈说了两句教我怎么写简历，但是实习、项目这些名词对当时的我来说就是不可触及的邻域，我很害怕去接触这些新东西，也不知道前辈是否真的把我的简陋简历发给了老师，总之就是没有任何后文。\n不过这位前辈现在还在和我交流，目前还在给出我离职后的职业规划建议，不过都是后文了。\n&nbsp;\n神圣的GameJam\n&nbsp;\n然后我决定参加GameJam，这个看起来很能唬人的名词对我来说在适合不过了，因为他是真正的0门槛。我害怕拖累别人，因为我从来没接触过任何游戏开发知识，也不知道怎么学，所以我决定一个人做，有什么不会的操作就网上查。总之我还是决定要做点什么准备好，我从外网上找到了一个看起来很好的2D角色控制器，还原了《空洞骑士》的优秀机制，我也找到了这个作者的开源Github仓库。我花了半个月去看这个仓库做了什么，代码根本看不懂，但是我还是十分佩服我当时的毅力，当时家人组织去旅游，我躺在酒店里也要打开电脑看代码，但我也不知道我到底在看些什么东西。我重新打开了Unity，GameJam的时间限制是48h，我印象很深，我百度上学习如何在scene里面摆场景就花了两个小时，用上了Github里面的开源控制器，看的代码没有起任何作用，我做的最多的事情就是思考为什么原作者的代码复制粘贴过来会显示脚本没挂上。48h我熬了两天夜，我学习了如何制作帧动画，花了很大的功夫弄好了一个跳跃能切换图片的状态机，最后也是走上了游戏初学者的归宿————2D平台跳跃。我应该如何评价我做的第一款游戏呢，大概像是《超级马里奥》的某一个关卡？然后角色踩到特定砖块会变化形态，因为GameJam的主题是“变化”。\n如果我用上第一次打GameJam的态度，用在找工作上，那么我现在应该也不会对秋招发愁了，我也感觉很诧异，因为GameJam就是没有任何回报的交流会，支撑着我前行的，也许是对游戏开发的原始本能。\n再后来又参加了大大小小的游戏比赛，值得关注的是大二暑假，吉比特公司开办的游戏开发训练营，本质上也是一个小型GameJam，但是这个需要简历筛选，算是有一定门槛的了。我之前的没用的GameJam经历在这个时候起了作用，因为至少他能填充简历，让简历看起来像是真的一本正经地想做游戏开发的样子。吉比特的比赛七个人一组，让我认识了形形色色的游戏开发同好，后来又在其他活动里见过这些同学，才发现原来游戏开发是这么小一个圈子。\n再后来，就是腾讯的游戏公开课了，在此之前也是献上了人生中第一次面试给字节跳动的朝夕光年工作室，那一次面试在寝室进行，我紧张到连库是什么都说不清，把我舍友都吓得不轻，从此也就奠定了我和字节跳动没有缘分的基础了，因为字节跳动的面试会看面评，如果一个软件工程的大三学生连库是什么都不知道，那么会被认为是特地来找面试官乐子的。\n紧张流面试\n腾讯的课程上完后给了一次面试的机会，准备面试、等待结果的那几个月像强力老虎钳一样扭转了我的人生去向，那几个月一定是我这辈子最重要的几个月。还是半个月时间，我花了半个月时间总结上一次面试的失败原因，发现原来面试是有八股文的，而且会大量考察计算机基础知识，在这半个月时间内我在牛客网上找其他人的面经，自言自语练习尝试回答面经上的问题。我当时没想到是线下面，半个月后我来到了腾讯北京的总部大楼，马连洼的北京总部楼非常气派，楼内设施也十分现代化，办公区域非常安逸有韵味，不过我更没想到的是这栋楼居然真的成为了我第一份工作的工作地点。\n我在约定的会议室里静静的等待，面试官迟到了几分钟，期间打了个电话给我，发现原来是他搞错会议室了。和我一起来面试的有另一位女生，这里就化名QQ，也是我后来的实习生同事，当时想加微信来着，结果被闯进来的面试官打断了。面试官是后面我的直属leader，后来我们都叫他L哥，看起来很有行业经验。面了半个小时，时间很短，期间我甚至紧张到深呼吸好几次，L哥也安慰我别紧张，我紧张的原因是表述C++多态的原理表述混乱了，我向面试官请求能不能重新回答，得到肯定的答复后慢慢调整了过来，L哥的表情也变得缓和起来，慢慢开始引导我回答一些其他的问题。反问阶段我问他们做的游戏品类是什么，L哥回答是动作类，我脱口而出说我玩《火影忍者手游》很久了，本身也是火影迷，反而是L哥坐不住了，他直接笑着说他就是火影当时的主程序，做火影已经有十年了。走出腾讯总部大楼的那一瞬间我头一次体会到北京的空气居然如此香甜，那一次面试虽有意外，但比字节的面试好太多了，我的心情非常舒畅，觉得面试结果根本无所谓，因为我第一次跨出了面试的这一步。\n第二天腾讯发来了二面的邮件信息，这也是意料之外的一环。果不其然是腾讯魔方工作室的火影手游项目部发起的，据说是老主程亲自推荐。但是这一次面试就没有第一次面试这么顺利了，我凭公开课的印象说自己比较熟悉UE引擎的ai部分，结果我连行为树是什么都没想起来。而且我甚至没意识到火影手游其实是很老的项目，是用的Untiy引擎制作的，我还在吹牛说梦想是成为UE程序员。然后这个流程就中断了，被魔方的航海王项目组拉起面试，因为航海王项目组是使用的UE引擎。\n航海王的面试官，就叫他D哥吧，也是我生涯中非常重要的一位人物，他的面试现场很压力，问题一个接一个连串地来，但是这些问题奇迹般地我还都会，D哥一口气从C++类函数问到UE的垃圾回收，再到计算机图形学的阿尔法测试，当然从我现在的角度看这些都属于基础了，但是对于一个只学习过101，看过半个月八股的人来说确实很奇迹。\nD哥给的面评非常高，乃至于二面的主程面试我的时候看到免评也就匆匆问了几个简单问题就结束了，还附带感叹一句免评非常高，然后说暑假的时候来组里学学lua就结束了。\n整个过程可以说是非常奇迹了。\n因为除去字节那一次幽默面试外腾讯就是我第一次真正有所准备的处女面，能有这个结果确实是想不到。然后是经典hr面试，排序流程，等待hc，这些都是我第一次经历，都是我不敢想的东西。然而这一等就是三个月，从23年等到24年年后，等到D哥直接换了新项目组才给我发offer。\n&nbsp;\n职场\n三月份，也是新学期，我重新回到腾讯北京的总部大楼报道，每天坐两个小时的地铁或者班车通勤。但是却不是航海王组，更不是UE引擎，我跟着D哥来到了新的在研项目做开发，这些都是我入职那会不知道的，我甚至在几个月后都没意识到我其实在新项目，因为在研项目保密级别非常高，游戏名字都没起的那种。而且航海王主程在二面时没有开启摄像头，我没有意识到新项目的北京ld其实不是那位面试官，但我认识L哥和D哥，L哥在这里做主程，感觉知道这些熟人也够了。\n入职第一天我拉了项目代码和资源，还没来得及感叹工业项目体量就是大，D哥就给我排了一个非常大的需求，但是我还是有点害怕不能胜任，因为我的硬经验其实还停留在2D平台跳跃GameJam上。D哥说了句我铭记终生的话：这个用不着担心，我们周六要求加班，不用担心时间不够做不完。\n腾讯ieg北京可以说是一个小而美的地方了，规模非常小，60来人，楼非常大，工区也广，在北京的存在感低，招聘需求也少，但却是实实在在的北京ieg，项目也是好项目。我们项目在北京前后台加起来也就10来个人，前台正式也就4个人，级别都非常高，每次吃饭ld都要拉所有前台带着实习生一起去食堂找吃的，我还和ld是校友，吃饭的时候经常调侃学校的一些骚操作，北京的ld，就化名Y哥吧。D哥培养的意图非常明显，比如第一天就拉大需求带着做，也会教很多专业职能之外的事情，比如要怎么和ld打交道，怎么自然地和Y哥要需求刷存在感等。D哥直白他也是很内向的人，看我不是很主动，希望我不要向他一样也不经常和同事打交道，他说他毕竟有资历，同事都知道他的性格，但我是实习生最好不要这样。\n&nbsp;\n感叹一句真的辜负了D哥的期望，我在后来转去航海王项目组里没做到这一点，转组很累，期末考也很累，我真的不想重新拉拢人际关系，乃至导致后面产生这样的结果，真的很对不起D哥\n\n&nbsp;\n所以说小也有小的好处，北京人少，所以所有事都会拉拢大家一起做，包括一些福利领取之类，反正大家也坐的很近。\n入职的第五天，L哥大老远从深圳赶来北京和我们开会（当时面试也是L哥从深圳出差到北京），会后叫了个馆子，直接拿了两瓶白的（？可以说是我第一次和ld喝酒了，但是其实也不算，因为L哥也就是来贺喜吃饭新人团建，工作上的事谈的也不多，不过不得不说北京人真能喝酒，有一位北京的实习生同事千杯不倒。我敬了D哥一杯，D哥直接微信暗示让我少喝点更别敬他酒，要敬就去找L哥。然后我就喝大了，在厕所吐了个满堂彩，辛亏没人发现，要不然得在ld面前留一个很深的印象了。\n躺在寝室上，我说了很多胡话，当然这些都是我清醒状态下情绪发泄，我和舍友说ld又加了多少hc，去年实习生转正率百分百，和舍友吹牛说ld之后会带我们出国玩，，啊对啊，L哥还说过项目好起来后会带大家去团建。。\n其他同事\n有一位很有善意的同事，就叫他C哥，C哥学历非常顶级，实力也非常强悍，交流思路也很清晰，也很喜欢和实习生交流，更喜欢教实习生一些项目的底层原理。我从C哥这里不仅学到了知识，还学到了对待知识的态度。C哥喜欢打瓦，知道我也打瓦之后，我们每次周五下班一有机会就会开黑到11点，带上深圳的同事一起，我还特地下载了国服的无畏契约。\n劳动节假期前天，D哥说他得请调休假，问我能不能帮他改点bug，直接看他名号下的bug，有空就改改。Y哥也请假了，其他实习生也走了，整个项目组就C哥和我在工作，不过我也没啥工作了，D哥的bug能修的都修差不多了，问了C哥也没别的适合我干的事了。由于错过了火车，我不得不买第二天凌晨的票，于是我把行李直接搬到了公司，打算在公司睡一晚上第二天直接出发去火车站。C哥把他放在公司的小床借给了我，毯子上还标有魔方火影项目部的标。那天和C哥打瓦打到很晚，我在用工位电脑玩不太敢开麦，怕打扰其他同事。C哥邀请我去参加公司的游戏比赛活动，但是发现实习生没有资格参加，他说等你转正了我们明年再一起打。\n北京的正式同事每年都要去深圳出差。后来知道我要去深圳的部门了，最后一天C哥感叹是和我最后一次一起吃饭了，我调侃道没事深圳还能见面，结果我在深圳真见到C哥了，毕竟魔方的部门工位都非常近，C哥直接掏出攒了很久的夜宵卷，请我和原深圳的老同事吃科兴三楼的小火锅。\n我当然是去不了火影部门了，D哥和我说这个很正常，老项目学不到东西，尽量还是去新项目好，我也十分同意这个观点，也就不惦记着火影了。\n班味\n六月份我收到了L哥亲自打来的电话，L哥问我什么时候去深圳，其实在那个时候我才意识我是航海王项目组的人，来新项目一方面是跟着D哥，另一方面是我学校在北京更适合日常在北京的项目实习。L哥的职级非常高，比项目组包括航海王项目组里的所有人都高，他亲自打我电话给我吓得不轻，到深圳新工位的时候L哥甚至亲自到我工位慰问，问我在哪租房，有没有其他需求，我新mt为此也十分惊讶。\nD哥，包括北京的ldY哥以及其他同事，甚至深圳航海王除主程之外的同事，在L哥这个电话之前，都不知道我要转去深圳新组了。这其实也是腾讯做的不是很好的一个方面，就是除需求以外的其他工作安排，ld和同事之间是对不齐的，更离奇的是我的直属ld和直属导师，都不知道这件事。\n稀里糊涂之下火急火燎地就打飞的赶往深圳了，从北到南跨越了大半个中国，气候环境都变化了，也不住学校了，得一个人照顾自己，还有周围人的语气、同事的工作氛围、人际关系，以及最重要的连技术栈也从Unity+C#变成了UE+Lua，一切都要重新开始。这也是我噩梦的开始。\n有人说人往往会把第一份工作当成白月光，所以不会当第一门工作的pua当成一回事，但是我就是觉得深圳的大组，和北京的小组气氛比起来，真的很微妙。\n新的ld，给我安排在了新导师旁边，但是这个导师其实带了有3个实习生，之后还会增加，而且他本人日常200多个bug挂在身上，这个是我从未见过的。新导师教我怎么使用lua，其实还是MVC那一套，短暂熟悉后上手了第一个需求，这个需求需要和其他同事协作，而且半道还被策划砍了一半，导致最终我负责的地方就一个小界面，还是其他同事早就实现过的。水土不服，很不适应新技术，其实说是新技术，不如说是有点老套的框架，有很多我不能理解的点，新导师也解释的不是很清楚，得过且过罢了。\n除了通知我转正失败，以及前不久建议结束实习之外，新的ld从来没和我单独说过任何话。\n半个月后参加了魔方的超新星计划，这个活动我之前聊过一些，已经不想再回味这次经历，毕竟这个活动名义上决定留用，但其实和转正结果关系不大。\n新ld说：你的项目挺有技术深度，但是评委认为不好玩，所以评分比较低，建议留在组内继续学习，参加明年春招，我们组内还有名额。\n无意义的秋招\n魔方今年的项目非常多，转正名额也非常多，整组整组转正的很多，包括我之前在北京呆过的在研项目组，老东家在我后之后又招了几个实习生，有很多只带了一两个月也转正了。网上的吉音也非常多，牛客上时不时就能刷到魔方转正的帖子，都宣称组内基本上都转正了，今年温度很高。航海王项目组，我们几个实习生相互交流的比较多，有一个很厉害的哥们四月份来的深圳，本身其实也没打算转正，超新星阶段没怎么认真做项目，去了好几个提前批，最终成为offer收割机，拿着半成品项目参加的超新星也成功转正。包括之前和我关系很好的北京实习生，就是那一位很能喝的哥们，做的项目也很简单，也拿到了其他公司的offer。\n不过我觉得确实不应该总是看别人吧，那我的情况呢，我很喜欢魔方，决定就在魔方转正了，因为实习时间非常长，也有很多产出，和同事关系也不错。但是我没意料到这不代表我在深圳也是这样的评价。\n很多人嘴上说是一回事，具体做是另一回事，在北京实习的时候就决定多刷题准备秋招，但是转组+期末+适应深圳，我其实并没有准备多少，更何况我心里原本就有底，直接转正不就完了，秋招随便玩玩就好。\n新ld把我推荐给了光子很好的组，线下+线上，我一口气进了三面。再然后就是光子和天美大动荡事件了。我在光子的流程最终结束，不过我倒是觉得更多是我自身的原因。\n后来我又去面试了雷火，也是三面光荣下班，这次是真自身的原因了，链表快排没写出来，充分暴露了一个只会2D平台跳跃的游戏新人的代码水平。再然后的mhyyj，笔试无果，再后来滑铁卢，自信也打没了。\n九月份开始秋招也许不算晚，但是九月份开始准备秋招那可能真的很晚了。\n我每天熬到至少4点睡觉，我已经对莫大的压力本身感到害怕了，秋招甚至得往后稍稍。请的假越来越多，毕竟新ld根本不给我派活，我自己还忙着笔试面试。说是让我学习，但是他连我写在项目个人空间里的学习笔记都没看一眼。\n我和项目组之间产生了一种很奇妙的联系，我属于项目组的人，但我没有任何需要做的事，我和魔方的关系就像藕断丝连中间的那根线，每次上班都要听着同事激烈讨论需求分析，但其实和我已经没有任何关系。看门犬？寄生虫吧大概，好就好在我真能借着“学习”的名义继续待着吃低保边秋招，腾讯的补助还是挺高的。\n两个月后再也没任何面试了，尝试联系了几个还算有名有号的小公司，这个履历确实能让我很轻松拿下简历筛选，但是永远都是一面后石沉大海。\n我确实不知道该怎么办了。\n有offer吗？\n我最终选择了以最狼狈的方式离职。\n其实也有个实习生同事和我的情况很像，比我来得更晚，也是没能转正，多呆了一个月后她立马准备离职了，因为研究生毕业也有一定压力，而且有其他大公司抛出橄榄枝了。\n我和她一起在科兴楼下吃了最后一顿湘菜，逛了会科兴买了最后一根冰淇淋，我成为了那个来的最早、走的最晚、目睹了项目人员变迁，却最终没能转正的家伙。\n导师发来了消息，说上面给压力要尽早离职了，我最近也能感受到，工位非常紧张，我被赶到了会议室办公，甚至会议室都被挤满了，电脑也不够用。我和ld最后打了个招呼，说我离职的话，有可能去找其他项目的机会，ld却还在找我身上的借口，说不是工位不够用，是最近看我学习进度变低了，决定停止实习。\n但是他连一眼都没看过我写在项目空间里的十多份均字万字学习笔记。\n我觉得我就像是个癌症晚期病人，可能早在转组的那一刻就确诊了，超新星结束下达了病危通知书，而我由于没准备秋招，还不得不相信ld会留我到春招。最终这最后一份信任也消散了。\n由于系统上的导师还是D哥，我最后和D哥联系上了，说我要离职了，麻烦审核一下离职信息。\nD哥打了很久的字，但最终只发出了一句话：去其他地方了？还是怎么了？我后来没怎么关注你的实习评级了。\n其他人我也不知道去向了，我可能也不太想去打最后一声招呼了，我不知道春招还有没有机会，但是我写了一个比简历更简的简评，然后按照企业微信通讯录的顺序去找ieg各部门的主程序，将“简简历”发给他们，然后询问是否能加一个私人微信，因为我害怕一旦离职就断联了，就得重新让hr筛选了。\n我可能就是这样，一直没有办法去狠心下来决定人生的走向，一直带有侥幸心理，一直得过且过，一直被动行事，希望别人能看上刚步入及格线的自己，哪怕机率只有百分之一。等下就要面试微信小游戏公司了，其实公司本身知名度不错，但跳入坑中，可能意味着我这辈子都接触不了我想要做的游戏了。但是我有offer吗，我不确定，我可能连跳入坑的资格都没有，今晚的面试能顺利吗，之后会有人约我面试吗，以及明年春招还有机会吗，我最终能有offer吗，我都不知道。\n&nbsp;\n\n","categories":["孩子写着玩的"]},{"title":"操作系统初认识","url":"/2023/05/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E8%AE%A4%E8%AF%86/","content":"\n\n\n\n\n\n\nBlog搭建成功后写的第一篇文章，内容是b站王道考研操作系统笔记  \n目标是加更多的友链（看起来好像目的是建成一个Blog快捷打开器？）  \n以及写一些学习过程中走过的无数弯路，所以现在的Blog还不具有任何参考意义  \n此篇文章中红色代表标重内容，黄底代表记忆内容\n操作系统概念功能目标与特征  \n操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件。  \n画黄线方便答题分点  \n\n一些看起来似乎没什么用的名词解释。。\n\n命令接口：允许用户直接使用\n程序接口：允许用户通过程序间接使用（如dll文件，即系统调用）\n联机命令接口——交互式命令接口：说一句做一句（如cmd）\n脱机命令接口——批处理命令接口：说一堆做一堆（如bat）\n程序接口=系统调用=广义指令\n隔离:处于安全性和稳定性考虑，用户空间程序无法直接执行内核代码（例如：I/O 读写、创建新进程/线程），也无法访问内核数据，必须通过系统调用。\n没有任何软件支持的计算机称为“裸机”\n覆盖了软件的机器称为“扩充机器”或“虚拟机”  \n\n操作系统的特征  \n\n并发  \n易混淆：并发与并行，前者宏观上同时发生（用户看起来）微观上交替发生，后者表示多事件同时发生  \n\n\n共享:互斥共享方式（如不能同时用qq和微信的摄像头）、同时（宏观上）共享方式 \n并发与共享：例子、如两程序同时使用（并发）硬盘资源（共享），所以说两者互为存在条件\ne.g\n\n\n虚拟：物理上的实体变为若干个逻辑上的对应物（用户感受到的）  \ne.g.单核CPU同时处理多个软件（其实是微观上把时间分为多个小段分别处理）\n虚拟技术：空分复用技术（如虚存）、时分复用技术（如虚拟处理器）\n可得，没有并发性也没有虚拟性\n\n\n\n\n\n异步:资源有限，并发的程序执行速度不同不可预知（同样需要并发性）\n\n\n操作系统发展与分类\n\n手工操作阶段：手工速度与机器速度的矛盾导致资源利用率低\n\n\n\n单道批处理阶段：引入“脱机输入/输出技术”，监督程序控制作业的输入、输出。矛盾略微缓解  \n 缺点：内存中只有一道程序运行，CPU大量时间在等待程序运行\n\n\n\n\n多道批处理系统：程序并发，效率提高  \n缺点：没有人机交互功能\n\n\n\n\n分时操作系统：以时间片为单位轮流为各个用户/作业服务。解决人机交互问题  \n缺点：不具有优先处理紧急问题的特性\n\n\n\n\n实时操作系统：能优先响应一些紧急任务，要在严格的时限内处理完事件（及时性和可靠性）\n\n\n硬实时系统：导弹控制等\n软实时系统：火车订票等  \n\n操作系统的运行机制与体系结构  \n指令是处理器能识别、执行的最基础命令  \n\n两种指令：\n1、特权指令：不允许用户程序使用（内存清零等）\n2、非特权指令：***（加法指令等）\n处理器状态（用标志位识别）：\n1、用户态\n2、核心态（特权指令与非特权指令）\n两种程序：\n1、内核程序\n2、应用程序\n两种内核：\n1、大内核：高性能，代码庞大结构混乱难以维护（小体量公司）\n2、微内核：与大内核相反（大体量公司的管理层）  \n中断和异常  \n本质：需要操作系统介入，开展管理工作  \n过程：发生时，CPU立即进入核心态(只有 核心态能处理管理工作，也就是需要特权指令)-&gt;发生后，当前进程暂停，由操作系统进行后续处理-&gt;不同中断不同处理  \n中断是“用户态”到“核心态”的唯一途径  \n核心态到用户态只需要改变程序状态字亦可（特权指令） \n中断分类  \n\n\n&nbsp;来源包括\n内中断CPU内部陷阱(如系统调用)、故障(如缺页)、终止(不可恢复的致命错误，如整数÷0)外中断CPU外部I/O中断请求、人工干预\n\n外中断过程： \n1、检查是否有外部中断信号  \n2、保护被中断的CPU环境（如PSW、计数器、寄存器）\n3、根据中断类型处理程序\n4、恢复原进程CPU环境退出中断，返回原进程继续执行  \n系统调用\n本质：应用程序请求操作系统的服务\n原因：系统中的各种共享资源都由操作系统掌管，所有与资源相关操作都由操作系统代为完成（另外：与资源有关还与特权指令相关）\n作用：保证系统的稳定性和安全性，防止非法操作  \n过程：传递系统调用参数-&gt;执行陷入指令（用户态）-&gt;执行系统调用程序（核心态）-&gt;返回用户程序  \n1、 陷入指令在用户态执行，之后马上引发内中断，CPU进入核心态\n2、 发出系统调用请求发生在用户态，而对系统调用相应处理在核心态进行\n3、 陷入指令是唯一一个只能在用户态执行而不可在核心态执行的执行  \n分类：\n\n进程控制（process control）\n文件管理（file manipulation）\n设备管理（device manipulation）\n信息维护（information maintenance）\n通信（communication）\n保护（protection）\n\n\n其实就是涉及堆系统资源的管理、对进程的控制，需要执行特权指令才能完成，因此系统调用的相关处理需要在核心态下进行\n\n","categories":["操作系统"]},{"title":"数据链路层","url":"/2023/10/17/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"\n\n\n\n\n数据链路层\n\n数据链路层\n设计目标：关注的是点到点、两个临近机器之间的高效的、可靠的关系链接算法。”像一根线又不是一根线“\n\n成帧\n错误控制\n流控制\n为网络层做服务\n\n\n通过协议栈的方式链接到物理层上\n\n&nbsp;\n基本数据交互传递原理\nQ：如何向网络层提供服务？\nA：非确定的面向非链接服务（LANS局域网）、确定的面向非链接的服务（常用于非可靠链接例如无线系统）、确定的面向链接的服务（计时器、序列号、建立的链接）\n&nbsp;\n帧\n很容易说明出统一协议的重要性\n\n结点A与结点B通过点对点的方式链接起来，接收结点必须明确发送出的帧的bits构成、是什么、从哪里开始从哪里结束\n字节计数（DEC：DDCMP）：每一帧的帧首就是计数位，储存了发送的这一帧的大小位数\n如果某一帧首发生错误，那么取址发生错误，容易对后面帧的取址造成严重影响\n\n字节填充：增加一个标志来区别不同的帧，在帧首前与帧尾后增添一个flag\n如果传递的信息内就包含flag等，解决办法如下：\n\n比特填充（HDLC）：起始flag使用比特填充（01111110），若信息内出现连续6个1，那么在第五个1后添加0，在接收的时候自动去除。\n和字节填充比起来更加有效率\n但是两者也都不是完全能避免错误\n\n&nbsp;\n&nbsp;\n差错控制\n确保传输到网络层的所有帧都是要在正确的顺序之上\n\n方式：\n\n向寄件人提供一些有关错误信息的反馈\n如果帧数据完全消失——如果帧的ADC丢失了，或者超时，向寄件人发出警告；管理计时器与帧序列，保证传输的帧是确切的那一个，不多也不少\n\n\n&nbsp;\n典型错误：丢帧（传送过程丢失）——有时候由于噪音，有时候直接从队列中丢失、帧损坏（bits损坏）\n\n错误纠错——FEC：前向纠错\n\n\n更多用于错误率较高的信道上，因为重传的信息也有高概率出错\n\n\n错误检错——Parity check：能够检测出单个bit错误、CRC、ARQ\n\n\n用于高度可靠的信道上（光纤），如果发生错误重传即可\n\n&nbsp;\n流控——缓速接收者不被高速发送者淹没\n两种常用方式进行控制：\nFeedback-based：接收者向发送方发送反馈信息，给与发送方许可来接收更多信息，或者至少告诉发送方接收者正在做什么\nRate-based：该协议的内置机制直接限制发送方的数据传输速率，无需接收方反馈\n\nStop-Wait\n滑动窗口协议\n\n\n&nbsp;\nHDLC and PPP\nElementary Data Link Protocols\n\n首先，假设物理层、数据链路层和网络层都是独立的进程，它们通过来回传递消息进行通信。有助于使概念更加清晰，同时也可以 强调每一层的独立性。 \n许多协议公用的一些声明：\n#define MAX_PKT 1024 /*determines packet size in bytes */\ntypedef enum (false, true&#125; boolean;  /* boolean type */ \ntypedef unsigned int seq_nr;/* sequence or ack numbers */\ntypedef struct (unsigned char data [MAX_PKT]；&#125; packet;/* packet definition */  \ntypedef enum (data, ack, nak&#125; frame_kind; /* frame_kind definition */ \ntypedef struct&#123;/* frames are transported in this layer */ \n    frame_kind kind;  /* what kind of frame is it? */ \n    seq_nr seq;  /* sequence number */\n    seq_nr ack; /* acknowledgement number */\n    packet info; /* the network layer packet */\n    &#125; frame;\n /* Wait for an event to happen； return its type in event. */ \nvoid wait_for_event(event_type *event);\n/* Fetch a packet from the network layer for transmission on the channel. */ \nvoid from_network_layer(packet *p);\n/* Deliver information from an inbound frame to the network layer. */ \nvoid to_network_layer(packet *p); \n/* Go get an inbound frame from the physical layer and copy it to r. */ \nvoid from_physical_layer(frame *r);\n/* Pass the frame to the physical layer for transmission. */ \nvoid to_physical_layer(frame *s);\n/* Start the clock running and enable the timeout event. */ \nvoid start_timer(seq_nr k);\n/* Stop the clock and disable the timeout event. */ \nvoid stop_timer(seq_nr k);\n/* Start an auxiliary timer and enable the ack_timeout event. */ void start_ack_timer(void);\n/* Stop the auxiliary timer and disable the ack_timeout event. */ void stop_ack_timer(void);\n/* Allow the network layer to cause a network_layer_ready event. */ void enable_network_layer(void); \n/* Forbid the network layer from causing a network_layer_ready event. */ \nvoid disable_network_layer(void);\n/* Macro inc is expanded in-line: increment k circularly. */ \n#define inc(k) if (k &lt; MAX SEQ) k = k + 1； else k = 0\n\nUtopia(乌托邦式单工协议)\n不会出现任何错误的协议，不需要考虑任何情况，数据只能单向传输\n\n这个没道理的协议分为发送过程与接收过程。发送过程运行在源机器 的数据链路层上；接收过程运行在目标机器的数据链路层上。唯一需要处理的事件类型是frama_arrival（收到完好帧）\ntypedef enum &#123;frame_arrival&#125; event_type;\n#include &quot;protocol.h&quot;\nvoid senderl(void)&#123;\n    frame s;//buffer for an outbound frame\n    packet buffer;//buffer for an outbound packer\n    while(true)&#123;\n        from_network_layer(&amp;buffer);//go get something to send\n        s.info=buffer;//copy it onto s for transmission\n        to_physical_layer(&amp;s);//send it on its way\n    &#125;\n&#125;\n              \nvoid receiver1(void)&#123;    frame r;    event_type event;    while(trye)&#123;        wait_fot_event(&amp;event);        from_physical_layer(&amp;r);&#x2F;&#x2F;go get the inbound frame        to_network_layer(&amp;r.info);&#x2F;&#x2F;pass the data to the network layer    &#125;&#125;\nstop-and-wait(无错信道上的单工停-等式协议)\n解决发送方以高于接收方能处理到达帧的速度发送帧，导致 接收方被淹没的问题，但是仍然单工\n\n如果升级接收方硬件，使用更强大的接收器，具有更大的缓存与数据处理能力，但是成本较高，容易浪费资源，并只是纯粹将问题转移到网络层。\n就像水龙头与蓄水池，最好的解决方法就是关小水龙头。\n接收方给发送方提供反馈信息：等待对方确认到达后才能继续发送，这样的协议称为停-等式协议。这个模型规定了流量交替关系，只允许发送方发送一帧接收方再发送一帧，依次反复。可以说是采用半双工的物理信道即可。\ntypedef enum &#123;frame_arrival&#125; event_type;\n#include &quot;protocol.h&quot;\nvoid sender2(void)&#123;\n    frame s;//buffer for an outbound frame\n    packet buffer;//buffer for an outbound packer\n    event_type event;/*********/\n    while(true)&#123;\n        from_network_layer(&amp;buffer);//go get something to send\n        s.info=buffer;//copy it onto s for transmission\n        to_physical_layer(&amp;s);//send it on its way\n        wait_for_event(&amp;event);/*********/\n    &#125;\n&#125;\n              \nvoid receiver2(void)&#123;    frame r,s;    event_type event;    while(true)&#123;        wait_fot_event(&amp;event);        from_physical_layer(&amp;r);&#x2F;&#x2F;go get the inbound frame        to_network_layer(&amp;r.info);&#x2F;&#x2F;pass the data to the network layer        to_physical_layer(&amp;s);&#x2F;&#x2F;send a dummy frame*****    &#125;&#125;\nARQ或者PAR(有错信道上的单工停-等式协议)\n现在信道有可能出错，帧有可能损坏，也可能被丢失\n\n发送错误的帧会使得接收方能检测出来，这是这种协议最大的目的。\n在协议二的基础上，增加一个计时器。\n如果接收方受到错误帧，就将其丢弃，那么发送方就会超时，并再次进行发送。\n缺陷是接收方其实并不知道送过来的包是被丢失了，还是被发送了多份过来，他只管进行信息查验。\n试想一下确认帧完全丢失，接收方是不管确认帧的存活的，于是发送方一遍又一遍地进行包发送，接收方一次又一次接收重复的包，并认为这样子是没问题的。\n所以新的需求是让接收方知道收到的帧是新帧还是老帧。\n做法就是在帧头加一个序号，序号的格式需要着重考虑，理论上，需要位数很多，因为包会很多；需要位数很少，因为不能冗余。\n但实际情况发送方选择是否发送新一帧的条件是前一个帧成功完成了流程，也就是说其实帧头序号只需要一个二进制位，因为只需要和前一帧做对比即可。\ntypedef enum &#123;frame_arrival&#125; event_type;\n#include &quot;protocol.h&quot;\nvoid sender3(void)&#123;\n    seq_nr next_frame_to_send;//帧头序号\n    frame s;//buffer for an outbound frame\n    packet buffer;//buffer for an outbound packer\n    event_type event;/*********/\n    next_frame_to_send=0;//initialize\n    from_network_layer(&amp;buffer);//go get something to send\n    while(true)&#123;\n        s.info=buffer;//copy it onto s for transmission\n        s.seq=next_frame_to_send;//帧头写入\n        to_physical_layer(&amp;s);//send it on its way\n        start_timer(s.seq);//timer\n        wait_for_event(&amp;event);/*********/\n        if(event==frame_arrival)&#123;\n            from_physical_layer(&amp;s);\n            if(s.ack==next_frame_to_send)&#123;//要是收到了\n                stop_timer(s.ack);//重置计时器\n                from_network_layer(&amp;buffer);//把下一个信息写入\n                inc(next_frame_to_send);//下一帧头信息（0变11变0）\n            &#125;\n        &#125;\n    &#125;\n&#125;\n              \nvoid receiver3(void)&#123;    seq_nr frame_expected;&#x2F;&#x2F;所期望的帧头    frame r,s;    event_type event;    frame_expected&#x3D;0;    while(true)&#123;        wait_fot_event(&amp;event);        from_physical_layer(&amp;r);&#x2F;&#x2F;go get the inbound frame        if(r.seq&#x3D;&#x3D;frame_expected)&#123;            to_network_layer(&amp;r.info);&#x2F;&#x2F;pass the data to the network layer            inc(frame_expected);        &#125;        s.ack&#x3D;1-frame_expected;        to_physical_layer(&amp;s);&#x2F;&#x2F;send a dummy frame*****    &#125;&#125;\n//解析略，看不懂代码自己看书去\n&nbsp;\n滑动窗口协议\n保证两个方向的数据传输，也就是全双工数据传输\n\n有一种方法是将前面的协议复制一份，一份用来传递数据，一份用来传递确认帧——这样就导致了带宽浪费。这是最差的情况。\n在正常情况下前面的协议其实可以进行双工数据传输，毕竟确认帧的存在已经证实了可以进行双工数据交流。\n捎带确认（piggybacking）指接收方在收到包的时候，确认帧并不马上发出，而是等待下一个要逆向发出的正常包一起发出。\n这样的方法节省了带宽，但不保证时间，因为接收方接收到包与接收方下一个包的发出之间有一定时间，在这个时间内发送方不可能进行下一个包的传输，这样的时间浪费十分可惜。\n可以进行手动操控这个时间，比如设置一个计时器，如果在这段时间内下一个数据包没有到来，那么马上发送单独的确认帧。\n这是一种方法，不过网络传播这么大一个工程，不太可能会为了等待一个确认帧而真的停滞不前了，要知道第一个数据帧的发出是不需要确认帧的，所以有没有可能一次性发出多个数据帧，然后把这些数据帧的信息都保存起来，一个个等候确认帧呢？\n当然这儿的“一次性”并不是真的一次性并发出去了，而是将这一系列待发送的数据包标记，然后一个个待发送。这么一个队列称为“滑动窗口”，当然，多个包的并发使得确认帧头的01失效，必须使用更多的1234...来进行更多帧的标记。\n\n本质上就是对这些帧进行缓存。在进行确认过后或者重发并确认过后再移动窗口。\n&nbsp;\n1位滑动窗口协议\n滑动窗口的缓冲效果是有限的，现在设想这样一个场景，在景区检票口的队列上，检票员如果检查到了有问题的票务，他并不会停下来，而是一边确认有问题的票务，一边继续检查队列后的票务，这样在问题票务解决时，已经被检查过的人员可以保证一股脑放出。但机器代码协议并不像人，普通的滑动窗口协议，这个“出问题的人”会一直将队列拥堵，就好比如果窗口下限一直未解决，且缓冲到了一定限制，那么这个检票口就会一直拥堵。\n这是一个夸张的例子，但是如果把出问题的人单独拉到一边形成队列，让他不堵上窗口，保证后面的正常游客能顺利出游，甚至派专人来调查问题人，也就是说把滑动窗口分裂，是不是就不会造成拥堵了呢？\n但是在我们似乎能进行性能优化之前，我们最好先解决1位滑动窗口协议的一些残留问题。\n发送方与接收方相互发送包，等待确认帧的到来再继续发送下一个包，这只是单方面为信息传递划分了界限、做出了严厉的限制。理想情况的下的发包在实验室外永远不会发生，现实情况下可以会出现以下情况：超时时间设置较短（或者说发送过程时间较长），在第一个包还在发送的过程中就不断超时，然后发送方不断发出重复包。即使没有出现错误的情况下，重复发包仍然会不断浪费宝贵的带宽。\n&nbsp;\n回退N协议\n如果把传输路程夸张化，会发现保护机制变成了纯粹的累赘\n\n如果和月球通信，哪怕信息以光速传播，传播时间也是用分钟来计时，试想一下你玩的网络游戏下一帧要等待几分钟才能加载？\n放宽这个限制是必然的结局，于是我们便有了“滑动窗口”，那么如何找到一个滑动窗口的“容量”呢。从最佳效率解上看，这个容量其实也就是信道传播路程的容量，只要我们能保证信道源源不断地在进行信息传输，那么带宽利用率一定不会低。这个容量由比特/秒的带宽乘以单向传送时间决定，如果一次发送路程可以容纳BD（带宽-延迟乘积）数量的帧，那么w设置成2BD+1，+1指那个确认帧。\n这是最佳效率的容量，也可以说是“最大窗口尺寸”，如果w是一次性发送，或者说是成功发送的帧数，那么链路利用率=w/（1+2BD）\n保持多个帧同时传送的技术是管道化的一个内容，它可以保证如果在传输过程中出现了差错，比如某个帧丢失，那么他后面的那些正在路上的帧的处置方式。\n\n回退N：将后续所有的帧都丢失，不发出确认帧，让发送方直接重新发送。这样的话，大量的错误会=造成大量的带宽浪费。\n选择重传：坏帧丢弃，缓存正常的帧。如果窗口很大，那么这种方式对内存需求很大。\n结合使用：当接收到坏帧时，发送一个否定确认，直接让发送方进行重传，不用等待超时时间。\n\n\n在发送方这边，由于接收方需要将缓存的数据在坏帧重新发送成功时直接输送给网络层，释放缓存空间，所以发送方需要同时将一系列帧都“确认”，这个特性叫累计确认。\n&nbsp;\n选择重传协议\n前面已经暗示了，这个协议需要发送方与接收方各自维护一个缓存区域。\n//协议示例代码过长。。//\n按照惯例，这个协议也应该出现了一点毛病了，那就是“窗口重叠”问题。现在假设一组窗口帧全部丢失的情况，那么发送方不会理会丢失，而是直接发送下一组前序一模一样但内容不一样的帧，接收方在接收到这一组帧的时候返回确认帧，那么这一组确认帧的表现到底是“前一组丢失的帧”还是“这一组正常的帧”呢，发送方无法分辨，接收方就更得知不了了，于是协议“正确”，发送发出了一个错误的包。\n解决方法是限制窗口最大尺寸小于序号空间的一半，这样的话，在任何时候都只会出现一半序号空间数量的待确认的帧，这样就能避免重叠的情况发生。\n&nbsp;\nPPP\n点到点协议\n\nPPP的帧格式酷似HDLC帧格式，区别在于PPP面向字节而不是比特\n\n","categories":["计算机网络"]},{"title":"搭建blog时遇到的问题以及逆天思路逆天解决方案","url":"/2023/05/23/%E6%90%AD%E5%BB%BAblog%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E9%80%86%E5%A4%A9%E6%80%9D%E8%B7%AF%E9%80%86%E5%A4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"这个问题主要出现在next主题的官方配置中，可以自动为文章内的内标题标记并设置侧目录，最重要的是，可以直接点击该小标题跳转至页面内相应位置，如下： \n\n  \n\n\n问题产生时没有黄色高亮  \n\n\n但是我在上传第一篇文章时，发现点击相应小标题不会跳转，甚至黄色高亮也不会显示  \n\n其实一开始并没有注重这个问题，因为blog设计初衷就是为了方便，而且还有其他很多重要功能还没有实现，所以文章上传时图侥幸心理并没有做任何修改  \n\n第一反应是next相应配置文件未修改\n\n但现实情况是配置文件中只有“是否开启”以及相应的格式控制\n看来跳转功能是打包在这个功能内了，是默认开启的  \n\n于是懒狗习惯性各种搜索，百度搜，CSDN搜，GitHub搜\n后来意识到这个问题属于交叉问题（hexo×next主题），在一般搜索引擎甚至专业代码平台上是难以直接搜索到的  \n\n"},{"title":"浅浅记录一下第一次GameJam（solo）经历","url":"/2023/07/11/%E6%B5%85%E6%B5%85%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E7%AC%AC%E4%B8%80%E6%AC%A1GameJam%EF%BC%88solo%EF%BC%89%E7%BB%8F%E5%8E%86/","content":"\n\n\n\n\n\n\n\n现在是2023/7/11，下午的3点钟，距离CIGA Game Jam的作品提交截止日期已经过去了约30个小时。\n在过去的一天里，我睡到下午两点钟，晚上吃了点饭，查看了下作品提交的终端窗口，视频demo总播放数不过百，由于略微带点拖延症的缘故，总结感想并没有第一时间动笔，于是便打开steam玩了会最近比较热门的《潜水员戴夫》，然后就是继续云顶之奕玩到困到手都拿不起鼠标为止。\n这篇回忆录就是在这样的精神状态下写出来的。\n\n2023/07/07\n主题发布的时间是下午的五点钟，然而很早就确定一个人solo的我此刻其实并不是很紧张，毕竟刚接触Unity并没有几个月，无论什么主题最终都要拟合到那个我最擅长的（其实是我唯一会的）的游戏类型领域//可见某ytber2d角色控制器//。但想到最终成果还是要呈现一个至少画风风格要统一的游戏画面，于是我便花了一天时间在Unity上的免费商店里寻找一切有可能能用得上的素材，然而最后能用得上的也就是一个有多种形态的史莱姆，其实不得不说高强度长时间在一个风格完全不同意的素材市场里面细细阅览（特别还是免费素材！）真的有一种审美被qj的快感。。。\n\n至于为什么想着要solo呢，其实最主要的原因是怕坑了人家怕丢人，虽然作为软件工程科班学生，有一定开发基础，各种原理还是很容易能理解的，但好歹C#和Unity只是刚刚起步，自己一个人不行那拉倒无所谓，要是带着团队最后发现是程序不行那整个项目基本上停滞了，不像策划好歹实在不行换程序美术谁都能顶顶，，\n&nbsp;\n主题放出前几天一直在解析那位博主的角色控制器源代码，虽然从结果上看哪怕gj已经结束了我还是对那一批代码一脸懵逼，不过如何使用还是算是半摸透了，当然gj毕竟不是一个比赛，只是一个兴趣开发活动，在gj中学习也是一个很不错的方法。\n&nbsp;\nCIGA 2023 GAME JAM主题：\n\n&nbsp;\n按照gj的一般流程，应该是主题发布那一天晚上团队开始头脑风暴交流确定玩法与初步策划案-&gt;晚上好好休息-&gt;第二天程序与策划开始动工在晚上之前写出一个至少能玩的demo-&gt;不顺利的情况下可能加班熬夜-&gt;第三天补上美术素材并修复bug进行最后评选\n在主题发布的那天晚上我是个什么情况呢？首先是“头脑风暴”，脑海中呈现出无数个与接触有关的想法，什么盲人模拟器啊，点石成金器啊，不过最终果然还是和我一开始想的一样所有的都被推翻，于是我的“头脑风暴”阶段似乎很短（因为什么都没想出来），手上直接开始按照模板开始开发了（于是在主题发布之后24个小时内还停留在模板阶段）\n\n2023/07/08\n我想象中的gj：\n\n\n\n&nbsp;\n实际上线下的gj：\n\n\n&nbsp;\n我实际线上开发的真正环境：\n\n（阴暗的角落）（扭曲地爬行）...中间忘了后面忘了.........\n&nbsp;\n由于是solo，免去了开发必要的讨论与交流，用什么模式，用什么开发，用什么画风，玩什么关卡都存在我脑子里头，一念之间就能实现项目大变革，所以策划案这种东西对我来说似乎也是一种不是很必要的东西。。。\n线上solo比我想象中的要孤独很多很多，周围的人不知道你要干些啥，开发找素材剪视频修bug做关卡这些都得干，遇到bug项目停滞不前的时候经常想着放弃，最后做出了的成品也比人家组队的要差很多很多，然后还缺失了gj很重要的一点精髓就是开发者交流。我脑海里的gj应该是像逛漫展或者郊游似的和志同道合的人一起努力，然而我这边确是一股子算法比赛的画风，不知道的以为我在熬夜刷codeforce。。\n不得不说这种方式还是很适合学习的，因为48h之内的目标就是一个游戏完整的成品，所以完成了一次gj也就相当于完成了一整个微型游戏的开发，整个流程比如程序方面的镜头切换、ui蒙版、脚本对象交流、策划方面的关卡地图设计、美术方面的素材处理、甚至最终剪视频写文案都得一个人完成，这些都是之前志气满满自学Unity所体会不到的\n\n2023/07/09凌晨\n为了完成作品熬的第一夜，回想前24h信心满满却又悠哉游哉项目停滞不前，在这个凌晨瞬间就焦虑了起来，作为一个和画画搭不上半毛钱关系的我现在还在肝像素地图，为了让地图整体像“CIGA”四个字母我修修改改4~5个小时还是没能改成我希望的样子，不过这种东西玩家是看不到的，是一种类似“彩蛋”的东西，对于游戏完整开发并不是很重要，不过这个凌晨精神状态很差意识很模糊，第二天只剩几小时我甚至关卡还没做完，UI还没开始，贴图也没完善，脚本还有bug。哦，当然该砍的不该砍的也基本上砍了个遍，项目整体也渐渐向“能动就行”这个老梗靠近。。。\n\n2023/07/09\n活动群，官方网站，b站都渐渐有了其他队伍作品demo的链接与视频，在下午5点之后甚至开始评审，纷纷开始产出了各类奖项\n\n而我在。。。。。\n\n此时是晚上19：15，而我的pr还刚开始下载。。。\n所以说无论技术有多差，最好还是不要solo的好\n无论结果如何，毕竟是一个交流会，solo很容易把自己搞得灰头土脸还没人搭理，线上就更没意思了。。。\n当然万幸的是还是坚持成为第一批上交作品的队伍了，赶在最后23：59之前把视频链接、网盘链接给上交了\n官方网站\nbilibili\n \n这里也上提取码：\n链接：https://pan.baidu.com/s/1KguIdNwFoD7bf4jJUyDkOQ?pwd=5qie \n提取码：5qie\n最后成品的话，高情商发言就是”完成度很高“，不过也是人生中难得一次如此投入地干一件正经事儿了\n\n\n总结：虽然很孤独难受，但也是一件很开心的48h\n\n","categories":["孩子写着玩的"]},{"title":"测试","url":"/2023/05/19/%E6%B5%8B%E8%AF%95/","content":"在生活中，我们经历了各种挑战和困难，但我们不应气馁或放弃。每一天都是一个新的开始，充满了无限的可能性和机会。无论我们面临怎样的困境，我们都应该坚持下去，勇往直前。努力奋斗，坚持不懈，这是成功的关键。无论前方有多少坎坷和障碍，只要我们拥有坚定的信念和毅力，我们就能战胜一切困难，迎接成功的喜悦。让我们相信自己的能力，发挥自己的潜力，不断努力追求自己的梦想。无论遇到什么困难，我们都要勇敢面对，相信自己的实力，坚信明天会更好。\n\n（果然ai还是乐观的，随机生成的一段话是这样的）\n"},{"title":"深度缓存、光照与纹理","url":"/2023/09/25/%E6%B7%B1%E5%BA%A6%E7%BC%93%E5%AD%98%E3%80%81%E5%85%89%E7%85%A7%E4%B8%8E%E7%BA%B9%E7%90%86/","content":"\n\n\n\n\n深度缓存\n\nQ：为什么先采样再模糊是错误的\nA：因为不先做滤波会导致信号混叠\n深度缓存——Z-buffer\n不同图形存在相互遮挡，一般在绘制图形的时候，后绘制的图形会遮挡先绘制的图形，所以会对图形设置深度。\n在实际的计算机图像生成当中，会生成两个图，一个是成品图，一个是每个像素对应的深度值。\n深度可以理解成这个点到摄像机的距离，当然深度数值越大，离摄像机越远（z轴上大小越小）\n深度缓存算法的原理，是每次遍历记录每个像素的最浅深度。\n\n复杂度O（n），好处是与三角形绘制顺序无关，最终结果都一样\n&nbsp;\n着色\n对不同材质的物体提供不同的着色策略。\n&nbsp;\n局部着色\n只看光照方向，不看任何遮挡，只看自己本身\n&nbsp;\n漫反射\n\n光线打到物体表面，会被均匀反射出去，利用这个”结果“，我们通过光照射角度来计算接收到的光照能量，再”反射“出相应亮度（冯-布林光照模型）——光照“数量”\n把光看成能量，离光源越远能量越小（I/r^2）——光照“质量”\n\n\n\nkd为吸收的能量（颜色反射）\nmax防止负数\n&nbsp;\n高光（Blinn--Phong模型）\n如果材质接近金属等接近镜面反射的材质，则会再某个角度得到接近镜面高光的效果。\n目前的模型需要解决的问题是计算出观察方向与高光方向的接近程度，做到越接近越高光的效果。\nBlinn--Phong模型的解释是如果观察向量与光线向量的半程向量和法向量足够接近，则说明观察向量越接近高光向量。\n即比较半程向量与法向量\n\n\n\n\n如果直接使用的是观察向量与高光向量比较，那么那个模型叫Phong模型\n优势是前者是优化过后的，半程向量比较好算\n\np指数的解释（64常用）——用来控制高光程度有多大：\n\n\n\n\np指数与镜面反射系数的直观对比：\n\n\n\n\n&nbsp;\n环境光照\n环境光从四面八方射入，保证每一个像素都获取得到\nLa = ka Ia\nka为光照系数，la为光照强度\n&nbsp;\n高光、漫反射、环境光三者结合就是完整的布林-冯光照模型\n\n\n\n\n&nbsp;\n着色频率\n含有插值的新用法\n\n\nFlat Shading——每个基础三角形的两条边，求其叉积，得到法线，用这个法线来计算着色\nGouraud Shading——求每个基础三角形的三顶点法线，计算着色，而三角形内部的着色由各自顶点的着色进行插值算出\n\n\n顶点法线求法\n\n\nPhong Shading——（和着色模型是一个发明者）对三角形三顶点法线进行插值，算出三角形中每一个像素的法线，再对三角形中的每个像素进行着色\n\n\n&nbsp;\n虽然从上到下效果越来越好，但其实实际运用中如果物体本身几何图形面数很多，那么其实不需要使用高质量的逐像素着色，这个时候使用最简单的逐图形着色，有时候效果差不了很多，而且开销更小。\n比如极端情况下面数比像素更多的情况\n\n&nbsp;\nQ：顶点法线怎么算？\nA：通过顶点原本背后视图表示的物体（球）来计算，不过最常用最合适的方法是直接运算顶点周围面的法线进行根据面面积的加权平均来得出来。\n&nbsp;\nQ：逐像素法线怎么算？\nA：对顶点法线进行插值计算，根据重心坐标来计算（即将讲到）。\n&nbsp;\n实时渲染管线（图形管线）\n管线：从场景到最后一张图的一系列操作\n\n\nInput：输入空间中的各种点\nVertices：把各种点进行mvp变换，视口变换投影到屏幕上\nTriangles：划分出一个个三角形\nFragment：光栅化，将图形打散成一个个像素——也包含Z-buffer\nShaded：着色——如果是Gouraud，则这一步其实可以发生在Vertices那一步，如果是Phong，那就至少三角形划分出来之后再进行，不过现代GPU支持编程化Shaded，也就是说可自定义化控制每个像素使用哪种策略进行着色，我们就把进行编程的这个动作叫写Shader\nOutput：输出结果\n\n\nShader中不需要写For循环\n\n顶点着色器：如果写的shader是对顶点进行操作\n像素着色器：如果写的是对像素进行操作\n\n\nshader语言——GLSL\n\n&nbsp;\n纹理映射\n以上讲到的都是单个物体同一个基础颜色，纹理则是用来决定一个物体多个不同颜色的——改变漫反射系数\n\n纹理的本质就是一张图，可拉伸可伸缩到形态不同的物体上——叫做纹理映射\n\n映射的规则是默认已知的，一般由其他艺术家直接在模型上进行处理\nUV图：模型上的纹理展开后的图（0~1）\n常用最多的“优秀纹理”其实就是例如木纹这样的材质图，这种类型的纹理一般能够实现纹理无缝衔接\n&nbsp;\n三角形插值运算\n重心坐标：(a,b)=aA+bB+cC\n\t\t\t\t\ta+b+c=1\t\t\t\t\t\t——点在三角形平面内，如果三者都是非负，则在三角形内\n面积表示法：（略）\n&nbsp;\n纹理映射应用\n（u，v）图记录了每一个采样点的纹理颜色——即Kd漫反射系数\n屏幕上的每一个位置，可以转换成纹理坐标——三角形插值运算可计算出所有点了\n利用纹理坐标在（u，v）上的映射，将Kd代替进去\n&nbsp;\n纹理放大\n例如：高分辨率的模型（texture），墙等贴了一张低分辨率的纹理（texel）\n\n四舍五入——会导致很多相同像素映射到同一块texture上，没有“丝滑”的效果\n双线性插值（Bilinear interpolation）\n\n\n\n\n在计算texture中，却并不完全对应在texel上的点时（例如此红点），对其进行双线性插值计算出实际纹理颜色。\n实际操作是（例）计算出u00到u10，以及u01到u11的线性插值，得出红点的两个水平插值，然后再对两个水平插值进行插值计算算出红点的插值，这就是双线性插值的名字由来\nBicubic——取周围16个点来插值，计算量更大，但图像更准确\n\n\n\n\n&nbsp;\n纹理缩小\n小模型，纹理UV比像素多\n\n\n\n\n\n原因：屏幕上的区域，其实纹理覆盖的大小都不相同\n比如一块纹理覆盖到地面上，但从水平角度看，地平线方向纹理密度会非常非常大\n解决方法1：之前其实提到过抗锯齿的方法，在这里同样适用，比如在远处使用更多的采样点——超采样\n解决方法2：避免采样，进行范围查询——Mipmap\nMipmap将纹理图处理成大小不同的纹理图，存储量多了三分之一\n\n\n\n\nmipmap生成不同的纹理图，一般是按照倍数减少大小的，这张图做了放大处理，实际上像素面积大小都是一样的，也就是说从左往右图片面积也是越来越小的。\n具体要如何使用呢，在我们要渲染出的图像中，由于UV点密度在图像中不同位置不太一样，我们通过计算某采样点上面右边与自身采样点对应UV，计算出两长度大小。再根据这个长度大小来“模拟”出一个正方形，因为不同密度UV点一般情况下生成不了正方形但Mipmap的范围查询只能通过正方形查询。这个正方形大小就能代表像素点映射到纹理上的区域大小。\n这个时候重点来了，我们都知道像素点在屏幕上都是设定好的大小，排好队一个个显示好。但映射过后的UV图不一样，可能一个像素对应四个像素大小的UV图，也就是说大概四个像素面积的UV图要“挤”在一个像素内，这个时候所需求的采样点就会变多，不然就容易发生前面图中发生的“走样”现象，锯齿现象会严重。这个时候如果将这四个像素的内容“平均”一下，再将这个“平均”结合后的单个像素放入原来的位置，那么锯齿现象就会平滑很多。而这个“平均”从哪里找呢，其实就是Mipmap处理过后的纹理图，比如上图Level1就代表四个像素模糊到一个像素过后 的图像，如果正方形的结果是边长为2，那么就在Level1中找，如果边长为L，那么就在log2L层级上找。\n&nbsp;\n三线性插值\n 如果范围查询的结果是需要在1.5层级中查找，那么该如何处理呢\n在游戏中的设置中，经常会发现有一个叫”插值“的选项\n\n如果要在1与2层级中寻找1.5层级，那么直接在两层之间加一次插值，就被称为”三线性插值。\n其实有点没太理解似乎老师没细聊\n\n&nbsp;\nOverblur\n三线性插值过后，远处的场景发生了模糊化\n\n\n\n\n\n问题出在三线性过滤的基础都是发生在查询单位都是正方形的情况下\n各向异性过滤——每X2，三倍开销，和性能关系不大，和显存关系大\n在不同的方向上表现各不相同\n\n\n首先，图中的每一个像素对应在UV图上都是一个个拉伸了的结果，如果对于正常拉伸的矩形，可以快速对矩形进行查询。\n还不够，也可以使用EWA过滤\n\n","categories":["计算机图形学"]},{"title":"空间变换","url":"/2023/08/09/%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2/","content":"\n\n\n\n\n空间变换的意义\n\n空间变换的意义\n&nbsp;\n模型变换\n\n描述摄像机运动\n描述模型运动\n\n\n&nbsp;\n视图变换\n\n3D到2D的投影变换\n\n\n\n二维变换\n刻度矩阵\n\nx`=sx \ny`=sy\n写成矩阵：\n叫做缩放矩阵\n\ny轴反转：\n\n\n\nx`=-x\ny`=y\n\n&nbsp;\n\n斜变化：\n\n\n\n\n\n旋转变化：\n\n\n\n\n将特殊点代入就可以算出来\n\n没有额外交代，旋转永远以原点为旋转中心\n\n齐次坐标\n\n并不能用上述说的矩阵表示\n于是\n\n2D point   =(x,y,1)T\n2D vector =(x,y,0)T\n\n\n\n但是不是线性变换，不满足”由一个矩阵变换而来“的约定俗成格式\n所以引入一个新坐标\n\n解释如下：\n\nvector + vector   = vector\npoint   - point      = vector\npoint   + vector   = point\npoint   + point     = ??\n\n\n两点相加其实是中点\n\n其实所有二维点(x,y,w)T最终都能变换成这样的形式(x/w,y/w,1)T\n然后为什么坐标后面增加的是1，而向量后面增加的是0呢？首先看结果，进行平移变换后，点的坐标是满足我们需求的，而向量的特点是”平移不变“，所以我们不应该在进行平移操作后改变向量的值，所以0是用来保护向量的\n\n特点：在二维情况下的仿射矩阵中，最下面一排必为001\n\n逆变换：\n\n\n\n变换回来的方法就是乘以逆矩阵\n有意思的是对于旋转变换来说，他的逆变换就是向反方向旋转相同角度，而反方向旋转矩阵就是正方形旋转矩阵的转置，所以说对于旋转矩阵，他的转置就等同于他的逆（数学上叫正交矩阵）\n\n组合变换\n\n复杂的变换通过简单变换组合得来\n简单变换的顺序很重要（很形象：矩阵乘法不满足交换律）\n\n\n于是：\n\n从右到左\n\n可以说，一个3X3的矩阵，可以代表很多变换的组合，这就是这个矩阵很神奇的地方，无论多么复杂的变换，通过这个小小的3X3矩阵就能够表示\n实战：\n\n非原点的旋转如何实现？很难写，那么可以先把这个点移动到原点，平移过去后再进行旋转，这就是逆向思考，反过来分解矩阵\n\n&nbsp;\n三维变换\n依葫芦画瓢\n\n3D point    =(x,y,z,1)T\n3D vector  =(x,y,z,0)T\n\n\n同样多一个齐次坐标\n\n对于三维物体变换来说，难点在于旋转\n\n绕轴旋转变换\n\n\n\n分别代表绕某条轴旋转\n\n\n普遍旋转\n\n\nRxyz(a,b,c) = Rx(a)Ry(b)Rz(c)\n飞机三大基本旋转：roll、pitch、yaw\n\n罗德里格斯旋转公式\n\n//\n观测变换\nView/Camera Transformation\n\n回忆一下现实生活中拍照片的过程\n摆造型-&gt;选角度-&gt;拍\n观察变换，就是“选角度”的过程\n&nbsp;\n投影变换\n\n其实这个可以见//cinemachime基本操作//\n那就不细聊原理了\n\n正交\n实际上投影的实质是从相机空间到裁剪空间的变换：\n\n将相机摆放到原点，布置好方向，朝向等\n去除z轴（会出现无法区分物体前后的情况）\n按比例移动并拉扯成到[-1,1]2的矩形上（转换为规范视域体，为了方便处理，无需考虑屏幕尺寸）\n\n\n实质操作\n\n用AABB包围盒（6个参数）转换为规范视规体\n\n\nOpenGL为(-1,-1,-1)到(1,1,1)\nDirectX为(-1,-1,0)到(1,1,1)\n\n\n在三维上，由于常用右手系坐标，所以远近在z轴上表示是远比近小（比如x轴是远比近大，是完全相反的\n\n\n图片来着知乎@杨鼎超\n\n透视\n先导复习：点(1,0,0,1)与点(2,0,0,2)在三维中其实代表一个点\n\n实质是把一块空间中所有点，各自按照一定角度形成线状”挤“入屏幕中\n\n细说如何变换：\n\n 颇有一种土木老哥测距内味儿\n\n将某个点的变换写成齐次矩阵性质：\n发现问题：Z不见了，发生了和正交一样的情况\n于是变换一下思维，可以先把这个锥体（视锥体）变为AABB包围盒，再转变成规范视规体（如上上图所示）\n\n矩阵计算方法如下：\n\n统计所有常规点位变换规律（就是上图）\n统计近裁面上的所有点（也就是(x,y,z,1)T=W(x,y,z,1)T)\n统计z轴上的点，z轴值不变\n\n\n解方程最终结果为：\n\n图片分别来自知乎@杨鼎超与BiliBili@闫令琪\n\n&nbsp;\n\n","categories":["计算机图形学"]},{"title":"腾讯课堂——浅述游戏策划","url":"/2023/08/08/%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E2%80%94%E2%80%94%E6%B5%85%E8%BF%B0%E6%B8%B8%E6%88%8F%E7%AD%96%E5%88%92/","content":"\n\n\n\n\n游戏策划是什么\n\n游戏的改变更多取决于社会的变革与环境的改变，而不是我们游戏人的努力\n游戏人口的扩大，使得游戏体验成本的下降\n\n&nbsp;\n&nbsp;\n游戏策划是什么\n基础的策划工作流\n灵感-&gt;理论\n创意-&gt;方法\n(设计方案&gt;需求实现&gt;产品整合&gt;测试)&gt;(打磨&gt;测试)&gt;上线反馈&gt;迭代开发\n游戏策划的作用\n“创造游戏体验，对体验负责”\n\n&nbsp;\n&nbsp;\n游戏策划的分类\n\n文学策划\n\n\n为游戏制造世界观，为角色制作台词，为玩家创造一个虚拟世界\n\n\n数值策划\n\n\n包括抽卡概率，平衡等\n\n\n系统策划\n\n\n如各种背包，公会等系统、各种游戏流程链等\n\n\n关卡策划\n\n\n“游戏导演”，在游戏与玩家的交互这个角度中下功夫，是从玩家角度最能体会到的\n\n&nbsp;\n&nbsp;\n&nbsp;\n游戏的制作过程\n“我能当策划吗”\n结论：是人就行，但大厂门槛高，有科班\n策划的基础素质：热爱，视野，沟通，洞察，激情\n视野：知识面、学习能力、游戏经验、信息获取\n洞察：独立思考、逻辑能力、求真求实、好奇心\n热爱和激情：不忘初心、坚韧不拔\n\n专业设计理论\nM：机制\nD：动态\nA：审美\n&nbsp;\n&nbsp;\n&nbsp;\n游戏策划的养成\n开普勒计划\n&nbsp;\n\n","categories":["游戏设计杂谈"]},{"title":"网络游戏万事通（基本概念+引擎技术栈+底层原理）","url":"/2024/09/18/%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E4%B8%87%E4%BA%8B%E9%80%9A%EF%BC%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF%E6%A0%88-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%89/","content":"\n\n\n\n\n网络游戏编程万事通11\n\n网络游戏编程万事通\n网络编程对于游戏客户端来说就像是附加题一样的模块，绝大多数游戏开发玩家在一开始接触编程的时候都会不约而同地避开网络编程，因为他对于游戏开发来说是如此重要，又是如此可有可无——对于向往单机主机大作白月光的同学们。\n我认为造成这样的原因大抵是因为网络编程一直是程序面的。游戏客户端的其他模块，例如游戏动画，他是绝对的占领表现层制高点的一个模块。我愿称之为一种熵减，游戏动画做的好，他的表现永远都是正面的，例如考虑极端条件下，只使用2D立绘，其实也不影响游戏主流程，而如果这个立绘变成了live2D，那么一定能会收到正面的赞扬。而网络编程，它似乎永远都在和延迟对抗，必须要做到一个极端好的情况，或者玩家根本体会不到延迟带来的负面效果，这样才刚好能摸到“还算正常”的门槛。\n网络编程、对抗延迟一直是只有程序员关注的，玩家可能会对游戏玩法提出各种建议，或者对某角色形象感到不满，但玩家不可能说出“我建议游戏改成帧同步这样我的体验才会好点”这种话。所有涉及网络编程相关的知识一直都特别专业化，对于游戏客户端来说它反而是知识壁垒最高的一个模块，和游戏的其他组成部分脱耦合性高。\n所以这篇文章以这个背景，简要介绍网络游戏编程原理，以及主流引擎网络同步方案。\n&nbsp;\n构建印象\n\n首先需要达成共识的是，如果要实现“多人控制不同角色在不同的客户端进行游戏”这种需求，那么每个客户端其实会生成所有的玩家实例，也就是说如果一个游戏类似图中两个人的对线系统，那么其实会有四个角色实例，也就是同样的一对石头人和一对瑞文同时在两台电脑上运行。\n\n这种形式其实可以自行理解成“镜像“、”复制“等等都行，也就是说从玩家层面看起来都在进行同一场游戏，但其实是两场一模一样的游戏实例。\n在一个客户端中，玩家通过控制器实现对自己的角色控制，而其他角色则通过服务端控制，而服务端上角色的运作来源本质也是其他客户端的控制，这就是我们常说的“同步”——也就是讲服务器上的内容同步到每一个客户端，或者将客户端的内容同步到服务端。\n&nbsp;\n基础知识\n&nbsp;\n状态同步帧同步\n有的服务器上存在一个游戏实例，有的没有。服务器上的实例运行游戏逻辑，例如向对方打一圈对方掉血，“是否命中”的判断逻辑发生在服务端上，然后再将回调事件同步给所有客户端，这种就是常说的“状态同步”或者说“CS同步”。\n例如“万人同屏”的传奇游戏，或者多人mmo，都必须使用状态同步，因为人太多必然会发生非常多的逻辑判断，这些逻辑跑在玩家的机子上是耐受不住的，务必需要服务器来统一处理。又例如“吃鸡”类超大地图多人游戏，发生在地图另一边的巷战我连枪声都听不到，那种信息就没必要浪费客户端算法来进行演算了。\n另一种“帧同步（Lockstep）”就是服务器上没跑逻辑，服务器只负责进行信息转发。帧同步往往采用在需要“及时反馈性质”需求较高的游戏中，例如竞技性强的moba类游戏，因为帧同步只需要做一次转发，而不需要同步在服务器上。\n有一种说法是帧同步是采用固定时间间隔或者固定帧数间隔进行同步，而状态同步是只依靠状态事件来触发同步。这也许是名称由来，但实际上帧同步状态同步只是两种极端情况的汇总，就像UDP和TCP（也是接下来要说的），现实开发过程中这两种同步方式都是根据一些需求来混用的，例如帧同步可能也会用到服务器逻辑，但服务器逻辑不直接同步在客户端上，客户端照常通过转发的消息进行直接反馈，服务端的逻辑结果仅作为一种“验证”。\n还有一种完全以服务端为权威的同步方式——快照同步，这种方式将所有逻辑（几乎）所有逻辑处理都放置在服务端上，然后以一个标准的时间戳进行广播，而客户端甚至只进行画面渲染。这类游戏主打的就是帧同步状态同步坏处都有但是属于弱客户端类型，比如可以做成小游戏或者云游戏\n\n&nbsp;\n网络拓扑结构\n\nP2P结构\n\n\nCS结构\n\n虽然这两种结构可以和帧同步状态同步对应上，但需要注意的是他们是两种截然不同的概念。\nP2P×状态同步：每一个客户端只对自己操作的角色有权威，只发送自己角色的状态\nP2P×帧同步：每一个客户端广播玩家的操作\nCS×状态同步：客户端将操作发送到服务器上，服务器进行逻辑处理后进行广播\nCS×帧同步：客户端将操作发送到服务器上，服务器对操作进行广播\n当然p2p已经是一种过时的结构了，只不过将他拧出来可以对状态同步和帧同步有一个更深的了解。\n现代所说的C/S架构一般指一台主机做服务端的同时也做客户端，DS则指主机只做服务端，因为往往服务端主机不需要进行渲染或部分游戏逻辑。\n要小心问起“CS架构有多少种”，这样的问题提问的是“广义“上的CS，也就是说网络拓扑结构有多少种，可以直接答DS、CS（LS）、P2P等\n\n&nbsp;\n状态同步与帧同步历史渊源\n正如前文所言，死磕状态同步帧同步差别是没意义的，两者早就在历史的长河中被改造地体无完肤。现代游戏对网络同步模型的实际应用，也是经过一系列特化改造后的结果。我们常对两大同步模型的解释，其实更适合初学者学习交流与深入理解。\n\n其实这几个概念引起争端的时间点就在不久之前\n\n最早的帧同步概念的出现在Doom中，也就是那个最早的FPS。它采用的是所有玩家每一定时间间隔广播、缓存所有玩家操作信息，在经过等停协议处理后再进行下一帧。\n雷神之锤（Quake）则采用的是另一种完全相违背的方案，那就是使用专门的服务器，收集玩家的操作信息，在服务器经过逻辑处理后直接将要渲染的结果信息发送给所有的客户端，也就是上文所提到的”快照同步“。\n这个帧同步放在现代游戏中那就会暴露出非常多的问题（当然科学是踩在前人肩膀上才能发展起来的），例如等停，如果有一个玩家发送的信息许久没被广播到位，那么其他人是不是得一直等他呢？例如浮点数，不同平台对浮点数的包容度是不同的。例如作弊，没有服务器权威，甚至都不知道某个客户端是否开挂了。\n现代网络游戏同步模型分类，可以考虑参考gdc2017 overwatch上的分享：\n&nbsp;\n\nDeterministic LockStep\n\n\n（理想）要求：给定相同的初始状态，给定一系列相同的输入，计算出完全相同的结果。\n\nSnapshot Interpolation\n\n\n要求：服务端定期将世界的瞬时快照发送给所有的客户端，客户端只做展示，可以用插值的方式来让表现更平滑。\n\nState Synchronization\n\n\n要求：服务端运行世界，也允许客户端运行世界，但是要以服务端作为权威，定位对客户端进行纠正。\n&nbsp;\n很明显可以看出这三者就对应国内常说的”帧同步、快照同步和状态同步“，但要是从细节上纠察，又会发现差异的地方也是非常多的。对于同步方案的描述当然是百家之言，所以各位同学在面试的时候其实会发现面试官往往不会直白地提问”状态同步和帧同步“，而是就着项目或者场景题来让候选人分析，从而间接考验候选人对网络同步的见解。\n&nbsp;\n就比如Deterministic LockStep所言结果是完全一致的，但如果你对”帧同步“稍有了解，便会发现其实帧同步反而“同步不了”，因为缺乏纠察验证，谁知道同步过程中会发生什么。所以说Deterministic LockStep中提到的要求我加了“理想”二字，其实就象征了这是古今中外计算机科学家的同步的一种理想目标。\n之所以会产生差异，是因为Deterministic LockStep和帧同步对于网络的需求也不一致。Deterministic LockStep其实也完全可以实现这种理想化需求，就比如说TCP，完全确定性，拿他来传输文件不产生任何差异也是没有问题的。但游戏需求的是高即时性，低流量，Deterministic LockStep对网络的要求非常之高，而且也会浪费更多的带宽。帧同步则可以说是加了层层算法后的Deterministic LockStep，例如“帧锁定、乐观帧锁定、lockstep、bucket同步等”，这些手段最终都会导致一定的缺陷，例如乐观帧容纳了外挂的发生，这些都之后再聊。\n在细谈网络同步在游戏历史中的发展变化（上） - 知乎 (zhihu.com)中有提到过LockStep在没有服务器权威的情况下的防外挂方式——为发出的数据进行哈希加密，并在解密上一帧数据到来的时候再发送下一帧明文数据。现代一般直接只对关键数据进行哈希加密。\n\n&nbsp;\nUDP与TCP\n分别对应传输层方案的两者极限情况。\nTCP可靠，需要提前连接，字节流传输，常用于可靠性需求强的文件流下载等。但是开销高，延迟高。\nUDP不可靠，无连接，头部开销小，传输效率高，常用于实时性强的音视频等。但是不可靠。\nTCP可靠性\nTCP通过校验和、序列号、确认应答、重传控制、连接管理以及流量控制等机制实现可靠性传输。\n\n校验和：二进制字节流相加后取反获得的一个字段，这个字段在接收端被重新计算后进行前后比对。\n序列号：TCP的每一个字节发送会带一个序列号，接收端和发送端会约定好字节流顺序，序列号和校验和能直观说明哪些字段出现问题。\n确认应答：既ACK回包，回包中包含下一次准备接收的序列号。\n重传控制：除了之前包发生错误并回包后触发的重传，TCP还会设置各种计时器来记录传输时间，若超时也会发生重传。\n连接管理：三次握手四次挥手。\n流量控制：涉及滑动窗口、拥塞控制、慢开始拥塞避免快重传快恢复等一系列手段。\n\n\n\n&nbsp;\n三次握手四次挥手\n粗略版\n第一次握手为了证明发送端发送能力正常\n第二次握手为了证明接收端接收、发送能力正常\n第三次握手为了证明发送端接收能力正常\n&nbsp;\n第一次挥手为了表述发送端决定断开连接\n第二次挥手为了表述接收端收到断开连接的请求\n第三次挥手为了表述接收端也准备好断开请求了\n第四次挥手为了表述发送端收到断开请求的许可了\n&nbsp;\n因为网上三握四挥的详细介绍太多了所以粗略总结了一个精简版，不过还是整理一下完整版\n\n细节版\n1、发送方发出第一个连接请求，这个请求中的包的SYN字段为1，说明“请求连接”，并带有第一个序列号seq=x。\n2、接收方收到请求后进行回包，确认包中SYN=1，ACK=1，说明是回包，确认号ack=x+1，说明下一个预计要接收包的序列号应该就是x+1。同时自己也要独立初始化序列号，seq=y。\n3、发送方接收到回包，也向接收方发送回包ACK=1，seq=x+1，ack=y+1.\n建立连接整个流程会涉及到很多资源调用，所以三次握手就是让发送方和接收方都做好资源调用的准备。\n假如发送方无视握手直接开始建立连接，如果接收方本身没有做好连接准备，这个时候可能产生“服务器未响应”，不得不中断连接造成资源浪费。\n包传输本身是不可靠的，如果发送方服务器未响应，也有可能触发发送方的再次重传，这个时候接收方可能一次性收到两个连接请求，这个时候就轮到接收方产生资源浪费了。\n&nbsp;\n1、发送方发出第一个断开请求FIN=1，表示“请求断开”，序列号为seq=u。此时发送方不在传输新数据。\n2、接收方收到并回包，ACK=1，ack=u+1，并且带上自己的序列号seq=v。此时接收方知道之后不会再接收到包了，但是自己还有剩余的包需要传。\n3、接收方发出请求断开。此时接收方已经发送完所有包了\n4、发送方收到并回包，ACK=1，ack=w+1，而自己的序列号是seq=u+1，等待2MSL后正式断开连接。\n5、接收方收到最终回包后也断开连接。\n其实本质和三次握手是一样的，区别是挥手过程中可能会产生另一方还没发送完所有剩余包的情况，所以中间会加一次挥手等待接收方发出最终包。\n最终发送方会等待2MSL，因为此时接收方并不知道发送方是否真正接收到最后的ACK，必须等待发送方的ACK才断开（因为可能会发生丢包重传等情况）。对于发送方来说它同样也不知道自己的最终ACK回包是否正常收到，然而最终回包不会有回包了，所以直接等待2MSL时间，若期间不再接收到接收方的重传，则说明一切正常，可以断开了。\nMSL指一次包传输的最大时间，2MSL就是一个来回了\n\n&nbsp;\n以KCP为例\n游戏开发中一般既不会完全用TCP，也不会完全用UDP。\n两边都太极端了。\n除了早年回合制或者等停帧同步采用的是TCP（毕竟能直接现套成熟框架），现在的游戏讲究高实时性，所以肯定会以UDP为基础打造网络框架。\nUDP本身并不可靠，这一点又和“同步”这个概念相违背，所以网络游戏开发一般会进行UDP的个性化改造，方向大概如下：\n\n可靠UDP\n应用层实现可靠UDP\n\n\n可靠UDP指在传输层或者协议级别进行UDP扩展，这样的改造UDP运用起来和TCP本身差不多了，应用层直接调用即可。\n应用层实现UDP的可靠指在应用层纯算法实现TCP的一些机制，例如超时重传等。\n相比起来后者明显更加灵活，但使用起来可能会麻烦一点，不过恰巧契合了网络游戏开发这样高迭代性的应用。\nUnity中最有名的网络插件Mirror，就是自己应用层实现了一套可靠UDP，称作KCP。\nKCP是一个快速可靠协议，能以比 TCP浪费10%-20%的带宽的代价，换取平均延迟降低 30%-40%，且最大延迟降低三倍的传输效果。纯算法实现，并不负责底层协议（如UDP）的收发，需要使用者自己定义下层数据的发送方式，以 callback的方式提供给 KCP。连时钟都需要外部传递进来，内部不会有任何一次系统调用。\nTCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。\n\n&nbsp;\nHTTP\n&nbsp;\n解决方案\n&nbsp;\n以史为镜\n帧同步——《王者荣耀》\n理由：\n1、开发效率——和写单机很像\n2、打击感强\n3、流量消耗稳定\n帧同步与状态同步：王者荣耀的帧同步方案_王者荣耀是帧同步还是状态同步-CSDN博客\n&nbsp;\n状态同步——《Overwatch》\n理由：\n1、避免偶现的不确定性\n2、支持中途加入游戏*（帧同步需要重新模拟，这个和回放系统相关，也会后面讲）\n3、实现阵亡镜头快照\n《守望先锋》架构设计与网络同步在GDC2017【Overwatch Gameplay Architecture andN - 掘金 (juejin.cn)\n强烈推荐\n\n&nbsp;\n当然由于水平问题我的文章只会介绍一些概念上的皮毛\n\n预测回滚（GAS）\nCS架构中客户端需要等待服务端的同步信息，服务端广播之前又要等待客户端发来的同步请求，所以状态同步相对帧同步来说延迟更高。为了保证及时反馈，客户端往往会对input信息先执行逻辑，根据回包情况来进行适当回滚操作。\n最典型的就是早期网络环境不好的时候，吃鸡游戏舔物资需要角色播放好几次拾取动画，跑步也经常会出现“回溯”现象，这些都是客户端对角色本身逻辑优先做了预测运行的结果。\n&nbsp;\n插值方案\n如果客户端与服务端发送过来的实时消息有不同步的情况，客户端会对这个消息值与现存的消息值做插值处理，优化视觉体验。\n我在我的项目中习惯性使用一个虚拟轴与一个表现轴，虚拟轴不显示但绝对遵循服务端，表现轴负责计算与虚拟轴的信息差距（坐标、刚体速度等），如果差距超出预期则会以插值的形式缓慢对齐过去。input可以直接在客户端作用于表现轴，也可以直接将输入发送给服务器，这个就取决于是否使用预测回滚方案了。\n&nbsp;\n延迟补偿\nFPS游戏重灾区，玩家开枪，但事件到达服务器时已经延后了好几帧，这个时间点敌人早就跑远了，所以服务器需要保存前几帧的数据快照，待收到事件的时候在服务器对应的帧进行碰撞判断，然后再将结果返回给服务器进行广播。这个时候客户端也可以考虑进行预测，直接表现击中反馈，待几帧之后再返回实际击中结果。\n所以经常会看见做射线检测的游戏却会发生”拼枪同时死亡“的情况\n\n&nbsp;\n重连与回放\n如果时状态同步，那么在重连的时候只需要同步服务端当前的状态就可以了。但如果是帧同步，服务端只会发送一系列操作帧，所以需要客户端进行本地重演，直到表现帧追上逻辑帧。\n反过来会发现帧同步更方便开发回放功能，因为帧同步的操作序列占用内存小，非常适合制作本地回放，只需要将所有序列帧原封不动保存下来就可以了。但状态同步就没这么幸运了，保存每一个对象的每一个属性状态都意味着大量的内存占用。\n对于守望先锋而言，他们做了两个并行ECS来分别代表本体游戏事件与回放游戏时间，然后在需要回放的时候对世界进行切换，将信息直接映射在玩家屏幕上。\n为了防止状态同步造成的大量带宽浪费，需要做很多额外的处理来进行优化。\n\n同步状态是肯定的，除了位置、还需要同步物体的速度与角速度或者其他数据。\n只同步需要同步的状态，所以可以先做一些简单的处理，例如不发送绝对变化为0的对象。\now在服务器上维护了一个脏数据集合，收集每一次发包的数据，发出后清除。\n增量编码，维护客户端收到数据的历史纪录，这样就能只对变化的数据进行更新了。\n当检测到带宽容纳量不足的时候，脏数据不会丢失，而是放在下一个包进行发出。\n脏数据是会不断更新的，也就是说如果数据包一直未发出，他还是只会更新最新包。\n\n\n\n以上是ow对状态同步应用层的一些特殊处理，现在回到重连部分，可以发现状态同步的重连可以通过这一套“脏数据”集合来实现了。\n服务器上的“脏数据”还存有另一套全量的数据，也就是脏数据不会更新，而是每一种变化都保存下来，用于之后的回放系统。\n对于重连系统，不能直接使用当前的增量包，因为增量包肯定是不全的；同时也不能直接使用全量包，因为直接用全量包和直接更新所以状态差距不大，同样导致带宽浪费。还记得增量包是怎么来的吗，可以做一个“假想”的回放，一步步将全量包从头更新一遍，这样就能直接得出一个“全量的增量包”，直接用这个重连就行了。\now的死亡回放是实时的，可以直接使用全量包来直接进行渲染，虽然因为数据太大会发生可能的卡顿，但好在玩家禁止了玩家操作让玩家注意不到。\now忽略了大部分细节上的处理，例如UDP可靠的处理等一系列，这里我单独找了一篇可以适当补充下。[Unity Mirror] State Synchronization（状态同步）_unity 状态同步-CSDN博客\n&nbsp;\n确定性帧同步\n客户端方面有较多独有的数据不统一的可能性。\n\n平台不同的浮点数计算——使用定点数或者直接用分子分母代表，三角函数查表\n随机数不一致——使用随机数种子\n稳定性排序——不使用不确定是排序算法\n之前提到过的关键数据hash加密\n\n\n再补充下hash加密。现在可以统一口径了，如果人多，可以直接客户端自验证，如果有一个hash与别人不一致就说明666他开挂了；如果人少就需要引入校验服。\n\n&nbsp;\n表现层与逻辑层处理方案\n逻辑与表现分离，这是一个和客户端预测很像的概念。个人理解如下：\n关键点在于，表现层虽然被逻辑层控制，但是其运行逻辑是完全独立与逻辑层之外的，例如音效播放或者特效播放，这些和网络同步是完全没关系的客户端独立事件。客户端预测更像是将服务器要管辖的要素提前表现，例如控制角色移动，这些虽然最终还是作用在表现层上，但是我们可以在客户端上提前进行预演而不需要等待回包，这个叫客户端预测。\n&nbsp;\nUnity与UE技术栈\n在直接研究具体的技术框架方案之前先提一嘴框架概念，我的印象中无论是Unity还是UE还是其他引擎的网络架构，这一些概念都是业内最为常用的比较认可的。在后面我会讲一些应用层的基础方案。\n&nbsp;\nRPC调用\nRPC指一系列的一整套数据传输方案，这一套在游戏开发中一般会依赖外部插件支持。\n总所周知实现一系列的网络传输流程需要单独将数据进行序列化处理，还要负责装包拆包，最蛋疼的是还得写Socket。这些强数据化的工作已经和游戏客户端开发渐行渐远了，但偏偏就是网络游戏中不可缺失的一部分。在实际工业级开发中会专门让服务端的同学来处理一些更数据化的工作，比如使用机器学习流量压缩等更加高级的技术；对于客户端同学来说，对他们的福报就是能将网络同步的一些处理尽量简化（计网70分的有难了\nPRC调用就是这样一个东西，他的全称叫做“R远程过程调用”，意思就是客户端远程调用服务器的函数，这个函数一口气把数据传输等一系列的活全办完，让网络编程就像客户端编程一样方便。RPC不是一套固定的方案，我的理解他只是一个概念，既能直接暴露给客户端一个函数，而他的底层实现可以是多种方案的，TCP、UDP甚至HTTP，也可以是可靠的也可以是不可靠的。\nRPC可以理解为他的一个流程就是一整套的函数调用，也就是“一次性的”，不受任何生命周期影响。意味着如果RPC是不可靠的，那么他丢失了恐怕就真的丢失了。\n&nbsp;\n属性同步\n属性同步是一种上层特性，以对象为单位，和时间周期相关。\n也就是直接同步对象的“属性”，以一定的周期，服务端向客户端同步所有要同步的属性（不存在客户端向服务端的属性同步）。\n和RPC比起来，虽然属性肯定是可靠的（就算丢失了下一帧也会传达），但是属性不是事件化的，也就是说客户端的属性在同步之前就被覆盖掉了，那么还是会产生一些可能的数据丢失：\n\n如果数据包丢失，发生同步延迟，这段时间内属性再次发生改变，那么就会直接同步新的值。\n如果数据在客户端快速变化，属性同步不会同步每一个变化而是根据周期来同步最新值，也就是说可能在客户端上一个看起来表现很好的一个插值直接同步在其他客户端上就会卡顿。\n\n\n&nbsp;\nMirror\nMirror是Unity运用最广泛的一个民间插件，todo..（KCP）\n\n&nbsp;\n&nbsp;\nUE网络架构\nUE常用官方给出的架构（UDPSocket）\n\n&nbsp;\nNetDriver\n相当于网络总管理类。\n——初始化网络连接\n——处理RPC函数\n——管理Connection信息\n——接收数据包\n一个世界对应一个NetDriver\n&nbsp;\nConnection\nconnection本身代表一个网络连接，对于客户端来说，到来的服务端连接叫ServerConnection；对于服务端来说，客户端的连接叫ClientConnection。\n&nbsp;\nPlayerController\n玩家控制器，对应一个LocalPlayer（地图变化时不发生改变），也对应一个Connection。\n在不连接时，客户端上的PlayerController仅作占位符，可以理解为临时Controller。\n客户端连接过程：\n\n客户端发送请求\n服务器调用PreLogin，确定是否连接，如果允许连接，则发送地图信息\n客户端加载地图，成功后回包一个join\n服务端调用Login来创建PlayerController，这个Controller用来同步给其他客户端或者新加入的客户端\n服务器BeginPlay被调用，完成后调用PostLogin允许PlayerController调用RPC\n\n\n\n客户端存有一个PlayerController，但是像之前说的这个Controller只是一个临时的，真正的完成连接相关的逻辑是依靠服务器生成并同步过来的Controller来完成的（包含相关NetDriver，Connection以及Session信息），一般这种就叫”带连接的“。\nActor中含有owner属性，如果Actor中的owner是一个有连接的PlayerController，或者owner的owner是一个有连接的PlayerController，那么就说明Actor是有连接的Actor。\n更具体的是Actor的子类Pawn，Pawn本身就拥有Controller属性，所以有可能Pawn的owner属性为空。\n\nActor是UE进行属性同步与RPC调用的基础对象。\n&nbsp;\nChannel\n数据通道，一般分为不同的通道，特定类型的数据在不同通道中进行传输。\n在UE中表现为某些对象绑定特定的Channel，接收传输信息时非本Channel会被筛除。\n一个connection中可以包含多个channel，每一个channel都隶属于一个特殊的connection，需要传输信息时，connection会找到特殊的channel来进行信息处理。\nChannel一般会根据功能来进行划分，例如：\nControlChannel：只初始化一个，传输客户端服务端之间控制信息\nVoiceChannel：只初始化一个，传输语音信息\nActorChannel：Actor本身的信息同步，子组件同步，属性同步，RPC调用，每一个Actor都对于一个ActorChannel实例。\n\n\n图片来源知乎@Jerish\n\n&nbsp;\nBunch：是UE中进行数据传输、进行服务器客户端同步的基本单位。和UDP中的Packet不冲突，UE使用UDP作为底层协议，传输的就是Packet，而Packet内就包含大量Bunch。Bunch被包装成Packet进行传输，到达后拆解分到不同的Channel中进行处理。\n&nbsp;\nObjectReplicator\n负责对象层的网络同步，将游戏对象从服务端同步至客户端。\n保存了一份对象的属性快照，在每一次服务端更新时查找哪些属性发生变化（需要同步的属性），再将这些属性同步到客户端中。\nReplicator主要做的就是Bunch的打包与解析，也会处理RPC的发送和接收。\nChannel中含有多个Replicator实例，会在需要的时候调用他们的方法，例如发送Bunch或者获取接收到的Bunch。\n&nbsp;\nUE服务端网络模块初始化\n创建GameInstance开始，首先创建NetDriver来驱动网络初始化，进而根据平台创建对应的Socket，之后在World里面监听客户端的消息。\n&nbsp;\nUE客户端网络模块初始化\n创建GameInstance开始，首先创建NetDriver来驱动网络初始化，进而根据平台创建对应的Socket，创建连接到服务器的ServerConnection。\n&nbsp;\nActor同步\n[《Exploring in UE4》网络同步原理深入（上）原理分析] - 知乎 (zhihu.com)\n在服务器中的TickFlush，对针对Actor对其进行一些同步相关内容。\n\n初始化\n\n获取所有ClientConnections\n找到要同步的Actor（只有在World.NetworkActors里的Actor才会被同步）\n找到ViewTarget（和摄像机绑定），利用这个位置信息决定是否同步\n休眠的Actor不会同步\n\n\n\n优化同步\n\n如果没有Channel，且不在场景或者在场景但是距离很远，不同步\n如果需要同步但没有Channel则给他创建一个\n优先级排序——是否有controller、距离等\n\n\n\n执行同步\n\n执行UActorChannel::ReplicateActor，将序列化后的Actor以及子Actor、属性等封装到OutBunch中发给客户端\n\n\n\n\n\n&nbsp;\n组件同步\n静态组件随Actor一起序列化同步。\n动态组件需要设置Replicate来同步。\n&nbsp;\n属性同步\n\n切入点——某属性被标记为Replicates，通过反射系统将他保存到ClassReps列表中。\n\nFRepLayout——同步属性列表，记录类中哪些属性需要同步。NetDiver存有一个大对照表，叫RepLayoutMap。\nFResState——上一次同步的缓存数据，叫做Staticbuff。\nFRepChangelistState——检测到发生改变的属性序号列表，会延伸为所有变化的历史记录。\nFObjectReplicator——数据控制执行，随ActorChannel创建。\n\n\n\n\n\n\nFObjectReplicator:: ReplicateProperties开始执行（函数执行栈就懒得翻了。。）。在设置通道的时候为FObjectReplicator设置了一个指针指向Object，也就是从客户端同步过来的对象，这个对象会不停和Staticbuff这个对象做比较，Staticbuff会不断做更新，也会将变化点记录下来。\n客户端当中也有FRepLayout这一套，不过Staticbuff比对后不是发送不同的属性值，而是调用发生变化的回调函数。\n\n\n&nbsp;\nUE中PRC调用流程\n\n服务端调用，客户端执行。UFUNCTION中添加Client修饰符。命名规则以Client为前缀。\n客户端调用，服务端执行。UFUNCTION中添加Server修饰符。命名规则以Server为前缀。\n在服务端调用，服务端和连接上的所有客户端执行。UFUNCTION中添加NetMulticast修饰符。命名规则以Multicast为前缀。（多播）\n\n\n由于RPC是异步的，他的调用和执行在不同的端上，所有不能立即返回一个返回值，所以RPC调用一定是void的。\n添加Reliable关键字来确定是否需要可靠性\n\n函数也和Actor一样有RepLayOut对照表，可以通过反射系统查看某函数是否为RPC，使用的时候定义的RPC和反射系统调用的RPC是不一样的，调用的RPC需要带_Implementation后缀（这个函数就是程序员需要具体实现的逻辑函数）。\nUFUNCTION(Server, Reliable)\nvoid ServerDoSomething();\n\nvoid AMyActor::ServerDoSomething_Implementation() &#123;\n// 这里是服务器执行的逻辑\n&#125;\n\nRPC调用时，直接将产生的Bunch放到Sendbuffer中，按照UE4的Tick直接发送，RPC数据会比属性同步要早放进buffer中，所有会出现可能的同步问题。\n&nbsp;\nRPC发送与接收\nPRC函数在UE中实际起作用运行的时候，是通过反射调用自动生成的RPC函数。\n这个函数生成了很多新的代码，例如查找上下文，发现这个RPC由Server标记，则说明要在服务器进行逻辑，直接将RPC请求打包，而不是在客户端进行逻辑。发现由WithValidation标记，则说明需要增加验证，需要请求运行_Validation后缀函数。\n验证函数中需要自行规定，一般用来设置天花板，例如客户端传过来的伤害不可能大于100，那就再_Validation中设定大于100（是一个bool返回值函数）。\n打包的流程涉及数据的序列化过程，接收的时候将数据进行反序列化。\n接收过后会先查看是否带WithValidation，带的话就运行验证函数_Validation，通过后再通过反射调用到 __Implementation函数。\n&nbsp;\n可靠数据\n参考TCP的ack重传机制，不过UE中重传序列化的基本单位是Bunch。\n&nbsp;\n属性可靠\n处理初始化外会重传，正常情况下的属性同步是不可靠的，也就是不会进行直接重传机制。\n属性同步是依靠对象的Tick来执行的，所以他会将接收到的ACK做汇总记录，将需要重传的bunch与下一帧要传的bunch混一起传出去。\n&nbsp;\n数据传输\n//protobuf：：todo\n&nbsp;\n防挂🐕特别栏目\n//todo\n\n","categories":["计算机网络"]},{"title":"腾讯课堂——游戏设计本质与技巧","url":"/2023/08/08/%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E2%80%94%E2%80%94%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%9C%AC%E8%B4%A8%E4%B8%8E%E6%8A%80%E5%B7%A7/","content":"\n\n\n\n\n游戏本质玩法设计\n\n游戏本质玩法设计\n游戏玩法定义：\n是一种基于物质满足之上的，在一组特点时间、空间范围内遵循某种特定规则的，追求精神富足的行为活动\n游戏规则定义：\n游戏是规则的集合，在电脑介入之后，规则在规模大幅扩展的同时获得了丰富的传达方式，使玩家能够进入更复杂的游戏\n个人想法：认为电脑的介入之后给游戏最大的利好，处理主导游戏规则运行计算以外，给予了游戏丰富的随机性，不确定的前进方向使玩家产生了更大的兴趣\n\n游戏设计师是观察者，发现者，探索者\nJonathan Blow：游戏设计可以不是一种发明创造，而是一种发现；游戏设计可以不是某个才华横溢的设计师在用代码贯彻他脑中惊世骇俗的点子，而是一个善于倾听的设计师通过代码向宇宙发问，再将饱含宇宙真相自身之美感的回答精心呈现给玩家。宇宙才是一切的创造者，设计师只不过比普通人更擅长发现有意思的事物\n\n&nbsp;\n&nbsp;\n叙事与玩法的关系\n游戏美学赋予给gameplay之后能给予游戏质的提升，尽管产品大差不差，但游戏美学素养的提升能给用户一个完全不同的体验，所以说叙事和玩法式紧密结合的，不可分割的\n\n德式桌游VS美式桌游\n\n\n前者注重机制游玩，后者注重剧情代入\n\n\n一切源于创意\n\n\n从机制到故事\n\n创造玩家故事五要素：身份、动机、挑战、权衡、结果\n&nbsp;\n&nbsp;\n设计方法\n游戏设计理论介绍与索引\n&nbsp;\n\nKRS设计方法\n\n\nKnow-ledge概念：游戏内的一些基本概念、游戏中出现的特定要素、核心体验相关信息\nRule规则：游戏世界运行的基本规则、模式/胜负条件、3C（角色镜头和控制）/关键手段规则\nSkill技巧：物理技巧（玩技术）、心智技巧（玩脑子）\n&nbsp;\n\nMDA设计理论\n\n\nMechanics：机制，游戏基础规则\nDynamics：动态，游戏运行时会根据玩家输入而改变的状态\nAesthetics：审美，游戏带来的整体感官上的体验，不只是美术\nDesigner--Mechanics-&gt;Dynamics-&gt;Aesthetics--Player\nPlayer--Aesthetics-&gt;Dynamics-&gt;Mechanics--Designer\n\n&nbsp;\n\nOODA理论介绍\n\n\nloop:行动ACT--观察OBSERVE--确认ORIENT--决策DECIDE--行动ACT\n例如PUBG游戏观察敌人然后决策循环\n\n&nbsp;\n\nSCAMPER创意方法\n\n\n\nS=substitute=替代\nC=combine=组合\nA=adapt=改进\nM=modify=修正/扩大\nP=put to other users=用于其他方面\nE=eliminate=减少/消除\nR=reverse=逆转/重新整理\n\n\n\ne.g.马里奥网球，例如在打球的基础上增加角色技能等\n&nbsp;\n&nbsp;\n其他\n\n游戏完成度通过迭代提升，并不是一诞生就是一个完整游戏\n游戏策划、游戏设计师并不一定是十分高尚的职业，有很多新的创意就是由mod社区诞生或者就是由类mod产生形式而来，例如一种射击游戏沿用的爆破模式做底，然后进行“类mod”创新\n第三部分就是老师的《龙焰酒馆》创造历程与设计方法分析\n\n\n\n","categories":["游戏设计杂谈"]},{"title":"虚幻蓝图","url":"/2024/11/15/%E8%99%9A%E5%B9%BB%E8%93%9D%E5%9B%BE/","content":"\n\n\n\n\n10.28虚幻蓝图(11.1补充)\n\nUBlueprint\n\nhttps://zhuanlan.zhihu.com/p/450520990\nUBlueprintCore中的核心内容\n\nTSubclassOf&lt; class UObject&gt; SkeletonGeneratedClass;\nTSubclassOf&lt; class UObject&gt; GeneratedClass;\n\n\nTSubclassOf意思是模板的UClass\nSkeletonGeneratedClass指向一个框架类，变量或者函数添加的时候都会重新生成一次。\n重点在于GeneratedClass，他指向编译完成的可以完整描述一个蓝图的class。\nGeneratedClass，可以理解为一段完整的数据，他描述了某个actor或者其他实例的一切具体数据。\n他在文件中通过一个uasset文件序列化出来，不过uasset也序列化了蓝图本身的信息。\n\n经常会在一些项目内看见一些带“C”的路径内容，比如图中的VideoView也会有一个VideoView_C的版本，这个版本就是这个蓝图的GeneratedClass，而不带C的就是蓝图本身+GeneratedClass，所以一个uasset文件其实是两个文件，编译时通过路径名进行区分。\n\n再注意到蓝图界面的一些内容\n\n这个Parent的意思是这个蓝图代表的GeneratedClass的父类，而不是这个蓝图本身的父类，也许在实际开发过程中经常直接称呼XX蓝图，但是如果要理解蓝图的底层结构，那么先理清“蓝图”和“蓝图代表的类”这个概念很重要。\n那么蓝图是什么东西呢？蓝图就是用来修改他所代表的generatedClass的“编辑器”，当虚幻游戏启动的时候，GeneratedClass中的信息被读取之后本身其实就不起作用了，当然可以在运行时使用蓝图对对象进行编辑，但是退出游戏之后GeneratedClass仍然没有变化。\nGeneratedClass在UE中描述为_C后缀，这个类在实际游戏中往往会被实例化成多个对象，比如玩家一玩家二，怪物一怪物二，这些实例的命名加数字后缀，比如Class_C_2。\n蓝图的编译：指把UBlueprint描述的信息转换为BlueprintGeneratedClass的过程\n\n蓝图虚拟机\n蓝图节点\n虚幻引擎中的蓝图分为很多种，比如关卡蓝图，角色蓝图，控件蓝图等。\n但是不外乎都有一个图表，表内有一些起始节点，也可以放其他事件节点进去。从节点里面拉出来事件线，构成其他条件节点或其他事件节点，这些节点最终组成一个有相无环图，可以说是C++代码中函数、对象的具象化了。\n蓝图使用起来十分简单，这里不做概述，只要有一定C++基础，那么蓝图一定能够看懂。\n这里要说的是每一个蓝图节点是由多个statement组成的，statement在蓝图节点中由一个array引用，他们能够顺序执行，每一条statement代表了一个操作，比如跳转、比如条件判断、比如函数调用。\nstatement在ue源码中，由FBlueprintCompiledStatement类代表，类中具有语句的操作枚举值、操作的函数实例等。\nstatement还属于可视化编程的概念，完全可以说，蓝图连连看其实就是在编写一句句的“statement”逻辑，之后如果点击了“编译蓝图”，那么这些statement就会一股脑编译成一个个字节码。\n字节码\n蓝图在编译后会生成对应字节码，引擎运行时会读取字节码，并交由蓝图虚拟机动态解释执行。\nenum EExprToken\n&#123;\n    // Variable references.\n    EX_LocalVariable\t\t= 0x00,\t// A local variable.\n    EX_InstanceVariable\t\t= 0x01,\t// An object variable.\n    EX_DefaultVariable\t\t= 0x02, // Default variable for a class context.\n    //\t\t\t\t\t\t= 0x03,\n    EX_Return\t\t\t\t= 0x04,\t// Return from function.\n    //\t\t\t\t\t\t= 0x05,\n    EX_Jump\t\t\t\t\t= 0x06,\t// Goto a local address in code.\n    EX_JumpIfNot\t\t\t= 0x07,\t// Goto if not expression.\n    ...\n&#125;\n\n这些字节码都对应了一个个C++函数，可以在ScriptCore.cpp中找到，可以自行加入新字节码并实现对应指令函数。\n虚拟机的本质就是FFrame类，蓝图虚拟机的唯一作用就是解释运行字节码，因为反射GC控制内存等功能都已经被UObject完成了，所以蓝图虚拟机其实十分轻量。\nFFrame\n\nUFunction* Node：当前执行的函数对应蓝图节点\nUObject* Object：执行蓝图的对象\nStep()：取一个字节码运行\n\n\nvoid FFrame::Step(UObject* Context, RESULT_DECL)\n&#123;\n    int32 B = *Code++;\n    (GNatives[B])(Context,*this,RESULT_PARAM);\n&#125;\n\nGNatives是蓝图字节码和函数的映射表，函数由宏IMPLEMENT_VM_FUNCTION进行注册。\n一次蓝图调用可能会出现多个frame，所以需要循环进行Step直到读取到EX_return退出。\n从C++到蓝图的流程\n起点为ReceiveBeginPlay蓝图事件。\n1.如果C++函数被标记为BlueprintImplementableEvent，那么UHT在编译阶段就会在这个函数内生成ProcessEvent代码。\n2.函数被调用时，ProcessEvent函数会创建一个FFrame，对应的Node就是ReceiveBeginPlay。\n3.进行函数环境判断，如果是RPC函数，则会进入RPC的网络层调用，如果是本地函数责会调用ProcessLocalScriptFunction来分析字节码。\n从蓝图到C++\n1.如果C++函数被标记成BlueprintCallable，则说明这个函数能被蓝图调用，在UHT阶段会生成这个函数的exec函数。\n2.exec函数有Z_Param_Result参数（用于返回值）、Code字节码（存有函数本身的参数）、P_THIS-&gt;指针（指向函数本身并调用）。\n3.蓝图调用C++，先创建一个FFrame，解析对应的字节码，如果是本地函数，则直接传入参数进行invoke。\n实质上常说的蓝图调用C++函数，而C++函数调用蓝图函数其实很少，因为本质上C++是不能直接调用蓝图函数的。首先蓝图生成类不是C++NativeClass，是属于一种动态生成代码，C++没办法拿到这个函数的信息与实现，所以肯定没办法直接调用。广义上说的C++调用蓝图，其实是在特定条件下依靠一些特定方式完成的，比如例子中的BlueprintImplementableEvent，他其实也不是蓝图函数，而是声明在C++中，实现（override）在蓝图中的一种函数。也许可以通过这个函数去调用其他蓝图函数，然后实现蓝图的间接调用，不过准确讲，这些都不算C++调用蓝图。\n\n游戏编程与引擎编程\n使用虚幻引擎制作游戏的时候，绝大部分功能需求无论使用C++还是使用蓝图都能够完成。他们的侧重点略有不同。\n比如使用C++编写逻辑，更需要考虑“需要为对象分配多少内容”；使用蓝图进行逻辑编写，更侧重于考虑“gameplay层面上的不同表现”。\n前者更像“底层”，着重于细节上的填充，例如性能优化。\n后者更像“脚本”，着重于游戏框架的搭建。\n一般来说蓝图需要被翻译成机器码，然后再通过C++去调用解析，而C++本身甚至可以通过编译器进行优化，所以C++性能上要优于蓝图。\n之前说过蓝图可以直接被UE转换为C++，这个UE的一个可选功能，叫Blueprint Nativization，其生成的C++代码可读性差，代码性能差，充斥switchcase，而且不能编辑。所以可以考虑在蓝图搭建好游戏框架之后，对需要运行大量tick、开销较大的蓝图进行C++重构。\n蓝图与C++设计模式最佳实践\nC++是面向对象的语言，一般将类定义在.h文件中，类的函数实现在.cpp文件中。\n对于蓝图来说，蓝图的父类、组件、属性、函数列表就是他的类定义，而事件图就是函数实现。\n面向对象有一个很重要的软件工程原则就是“脱耦合”，比如人手拿武器，人就有了武器的引用，但是武器就不需要拥有人的引用了，需要避免工程上武器对人的方法的直接调用。\n一些小的工程当然很好去构建这种关系，比如武器实在想对人传输消息，那么通过提前规定好的事件就行了，在蓝图里面，这样类似的事件系统叫做“事件调度器”。\nmodule\n虚幻引擎中有模块分层的概念，逻辑上模块之间完全分离，需要模块之间显式引用，显式引用的模块，自身所引用的类和方法就暴露给了别的模块了。\n例如虚幻引擎中固有的“Pawn”类和“Weapon”类。这两个类存在两个不同的模块当中，完全分离，但是weapon被核心模块引用，所以pawn可以单方面调用到weapon。\n那么再来回顾一下模块的作用吧\n\n控制构建时间\n代码所有权确定\n责任界定\n\n\n缺点：\n自定义模块比较麻烦，而且自定义模块也会被纳入虚幻模块体系当中，需要按照默认的设计规矩走\n\n蓝图依赖\n蓝图没有模块这个概念，蓝图依赖于所有的C++模块。只要C++代码中有类型被标记为“BlueprintType”，那么蓝图就可以引用他。\n蓝图是资产，所以蓝图可以利用项目中资产的原理来管理蓝图。比如说资产可以查找他们的引用关系，这一招在蓝图上同样奏效。如果是CPP文件，我想大家可以试试使用vs的虚幻C++查找一下一个类的依赖或者一个函数的引用关系，保证有够受的。\n蓝图一个最大的优势就是可以直接调整参数，比如要引用某个特效，恰巧这个特效频繁在改变，那么使用蓝图就是最佳的选择，毕竟使用C++需要频繁更改源码的引用路径，还要重新编译。\n如果要使用事件，那么使用蓝图也是一个很好的选择，因为蓝图的事件系统非常直观（如果有过使用Unity引擎写事件系统的经历应该会有更大的理解）\n当然蓝图最大的优势仍然是：别人看得懂，因为不是所有人都懂C++\nC++性能上的具体优势：可以针对目标平台进行优化、源代码直接编译为机器码，没有多余开销\nC++的其他优势：绑定保存加载期间发生的底层事件、添加编辑器模块、添加C++链接库、创建自定义布局、绑定引擎编辑器事件等\nC++工作流上的优势：蓝图是二进制文件，查看蓝图必须通过项目编辑器对蓝图进行解释，而C++代码是纯文本的，本身是可以通过svn、git等工具做到一个分支合并的功能\n\n举个例子\n一个Pawn，一把武器，在蓝图中可以分别继承defaultpawn类和weapon类，绑定完后为weapon加一个fire事件，fire之后会启用开火特效，这个事件由pawn来触发。\n这一个需求使用蓝图实现起来非常简单，因为所有事件系统在蓝图里面非常直白。\n实际生产过程中需要将pawn使用C++进行重写，因为可能这个pawn需要面临比如ai逻辑，或者物理模拟之类的情况，那么使用C++保证性能是一个更好的选择。现在将pawn进行重写，但是发现pawn用不了weapon了，因为这个weapon是在蓝图中定义的，是动态生成的，C++只知道这个weapon是AActor的子类。\n所以这个pawn哪怕真的通过路径获取到了weapon的实例，那他也调用不了fire函数，因为pawn压根不知道这个actor有fire行为，这是个未定义的。（除非使用反射强行查找，但是这样子更加扯淡了）\n如果这个weapon本来就是C++就好了，那么pawn就能直接引用他了。\n说干就干，那么使用C++也重写一次weapon。\n特效、fire的实现、所有资源的引用都在C++中硬性编写了出来。。。\n这下又违背了资源引用的灵活性了，每一次修改开火的特效，都要重写一次C++然后重新编译！\n而且资产被C++强行引用了，发现每次启动游戏角色的武器都会卡一段时间再加载出来，因为文件加载到内存也是一件麻烦事。那就写成static好了！让游戏启动的时候加载内存。这下这把武器全程都要在内存里躺着了，那到底啥时候该加载他呢，这下谁都不知道了。\nUE自然能帮我们处理所有的麻烦事，只要善用蓝图和C++之间的联系。\n比如BlueprintImplementableEvent标记，他表示这个事件在蓝图中被实现。那么我们可以将fire函数用BlueprintImplementableEvent标记一下，然后再蓝图中实现这个fire函数，这样C++也可以调用到这个fire了。\n其他的需要蓝图“实现”的事情同样也可以这样实现，比如资产网格的载入，蓝图本身就有网格组件，我们将他绑定在weapon蓝图上，这样就不需要C++来管理他了。然后weapon蓝图呢，他的父类直接换成C++父类，这样C++也可以调用他在C++.h中声明的函数了，就比如说fire函数。pawn本身也需要有一个蓝图，因为weapon要被使用，而C++本身无法直接调用蓝图。所以用一个继承C++的pawn类的蓝图类，用这个蓝图绑定weapon蓝图，这样一个层次结构清晰的简单的蓝图——C++模式就诞生了。\n\n","categories":["虚幻引擎系列"]},{"title":"腾讯课堂——电子游戏发展史","url":"/2023/08/08/%E8%85%BE%E8%AE%AF%E8%AF%BE%E5%A0%82%E2%80%94%E2%80%94%E7%94%B5%E5%AD%90%E6%B8%B8%E6%88%8F%E5%8F%91%E5%B1%95%E5%8F%B2/","content":"\n\n\n\n\n电子游戏发展史与关键事件\n\n电子游戏发展史与关键事件\n一个变化迅速的行业，增量比存量更为重要\n\n1972-1983年：电子游戏黎明期\n标志事件：\n\n“Pong”的诞生\n雅达利冲击\n\n\n&nbsp;\n日本市场与任天堂体系（1983年—）\nFC-&gt;SFC-&gt;Wii-&gt;Switch\n\n\n马里奥\n塞尔达\n口袋妖怪\n\n\n&nbsp;\n任天堂体系：“低价”销售主机，不惜代价确保软件质量，收取软件授权金\n即，做最好玩的游戏-&gt;最好玩的游戏只能在我的主机上玩到\n由于只有任天堂有能力做到“授权金体系”，所以世界游戏中心由美国转变到日本\n&nbsp;\n主机行业核心秘密就是制作和补贴第一方的“大作”游戏\n这样的方式使任天堂建立起了“为了大作而购买主机”的游戏核心群体，可以降低参与者的风险\n\n&nbsp;\n&nbsp;\n&nbsp;\n世嘉SEGA\n任天堂的”追随者“\n\n\n索尼克\n莎木\n全面战争\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n科乐美KONAMI\n第三方商业模式\n\n\n魂斗罗\n实况足球\n合金装备\n\n\n&nbsp;\n驱逐小岛秀夫成为科乐美衰退的”标志“事件\n从科乐美开始，占领游戏品类成为游戏厂商占领游戏市场的新思路\n&nbsp;\n&nbsp;\n&nbsp;\n卡普空CAPCOM\n动作格斗游戏品类\n\n\n街头霸王\n生化危机\n怪物猎人\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n史克威尔艾尼克斯SQUARE ENIX\nJRPG王者\n\n\n最终幻想\n勇者斗恶龙\n古墓丽影\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n光荣特库摩KOEI TECMO\n战略游戏之王\n\n\n三国志与无双\n忍者龙剑传\n死或生\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n万代南梦宫BANDAI NAMCO &amp; 角川FRPM SOFTWARE\n动漫授权游戏\n\n\n高达\n铁拳\n黑暗之魂\n艾尔登法环\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n索尼SONY\n重建欧美游戏业的投资人\n\n\n神秘海域\n杀戮地带\n战神\nFATE/Grand Order\n\n\n独占商业模式\n&nbsp;\n&nbsp;\n&nbsp;\n欧美市场崛起（1999-2013）\n1983-1993：雅达利冲击所导致的衰败年代\n1993-1999：家用机的复兴\n&nbsp;\n&nbsp;\n微软Microsoft Studios\n主机/PC合流\n\n\n战争机器\n光环\n我的世界\n\n\nFPS游戏进入主机端使微软形成了强大的竞争力\n摇摆的策略：策略波动性很高\n&nbsp;\n&nbsp;\n&nbsp;\n微软-贝塞斯达Microsoft-Bethesda\nRPG帝国\n\n\n上古卷轴\n辐射\nID\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n阀门Valve &amp; Steam Powered\n一句话：Steam平台\n\n\n半条命\nCS：GO\nDOTA2\nPUBG\n\n\nPC游戏的重振：利用强大的第一方和第三方对战游戏网罗用户，进而笼络中小开发商为它开发大量游戏\n&nbsp;\n&nbsp;\n&nbsp;\n电子艺界Electronic Arts\nEA是规模最大的第三方开发商\n\n\n战地\nFIFA\n质量效应\n\n\n收购与扩张：可惜擅长收购不擅长管理，名声很差，经常解散公司\n&nbsp;\n&nbsp;\n&nbsp;\n动视暴雪Activision Blizzard\n强强联手\n\n\n魔兽世界\n使命召唤\n\n\n防御策略\n&nbsp;\n&nbsp;\n&nbsp;\n育碧Ubisoft\n欧洲第一\n\n\n汤姆克兰西\n刺客信条\n孤岛惊魂\n\n\n研发与创新：育碧是第三方里比较重视研发的一家，但是缺失顶级大IP\n研发成本优先：市场上第一个进入东欧/中国/北非的公司\n工作室分级\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\nT2 Take-Two Interactive\nGTA和开放世界\n\n\nGTA\n文明\nNBA 2k\n\n\n大作优先战略\n&nbsp;\n&nbsp;\n&nbsp;\n中国与免费化\n&nbsp;\n付费游戏市场（1995-2005）\n\n三剑（单机游戏形态）\n传奇（网游游戏形态）-&gt; 盛大\n\n\n商业模式：预付费、月卡、点卡\n\n\n梦幻西游 -&gt; 网易\n魔兽世界 -&gt; 暴雪/九城/网易\n\n\n&nbsp;\n免费网游市场（2006-2011）\n\n征途 -&gt; 巨人\n\n\n商业模式：\n1、降低进入门槛\n2、弹性消费\n3、玩家分层与社交化\n4、游戏非玩家化\n5、免费游戏的优劣\n\n\n诛仙 -&gt; 完美世界（IP版权进入游戏）\n英雄联盟 -&gt;QQ/Riot（对战游戏进入免费游戏）\n坦克世界 -&gt; 空中网（对战游戏进入免费游戏）\n\n\n&nbsp;\n网页游戏市场（2009-2013）\n商业模式：\n1、数据驱动设计-&gt;付费优先\n2、流量依赖-&gt;导致大量同质化\n\n\n开心农场 -&gt;开心网（社交进入游戏）\n游族、心动、墨舲（战略、卡牌、ARPG...... )-&gt;中度品类设计\n平台渠道化\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n跨国网游到跨端（全球化与移动化）\n&nbsp;\nNCSOFT/NEXON（韩国）\n\n天堂\n剑灵\n冒险岛\n\n\n&nbsp;\nDENA/GREE/DMM.com（日本）\n\n龙收集\n钓鱼之星\n舰c\n\n\n&nbsp;\nGongHo/Mixi/Cygames/Com2us（日韩手游）\n&nbsp;\nApple/Google（移动游戏基础渠道）\n\nPvz\nKR\n\n\n基础渠道依赖轻度用户生存\n&nbsp;\nFacebook/Zynga（网页与社交游戏）\n&nbsp;\nRovio/King/Glu（轻度游戏）\n\nAngry Birds\n\n\n&nbsp;\nSupercell/MachineZone/Elex Tech（重度游戏）\n&nbsp;\n莉莉丝（中度化与卡牌）\n\nMT\n刀塔传奇\n\n\n&nbsp;\nBilibili/抖音/叠纸/🦅角/紫龙（视频渠道与新兴文化）\n&nbsp;\nEpic/Bluehole/Gerena（创新游戏与全球市场贯通）\n\nPUBG\n堡垒之夜\nFree Fire\n\n\n&nbsp;\nNiantic/Roblox/Mihoyo（跨端等）\n\nPokemon Go\n原神\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n\n","categories":["游戏设计杂谈"]},{"title":"虚拟内存","url":"/2023/05/19/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/","content":"\n\n\n\n\n\n\n\n","categories":["操作系统"]},{"title":"虚幻引擎启动阶段做了什么","url":"/2024/11/15/%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E9%98%B6%E6%AE%B5%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/","content":"\n\n\n\n\nUE引擎开始游戏做了什么\n\nMAIN\n程序入口LaunchWindows.cpp\nint32 WINAPI WinMain(_In_ HINSTANCE hInInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ char* pCmdLine, _In_ int32 nCmdShow)\n&#123;\n    int32 Result = LaunchWindowsStartup(hInInstance, hPrevInstance, pCmdLine, nCmdShow, nullptr);\n    LaunchWindowsShutdown();\n    return Result;\n&#125;\n\nUE引擎的游戏入口就各种各样的Launch，这里举的是一个Windows平台的例子，那么直接进入LaunchWindowsStartup。\n忽视一大堆平台支持相关预处理宏标记等，直接来到比较核心的部分GuardedMain。\nFEngineLoop\tGEngineLoop;\nint32 GuardedMain(const TCHAR* CmdLine)&#123;\n    int32 ErrorLevel = EnginePreInit( CmdLine );\n    if ( ErrorLevel != 0 || IsEngineExitRequested() )\n    &#123;\n    return ErrorLevel;\n    &#125;\n    ErrorLevel = EditorInit(GEngineLoop);\n    while( !IsEngineExitRequested() )\n    &#123;\n    EngineTick();\n    &#125;\n    EditorExit();\n&#125;\n\n总而言之就是四大块：预初始化、初始化、tick、退出\n模块注册\n首先来看PreInit——UE模块加载的地方。\n在一开始会加载引擎核心模块CoreUObject、Engine、Renderer。。。\n之后会进入Default阶段加载项目和插件默认模块比如C++游戏代码等。\n#pragma once\n#include &quot;CoreMinimal.h&quot;\n#include &quot;GameFramework/Actor.h&quot;\n\n#include &quot;SomeActor.generated.h&quot;\nUCLASS()class MyClass : public AActor&#123;    GENERATED_BODY()    public:    MyClass(const FObjectInitializer&amp; ObjectInitializer);    virtual void BeginPlay() override;    virtual void Tick(float DeltaSeconds) override;&#125;\n在每一个模块加载的第一步，都是将这个模块内定义的所有UObject类注册一遍提供给反射系统，之后生成CDO（类默认对象），记录这个类的默认状态，还能用于子类继承。\n在类构造时，引擎会将CDO传给这个类的构造函数用于构造，就像例子中的一样。\n所以对于UObject来说构造函数最好不要放和逻辑相关的东西例如为一个特定的对象初始化属性。\n\n所有的UObject注册完之后，就是经典的StartupModule()和ShutdownModule()生命周期了\nvirtual void StartupModule() override;\nvirtual void ShutdownModule() override;\n\nINIT\nint32 FEngineLoop::Init()&#123;\n    FString GameEngineClassName;\n    GConfig-&gt;GetString(TEXT(&quot;/Script/Engine.Engine&quot;), TEXT(&quot;GameEngine&quot;), GameEngineClassName, GEngineIni);\n    EngineClass = StaticLoadClass( UGameEngine::StaticClass(), nullptr, *GameEngineClassName);\n    GEngine = NewObject&lt;UEngine&gt;(GetTransientPackage(), EngineClass);\n    check( GEngine );\n\n//Engine核心事件\nGEngine-&amp;gt;ParseCommandline();\nGEngine-&amp;gt;Init(this);\n\n//加载PostEngineInit阶段加载的插件模块\nIProjectManager::Get().LoadModulesForProject(ELoadingPhase::PostEngineInit);\nIPluginManager::Get().LoadModulesForEnabledPlugins(ELoadingPhase::PostEngineInit);\n\nGEngine-&amp;gt;Start();\nreturn 0;\n\n}\nEngine类\n如果看过InsideUE5 gameplay部分或者我写的阅读笔记，就明白这个类主要负责游戏的核心内容编辑。\n比如Browse和LoadMap。\nbool UEngine::LoadMap( FWorldContext&amp; WorldContext, FURL URL, class UPendingNetGame* Pending, FString&amp; Error )\n\n一个Engine对象，可以浏览到一个URL。这个URL代表服务器，也可以用于加载一个本地的地图。\n在DefaultEngine.ini文件中设置默认地图时将默认地图本地位置设置上去，也可以在启动游戏时使用命令行输入URL来覆盖默认的地图。\nEngine对象的初始化出现了一些比较属性的东西\n\nvoid UGameEngine::Init(IEngineLoop* InEngineLoop)\n&#123;\n    // Call base.\n    UEngine::Init(InEngineLoop);\n\n//GameInstance对象\nFSoftClassPath GameInstanceClassName = GetDefault&amp;lt;UGameMapsSettings&amp;gt;()-&amp;gt;GameInstanceClass;\nUClass* GameInstanceClass = (GameInstanceClassName.IsValid() ? LoadObject&amp;lt;UClass&amp;gt;(NULL, *GameInstanceClassName.ToString()) : UGameInstance::StaticClass());\nGameInstance = NewObject&amp;lt;UGameInstance&amp;gt;(this, GameInstanceClass);\nGameInstance-&amp;gt;InitializeStandalone();\n\n//GameViewportClient对象\nUGameViewportClient* ViewportClient = NewObject&amp;lt;UGameViewportClient&amp;gt;(this, GameViewportClientClass);\nViewportClient-&amp;gt;Init(*GameInstance-&amp;gt;GetWorldContext(), GameInstance);\nGameViewport = ViewportClient;\nGameInstance-&amp;gt;GetWorldContext()-&amp;gt;GameViewport = ViewportClient;\n\n//LocalPlayer对象\nFString Error;\nViewportClient-&amp;gt;SetupInitialLocalPlayer(Error) == NULL;\n&#123;\n    UE_LOG(LogEngine, Fatal,TEXT(&amp;quot;%s&amp;quot;),*Error);\n&#125;\n\nUGameViewportClient::OnViewportCreated().Broadcast();\nbIsInitialized = true;\n\n}\nGameInstance、GameViewportClient、LocalPlayer三者在UEngine的初始化过程中诞生，完全可以将他们理解成游戏地图加载之前生成的对象。\n与之相对的UWorld、ULevel、AActor、UActorComponent等等这些对象都是在“地图加载之后”生成的，与地图生命周期全权挂钩。如果游戏退出地图，或者说游戏退出到主菜单、掉线，那么这些对象都会被销毁。\n这些对象都和场景挂钩，那么就直接来看看加载地图的LoadMap，他在引擎对象初始化后运作\nbool UEngine::LoadMap( FWorldContext&amp; WorldContext, FURL URL, class UPendingNetGame* Pending, FString&amp; Error )&#123;\n    //原代码2k多行实在太长，这里直接写伪代码\n    WorldContext.OwningGameInstance-&gt;PreloadContextForURL(URL);\n    UPackage* WorldPackage = LoadPackage(...);//UWorld世界包含ULevel，然后ULevel中含所有的AActor，AActor包含Component，这些所有都打成Pack包存在内存中，需要重新打开事件的时候重新加载他\n    UWorld* NewWorld = UWorld::FindWorldInPackage(...);\n    NewWorld-&gt;SetGameInstance(WorldContext.OwningGameIntance);//WorldContext由GameInstance创建，用于跟踪当前UWorld\n\nWorldContext.SetCurrentWorld(NewWorld); //设置当前世界\nWorldContext.World()-&amp;gt;WorldType = WorldContext.WorldType; //世界类似设置为Game\nWorldContext.World()-&amp;gt;AddToRoot();//防止垃圾回收\nWorldContext.World()-&amp;gt;InitWorld();//初始化世界的物理、AI、声音等设置\nWorldCOntext.World()-&amp;gt;SetGameMode(URL)//设置GameMode\n\n//顾名思义初始化Actor\n&#123;\n    FRegisterComponentContext Context(WorldContext.World());\n    WorldContext.World()-&amp;gt;InitializeActorsForPlay(URL, true, &amp;amp;Context);\n    Context.Process();\n&#125;\n\n}\nvoid UWorld::InitializeActorsForPlay(const FURL&amp; InURL, bool bResetTime, FRegisterComponentContext* Context)&#123;\n    遍历Actor\n    遍历Actor中的Component进行注册（比如将本World的引用设置在Component内）\n    遍历Actor进行Actor自身的游戏化构造。。。\n&#125;\n\n网络游戏生成/登录流程\n//todo\nUClass与UObject\n在C++中定义一个Class类，用它实例化一个对象obj，那么仅凭这个obj，没有办法直接获取到这个Class本身的属性和方法。\n但是UE中的对象可以做到。\n很明显，UClass继承与UObject，经常说UObject作为虚幻引擎中几乎所有类的基类，他做的一个较重要的工作就是实现反射功能。也就是说UClass也能使用反射功能比如GetClass、StaticClass方法等。\nUE中创建对象的方法不是new，而是**NewObject&lt;&gt;**方法,这个方法同时为目标对象生成了一个伴随对象，这个伴随对象的类型就是UClass，直接存放在目标对象的变量内。\n除了UClass用于描述UObject，还有UEnum描述枚举、UFunction描述函数、FFIeld描述基础类型等\n\nUClass功能\n\n实现反射系统\n记录类的继承关系\n记录类元数据\n生成CDO并保留引用\n生成对象间引用关系用于垃圾回收\n\n\nUObject功能\n\n提供通用属性接口GetClass、GetName\n序列化反序列化\n内存管理、对象内存分配\n垃圾回收机制\nNetWork\n蓝图虚拟机\n\n\n&nbsp;\n\n","categories":["虚幻引擎系列"]},{"title":"计网课后一","url":"/2023/10/06/%E8%AE%A1%E7%BD%91%E8%AF%BE%E5%90%8E%E4%B8%80/","content":"\n\n\n\n\n计算机网络第一章课后\n\n计算机网络第一章课后\n\n计算机网络协议（Protocol）：计算机网络协议是在计算机网络中进行通信和交换信息的规则和约定的集合。它定义了网络中数据的格式、传输方式、错误检测和纠正等方面的规范，以确保不同设备和系统之间能够正确地进行通信。\n\n\n\n协议实体（Protocol Entity）：协议实体是指在计算机网络中执行协议的实体或模块。它可以是硬件设备（如网络接口卡）或软件进程（如网络传输协议的实现）。每个协议实体负责执行特定的协议功能，包括处理协议消息、发送和接收数据等。\n\n\n\n服务原语（Service Primitives）：服务原语是计算机网络中定义的一组操作，用于实现协议实体之间的通信和交互。它们提供了一种编程接口，允许上层协议实体请求和使用底层协议实体提供的服务。\n\n\n请求原语（request primitive）：上层协议实体向底层协议实体发送请求，请求执行特定的操作或服务。\n指示原语（indication primitive）：底层协议实体向上层协议实体发送指示，指示发生了特定的事件或接收到了数据。\n响应原语（response primitive）：底层协议实体向上层协议实体发送响应，回复对请求的执行结果或提供所请求的服务。\n确认原语（confirm primitive）：上层协议实体收到底层协议实体的响应后，发送确认原语以确认接收到响应或处理结果。\n\n\n\n\n协议数据单元（PDU）：协议数据单元是在计算机网络中传输的数据单元，它是协议中信息交换的基本单位。不同层次的协议将数据分割为不同的PDU进行传输，每个PDU包含特定的协议头部和有效载荷（payload）。每个协议层将接收到的PDU解析，并将有效载荷传递给上层协议，以实现数据的递送和处理。在不同的协议层中，协议数据单元可能具有不同的名称（如帧、分组、报文等）。\n\n\n\n&nbsp;\n\n面向连接的服务（Connection-Oriented Service）\n\n\n通信的两个端点（发送方和接收方）在建立通信之前需要先建立一个连接。连接的建立涉及到握手过程，其中包括发送方和接收方之间的交换控制信息以建立可靠的通信路径。\n连接的建立使得通信的两端可以在通信的整个过程中维护状态信息，以便进行错误检测、流量控制、数据分割和重组等操作。数据传输完成后，连接可以被显式地终止，释放相关的资源。\n面向连接的服务通常提供可靠性、流量控制和顺序传输等特性，适用于对数据传输的可靠性和顺序性有较高要求的应用，如文件传输、视频流传输等\n\n\n\n\n无连接的服务（Connectionless Service）：\n\n\n通信的两个端点之间在发送数据之前不需要建立连接，每个数据包都是独立地发送和处理。发送方将数据包发送到网络，接收方根据数据包的目的地址进行处理。\n不需要事先建立连接，也不需要维护连接状态信息。每个数据包都是独立的实体，其传输和处理是相互独立的。\n无连接的服务通常提供了较低的传输延迟和较小的开销，适用于对实时性要求较高、容忍一定数据丢失的应用，如实时音频、视频通话等。\n\n\n\n\n\n\n&nbsp;\n\n电路交换（Circuit-Switching）：\n\n\n通信的两个端点之间在通信过程中会建立一条专用的物理连接（电路）。这条连接会一直保持到通信结束，不论是否有数据传输。\n在建立连接之后，整个带宽和资源都被分配给该连接，即使在没有数据传输的时候也是如此。这意味着在连接期间，带宽是专用的，不与其他连接共享。\n数据在电路交换中按照固定的顺序传输，保证了数据的有序性和实时性。数据被分割为固定大小的数据单元（例如语音通话中的时间槽），然后按照顺序通过连接进行传输。\n电路交换适用于需要连续、实时传输的应用，如传统的电话通信。由于连接是专用的，它可以提供稳定的带宽和固定的时延，但在没有数据传输时仍然占用资源。\n\n\n\n\n分组交换（Packet-Switching）：\n\n\n\n\n\n数据被分割为更小的数据包（分组）进行传输。每个数据包包含有关目标地址和其他控制信息，以便在网络中进行路由和交换。\n数据包根据网络中的可用路径独立地传输，可能通过多个中间节点（路由器）进行转发。每个数据包在传输过程中独立处理，而不需要建立专用的连接。\n分组交换能够更加灵活地利用网络资源，因为多个数据包可以并行地通过网络进行传输，并且数据传输的带宽和延迟可以根据当前网络负载动态分配。\n分组交换适用于非实时性要求较高或数据传输较大的应用，如互联网数据传输。它允许多个通信会话共享网络资源，并且可以根据需要动态调整带宽分配。\n\n\n\n\n\n\n&nbsp;\n\nOSI-RM（开放系统互联-参考模型）\n\n物理层：物理层协议负责在物理媒介上传输原始比特流，提供了数据的传输和接收。它定义了电压、频率、物理连接接口等物理特性。\n\n机械特性：规定了物理连接时对插头和插座的几何尺寸、插针或插孔芯数及排列方式\n电气特性：规定了信号状态的电压、电流的识别，最大传输速率等\n功能特性：规定了接口信号的来源、作用及其他信号之间的关系\n过程特性：规定了使用交换电路进行数据交换的控制步骤，这些控制步骤应用便于比\n\n\n数据链路层：数据链路层协议负责将原始的比特流组织成更高层次的数据单位（帧），并进行错误检测和纠正，以确保数据在物理链路上的可靠传输。\n\n帧的定界、流量控制、差错检测与纠正、访问控制\n通常使用MAC（媒体访问控制）地址来标识网络设备。\n\n\n网络层：网络层协议负责实现数据在网络中的路由和转发功能，将数据从源主机发送到目标主机。它使用逻辑地址（如IP地址）来标识网络设备。\n\n选择、寻址、分组编码和解码、拥塞控制\n定义了数据包的传输路径，并处理不同网络之间的连接。\n\n\n传输层：传输层协议提供端到端的可靠数据传输，确保数据在源主机和目标主机之间的透明可靠传输。它使用端口号标识不同的应用程序。\n\n提供在不同系统之间的进程间数据交互的可靠服务\n分段和重组数据、流量控制、拥塞控制、错误检测和纠正\n传输层协议可以是面向连接的（如TCP）或无连接的（如UDP）。\n\n\n会话层：对对话的双方进行资格审查和验证的规则（发送时进行加密的规则，MD5加密），同时规定发送时的双工模式\n\n单工数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信，举例：电视，广播。\n半双工数据传输允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：对讲机。\n全双工数据通信允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信，举例：电话通信。\n\n\n表示层：为数据在传输之前对加密、解密、压缩、解压缩及终端数据格式转换提供一套规则和约定\n\n应用层：所有能产生网络流量的程序，提供应用程序运行的环境、负责管理和执行应用程序\n\n\n\n&nbsp;\n\n基带传输：指将原始信号（基带信号）直接传输到通信媒介上，不经过调制过程。\n\n把直流（零频）开始到能量集中的一段频率范围称为基本频带，简称为基带。\n特点是频带窄，只能传输低频信号。它的传输距离较短，且容易受到噪声和干扰的影响。因此，通常需要使用放大器和调整器来增强信号和抵消噪声。——局域网\n\n\n带通传输：将原始信号进行调制，转换为适合在通信媒介上传输的信号。\n\n可以传输较高频率的信号，适用于长距离通信。它对噪声和干扰的影响较小，具有较好的抗干扰性能。\n\n\n\n\n&nbsp;\n\n基带编码方案：\nRZ（归零码）\n\n\n\n\n\nNRZ(不归零码)\n\n\n\n\nNRZI(不归零逆)——USB\n\n\n\n0变1不变\n\n&nbsp;\n\n调制：在信号传输过程中，将数字信号或基带信号转换为适合在传输介质上传输的模拟信号或载波信号的过程。——振幅、频率或相位\n\n调制的基本目的是将原始信号调整到适合传输的频率范围，以便有效地传输信号，提高传输质量和可靠性。\n调幅（AM）、调频（FM）、调相（PM）、正交振幅调制（QAM）、正交频分多路复用（OFDM）\n\n\n复用：将多个信号或数据流合并到一个共享的传输通道上的过程。\n\n允许多个信号通过同一传输介质同时传输，以提高传输效率和利用率。\n常用于电话系统、数据通信网络和广播电视等领域。\n时分复用（TDM）、频分复用（FDM）、波分复用（WDM）、码分复用（CDM）\n\n\n\n\n&nbsp;\n\n5G移动通信网络面向的三大类业务场景：增强移动宽带、大规模机器类通信、超可靠低延迟通信\n\n\n&nbsp;\n\nLinux命令：\n\n\n\nip: ip命令用于管理网络接口和路由表。它可以用来配置网络接口的IP地址、子网掩码、网关等信息，也可以查看和修改路由表信息，以及执行其他与网络相关的操作。\nip link: ip link命令用于管理网络接口。它可以列出系统上的网络接口，包括物理接口和虚拟接口，并提供配置接口、启用/禁用接口、设置MTU（最大传输单元）等功能。\nip route: ip route命令用于管理IP路由表。它可以显示当前系统的路由表信息，包括目的网络、下一跳网关、出接口等，并可以添加、修改或删除路由表项。\nping: ping命令用于测试与目标主机之间的连通性。通过发送ICMP回显请求消息（ping请求）并等待目标主机的回应消息（ping响应），可以检查网络是否可达以及延迟时间。\nifconfig: ifconfig命令用于配置和显示网络接口的配置信息。它可以列出系统上的网络接口及其配置，包括IP地址、子网掩码、MAC地址等。然而，目前在许多Linux发行版中，ifconfig已被ip命令所取代。\nroute: route命令用于管理IP路由表。它可以显示和操作系统上的路由表信息，包括添加、删除或修改路由表项。然而，推荐使用更现代的ip route命令来代替。\ntcpdump: tcpdump命令用于在网络上抓取和分析数据包。它可以捕获经过指定网络接口的数据包，并以人类可读的格式显示这些数据包的详细信息，如源IP地址、目标IP地址、端口号等。\nnetstat: netstat命令用于显示网络连接、路由表和网络接口的状态信息。它可以列出当前系统上的网络连接、监听端口、网络接口统计信息等，有助于诊断网络问题和监控网络活动。\niptables: iptables命令用于配置Linux系统上的防火墙规则。它可以设置和管理网络数据包的过滤规则、NAT（网络地址转换）规则、端口映射等，提供对网络流量的控制和保护。\n\n\n\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n\n","categories":["计算机网络"]},{"title":"进程与线程","url":"/2023/05/28/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","content":"\n\n\n\n\n\n\n进程定义\n程序段、数据段、PCB组成进程实体，即进程，创建进程即创建PCB，撤销即撤销PCB（进程存在的唯一标志）\n\n定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位\n进程组成：\n\n\n&nbsp;存放性质\nPCB进程管理者（操作系统）所需数据进程存在的唯一标志程序段要执行的程序代码&nbsp;数据段执行过程中的各种数据&nbsp;\n\n进程的状态与转化\n基本状态：运行态，就绪态，阻塞态\n\n进程转化的实质就是PCB的修改以及相关环境的改变（如某些寄存器的值的改变）  \n进程通信\n三种方式：共享存储，消息传递（消息队列），管道通信\n\n共享储存：基于数据结构的共享（低级）与基于存储区的共享（高级）\n\n管道通信：半双工通信，同一时间段内只能实现单向的传输（双向通信需要设置两个              \n管道）\n当管道满时，写进程的write（）被阻塞；\n当管道空时，读进程的read（）被阻塞。\n即没写满不能读，没空不能写\n由于数据被读出后就被抛弃，所以读进程最多只有一个\n\n\n消息传递：格式化的消息为单位通过“发送消息/接收消息”两个原语进行数据交换\n\n\n\n\n//中间的调度内容被吃掉了，以后吐出来//\n\n进程调度的时机\n主动放弃与被动放弃进程\n不能进行进程调度与切换的情况：\n1、处理中断\n2、在操作系统内核程序临界区中\n3、在原子操作过程中  \n内核程序临界区与临界区并不相同\n进程调度方式：1、非剥夺调度方式（非抢占方式）2、剥夺调度方式（抢占方式）\n                           前者实现简单，但无法及时处理紧急任务\n进程切换：指一个进程让出处理机，另一个进程占用处理机的过程\n狭义的进程调度：从就绪队列中选中一个要运行的进程\n广义的进程调度：选择一个进程并进行进程切换\n进程切换过程：1、对原来运行进程各种数据保存\n                           2、对新的进程各种数据的恢复\n过于频繁的进程切换会导致系统的效率降低\n\n调度算法的评价指标\n\nCPU利用率=忙碌的时间/总时间\n\n\n\n系统吞吐量（单位时间完成作业的数量）=总共完成了多少道作业/总共花了多少时间\n\n\n\n周转时间=作业完成时间-作业提交时间\n\n\n\n平均周转时间=各作业周转时间之和/作业数\n\n\n\n带权周转时间（大于等于1）=作业周转时间/作业实际运行的时间\n\n\n\n平均带权周转时间=各作业带权周转时间之和/作业数\n\n\n&nbsp;\n等待时间：\n1、对于进程，等待时间指进程建立后等待被服务的时间之和\n2、对于作业还要多考虑作业在外存中被等待调度的时间\n响应时间：用户提交请求到首次产生响应所用的时间\n调度算法\n链表数据如下：\ntypedef struct thread &#123;\nint pid;//线程运行信号\nint counter;\nint nice;\nstruct thread* next;\n&#125;thread,*LinkList;\n\nint algorithm(int counter,int nice) &#123;    int priority &#x3D; counter + 20 - nice;    return priority;&#125;\n先来先服务（FCFS）\n另一种思路——等待时间越久的优先\n\n对于作业与对于进程，先来后到概念不同\n对长作业有利，对短作业不利\n\n\n补充与FCFS相似的FIFO：\nvoid SCHED_FIFO() &#123;\n    int Pid = 1;\n    LinkList H = (thread*)malloc(sizeof(thread));\n    LinkList T = H;\n    H-&gt;next = NULL;\n    while (1) &#123;\n        int Counter = 0;\n        int Nice = 0;\n        scanf_s(&quot;%d %d&quot;, &amp;Counter, &amp;Nice);\n        //两个时间片之间增加线程\n        if (Counter != 0) &#123;\n            LinkList p = (thread*)malloc(sizeof(thread));\n            p-&gt;counter = Counter;\n            p-&gt;nice = Nice;\n            p-&gt;pid = Pid;\n            Pid++;//为下一个线程线程pid自动加一做准备\n            //如果队列内暂时为空，那么线程先直接进入cpu运转\n            if (H-&gt;next == NULL) &#123;\n                H-&gt;next = p;\n                p-&gt;next = NULL;\n            &#125;\n            else &#123;\n                for (LinkList p1 = H;; p1 = p1-&gt;next) &#123;\n                    if (p1-&gt;next-&gt;nice &lt;p-&gt;nice) &#123;\n                        p-&gt;next = p1-&gt;next;\n                        p1-&gt;next = p;\n                        break;\n                    &#125;\n                    else &#123;\n                        if (p1-&gt;next-&gt;next == NULL) &#123;\n                            p1-&gt;next-&gt;next = p;\n                            p-&gt;next = NULL;\n                            break;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        //两个时间片之间不加线程,或者增加线程后\n        if (H-&gt;next != NULL) &#123;\n            H-&gt;next-&gt;counter--;\n            printf(&quot;正在运行线程%d&quot;, H-&gt;next-&gt;pid);\n            printf(&quot;该线程还剩%d运行时间&quot;, H-&gt;next-&gt;counter);\n            //如果线程运行完毕\n            if (H-&gt;next-&gt;counter &lt;= 0) &#123;\n                LinkList p = H-&gt;next;\n                H-&gt;next = H-&gt;next-&gt;next;\n                free(p);\n            &#125;\n        &#125;\n        else &#123;\n            printf(&quot;队列空，CPU空闲状态&quot;);\n        &#125;\n    &#125;\n&#125;\n\n短作业优先（SJF）\n短进程优先调度（SPF）\n非抢占式，每次调度时选择当前已到达且运行时间最短的作业、进程\n最短剩余时间优先算法（SRTN）\n抢占式，每当就绪队列改变时，计算新到达进程的剩余运行时间与当前运行进程的剩余运行时间，由最短的来抢占。同时，在一个进程完成时也需要调度\n\n对短作业有利，对长作业不利，可能产生饥饿现象（某些作业一直得不到运行)\n\n\n在题目中，提到的“短作业/进程优先算法”默认是非抢占式的，引出概念：在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少\n\n高响应比优先 （HRRN）\n非抢占式，经典折中\n\n等待时间相同时，要求服务时间短的优先（SJF优点）\n要求服务时间相同时，等待时间长优先（FCFS优点）,避免饥饿\n\n\n响应比=（等待时间+要求服务时间）/要求服务时间\n\n时间片轮转（RR）\n抢占式，轮流让就绪队列中的进程依次执行一个时间片（一般题目给出时间片大小）\n\n下处理机时重新放回队尾，时间片不能太大也不能太小\n公平，适用分时操作系统，不区分任务紧急度\n\n\nvoid SCHED_RR() &#123;\n    int Pid = 1;\n    LinkList H = (thread*)malloc(sizeof(thread));\n    LinkList T = H;\n    H-&gt;next = NULL;\n    while (1) &#123;\n        int Counter = 0;\n        int Nice = 0;\n        scanf_s(&quot;%d %d&quot;, &amp;Counter, &amp;Nice);\n        //两个时间片之间增加线程\n        if (Counter != 0) &#123;\n            LinkList p = (thread*)malloc(sizeof(thread));\n            p-&gt;counter = Counter;\n            p-&gt;nice = Nice;\n            p-&gt;pid = Pid;\n            Pid++;//为下一个线程线程pid自动加一做准备\n            //如果队列内暂时为空，那么线程先直接进入cpu运转\n            if (H-&gt;next == NULL) &#123;\n                H-&gt;next = p;\n                p-&gt;next = NULL;\n            &#125;\n            else &#123;\n                for (LinkList p1 = H;; p1 = p1-&gt;next) &#123;\n                    if (algorithm(p1-&gt;next-&gt;counter, p1-&gt;next-&gt;nice) &lt; algorithm(p-&gt;counter, p-&gt;nice)) &#123;\n                    \tp-&gt;next = p1-&gt;next;\n                    \tp1-&gt;next = p;\n                    \tbreak;\n                        &#125;\n                \telse &#123;\n                    \tif (p1-&gt;next-&gt;next == NULL) &#123;\n                        \tp1-&gt;next-&gt;next = p;\n                            p-&gt;next = NULL;\n                            break;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        //两个时间片之间不加线程,或者增加线程后\n        if (H-&gt;next != NULL) &#123;\n        \tH-&gt;next-&gt;counter--;\n            printf(&quot;正在运行线程%d&quot;, H-&gt;next-&gt;pid);\n            printf(&quot;该线程还剩%d运行时间&quot;, H-&gt;next-&gt;counter);\n\n        //如果线程运行完毕\n        if (H-&amp;gt;next-&amp;gt;counter &amp;lt;= 0) &#123;\n            LinkList p = H-&amp;gt;next;\n            H-&amp;gt;next = H-&amp;gt;next-&amp;gt;next;\n            free(p);\n        &#125;\n        //如果线程未运行完毕，接入链表尾\n        else &#123;\n            //如果队列中只有一个线程，则继续分配时间片并运行\n            if (H-&amp;gt;next-&amp;gt;next != NULL) &#123;\n                LinkList p = H-&amp;gt;next;\n                H-&amp;gt;next = H-&amp;gt;next-&amp;gt;next;\n              \tif (p1-&amp;gt;next == NULL) &#123;\n                        p1-&amp;gt;next = p;\n                        p-&amp;gt;next = NULL;\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    else &#123;\n        printf(&amp;quot;队列空，CPU空闲状态&amp;quot;);\n    &#125;\n&#125;\n\n}\n优先级调度算法\n抢占式，非抢占都有（注意看题），每个作业/进程都有各自优先级，选择优先级最高的\n多级反馈队列调度算法\n对其他算法的权衡\n\n/多级调度算法有很多细节补充\n然后进程同步和互斥也被吃了\n\n死锁\n对资源分配不合理容易发生\n至少两个或两个以上的进程同时发生死锁（争夺资源而导致阻塞）\n注意与“死循环”和“饥饿”的区别\n\n必要条件：\n\n互斥条件（必须相互争夺资源）\n\n\n\n不剥夺条件（资源在未使用完之前不能被强行夺走）\n\n\n\n请求和保持条件（已经保持了资源，但又请求资源）\n\n\n\n循环等待条件（存在资源循环等待链）\n\n\n处理策略：预防死锁，避免死锁，死锁的检测和解除(纯废话，但还是记一下) \n银行家算法\n安全序列：\n按照这种序列分配顺序，就能顺利完成。\n所以说安全序列可有多个\n如果找不出任何安全序列，就进入不安全状态\n如果能找出任何一个安全序列，就进入安全状态\n算法：\n每个进程声明一个m*n的最大需求矩阵Max与分配矩阵Allocation\n另外留一个长度为m的一维数组Available\n然后逐个对比并实验分配\n\nAvailable向量：系统中可利用的资源数目\nMax矩阵：每个进程对每种资源的最大需求\nAllocation矩阵：每个进程已分配的各类资源的数目\nNeed矩阵：每个进程还需要的各类资源数\n\n\nNeed[i,j] = Max[i,j] - allocation[i, j]\n\n死锁的检测和解除\n资源剥夺法（挂起进程，容易饥饿）、撤销进程法、进程回退法（要记录进程历史信息）\n&nbsp;\n\n\n","categories":["操作系统"]},{"title":"面向对象分析设计导论前半","url":"/2023/11/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1%E5%AF%BC%E8%AE%BA%E5%89%8D%E5%8D%8A/","content":"\n\n\n\n\n面向对象分析设计导论\n\n面向对象分析设计导论\n&nbsp;\n什么是OOAD？\n面向对象的分析和设计 （OOAD） 是一种技术方法，通过应用面向对象的编程来分析和设计应用程序、系统或业务，并在整个软件开发过程中使用可视化建模来指导利益相关者的沟通和产品质量。\n&nbsp;\nOOA\n强调在问题域中查找和描述对象或概念——需要相关领域的专家以及面向对象的专家\n&nbsp;\nOOD\n强调定义具有属性和方法的逻辑软件对象——根据OOA阶段的结果定义，包括软件逻辑解决方案以及类方法的定义\n&nbsp;\nOOAD基本能力\n巧妙地将职责分配给软件组件\n&nbsp;\n分析与设计\n\n分析强调对问题的调查——what\n设计强调逻辑解决方案——how\n\n\n&nbsp;\n抽象与分类与类\n\n抽象：忽略事物的非本质特征，只注意那些与当前目标有关的本质特征，从而找出事物的共性\n分类：把具有共同性质的事物划分为一类，得出一个抽象的概念\n类：具有相同属性和操作的一组对象的集合\n\n\n&nbsp;\n敏捷开发与迭代开发\n敏捷开发是以用户的需求为核心，采用迭代、循序渐进的方式开发软件。\n优点：\n\n具备进化式精化的计划、需求和设计的短时间定量迭代是这些方法所共有的基本实践\n倡导反映简易、轻量、沟通、自组织团队等更多敏捷性的实践和原则\n\n\n方法：\n\n通常应用时间定量的迭代和进化式开发\n使用自适应计划\n提倡增量交付\n并包含其他提倡（快速和灵活的响应变更）的价值和实践\n\n\n&nbsp;\n迭代开发整个工作被划分为一系列袖珍的、固定时间的小项目，这叫系列迭代。\n优点：\n\n减少项目失败可能性，提高生产率、降低缺陷率\n在早期缓解高风险\n早期可见的进展\n早期反馈、用户参与和调整，会产生更接近涉众真实需求的精华系统\n可控复杂性\n一次迭代中的经验可以被系统地用于改进开发过程本身32\n\n\n&nbsp;\n瀑布模型的错误\n\n假设规格说明是可预知的和稳定的，并且能够在项目开始时就正确定义\n典型的软件项目在需求上会经历25%的变更\n“新产品开发”领域-软件开发是（平均而言）变更极大且不稳定的领域\n\n\n&nbsp;\n反馈和改写\n\n早期开发中的反馈\n来自测试中的反馈，有助于开发者精化设计或模型\n来自团队处理早期特性过程的中反馈,有助于精化时间表和估计\n来自客户和市场的反馈，有助于重新定义下一次迭代实现特性的优先级\n\n\n&nbsp;\n敏捷建模\n\n使用敏捷方法并不意味着不进行任何建模\n不要单独建模，建模和模型的目的主要用于理解和沟通，并不是构建文档\n不要对所有或大多数软件设计建模或使用UML。\n尽可能使用最简单的工具。例如在白板上画UML草图，使用相机拍照等。\n\n\n&nbsp;\n统一过程（UP）\n软件开发过程——描述构造、不熟以及维护软件的方式\n\n四个阶段：\n\n初始——大体上的构想、业务案例、范围和模糊评估\n细化——已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估\n构造——对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署\n移交——beta测试\n\n\n&nbsp;\nUML图\n用例图、静态图（类图、包图）、行为图（状态图、活动图）、交互图（顺序图、协作图）、实现图（构建图、部署图）\n\n&nbsp;\nUML图中的关系\n泛化——继承关系，A继承B就是A泛化B，三角箭头指向父类\n实现——实现interface接口，带三角箭头的虚线指向父类\n关联——指一个类成为另一个类的成员，带普通箭头的实心，分为双向与单向（双向为纯实现）\n依赖——类成员也属于依赖的一种，依赖还包括：函数参数，函数内局部变量，虚线普通箭头指向被依赖\n聚合——特殊的关联，has-a关系，空心菱形+实线箭头，菱形是整体\n组合——特殊的关联，contains-a关系，实心菱形+实线箭头，菱形是整体（组合关系共享生命周期）\n&nbsp;\n需求分析\n\n系统需求：从系统的角度描述要提供的服务以及所受到的约束。\n功能性需求：描述系统应该做什么，即为用户和其它系统完成提供的功能和服务。\n非功能性需求：产品必须具备的属性或品质。\n\n\n\n\n&nbsp;\n需求分析的具体任务\n1.确定对系统的综合要求\n2.分析系统的数据要求\n3.导出系统的逻辑模型\n4.修正系统开发计划\n&nbsp;\n需求分析的作用\n1.客户与开发人员之间的桥梁\n2.明确系统做什么的问题\n3.降低开发风险\n&nbsp;\n需求分析过程\n1.需求获取\n2.需求建模\n3.需求文档\n&nbsp;\nFURPS+\nFunctional——功能性\nUsability——可用性\nReliability——可靠性\nPerformance——性能\nSupportability——可支持性\n”+“指以下因素：\n实现、接口、操作、包装、授权\n&nbsp;\n用例模型\n强调用户的目标何观点，目的是说明系统的功能性或行为性需求\n\n\n用例use case：一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标\n场景scenario：是参与者和系统之间的一系列特定的活动和交互，也称为用例实例use case instance\n参与者actor：是某些具有行为的事物，可以是人、计算机系统或组织\n\n\n三种格式：\n\n摘要brief：成功场景的简短摘要\n非正式casual：段落格式覆盖不同场景\n详述full-dressed：有前置条件何成功保证的各个步骤的各个变化\n\n\n\n&nbsp;\n用例的特点\n①用例用于描述系统的功能，这个功能是外部使用者看到的系统功能，不反映功能的实现方式。\n②用例描述用户提出的一些可见需求，对应一个具体的用户目标。\n③用例反映系统与用户的一次交互过程，应该具有交互信息的传递。\n④用例是对系统功能的描述，属于需求建模（功能性需求）。\n&nbsp;\n如何发现用例\n1.选择系统边界——硬件还是软件？一个人还是多个人？\n2.确定主要参与者\n3.确定主要参与者的目标\n4.命名\n&nbsp;\n用例模型准则\n\n以无用户界面约束的本质风格编写用例\n编写简洁的用例\n编写黑盒用例\n\n\n&nbsp;\n用例关系\n\n关联关系——用户与用例\n泛化关系——参与者与参与者\n包含关系——include其他用例\n扩展关系——extend其他用例\n\n\n&nbsp;\n领域模型\n定义：对领域内的概念类或现实世界中对象的可视化表示。\n领域模型是没有方法的类图的集合，并且在领域模型中不会出现软件构件\n领域模型是现实世界的一个可视化抽象字典\n\n领域模型中的概念类越多越好\n&nbsp;\nQ：为什么要建模？\nA：因为建模能帮助团队提炼出事物的本质，以便能更好的指导应用系统规划建设。\n&nbsp;\n创建领域模型的原因之一就是理解该业务的关键概念和词汇\n创建领域模型，就是以当前迭代中所要设计的需求为界：\n1.寻找概念类\n2.将其绘制为UML类图中的类\n3.添加关联和属性\n&nbsp;\n找到概念类\n1.重用和修改现有模型\n2.使用分类列表\n3.确定名词短语\n&nbsp;\n&nbsp;\n参考：OOAD基本概念-CSDN博客\n\n","categories":["设计模式"]},{"title":"面试进阶概要","url":"/2024/11/15/%E9%9D%A2%E8%AF%95%E8%BF%9B%E9%98%B6%E6%A6%82%E8%A6%81/","content":"\n\n\n\n\n11.12例行复习\n\n例行复习\n图集 drawcall相关————Unity UE适用\nQ：为什么要打图集，打图集的作用是什么？\nA：在图片渲染的过程中，涉及到一个DrawCall的过程，DrawCall的意识是CPU向GPU申请一次图像处理接口，一般情况下CPU会将图像的信息发送过去，比如物体的顶点数和面数等等，这些数据都非常大，涉及几千几万条，GPU很擅长处理大数据，但CPU不擅长，所以GPU进行计算的速度会比CPU进行调用的速度要快很多。那么CPU就很容易成为性能瓶颈了，进行UI优化的一个经典思路就是减少DrawCall，也就是尽量让CPU在一次DrawCall过程中发送更多的图像数据，因为DrawCall的过程会涉及到一些图片渲染状态的切换。无论是Unity还是UE，都有打图集的功能，图集就是将相同纹理的图片汇聚成一张图片，这样这一张图片的信息就能直接通过一次DrawCall发送给GPU了。\nUnity里面有动态批处理和静态批处理，这些都是应用层上自动打图集的一些策略。动态批处理不需要应用人员去考虑，他会自动将一些较小的mesh合并起来；静态批处理就是指一些静态的部分，比如2D地图等设置为Batching Static，然后这些静态的mesh就会合并到一块去。静态批处理、以及图集本身都有一些缺点，那就是会拷贝额外的一份图片填充内存，所以在内存紧张的情况下，有时候需要牺牲一点渲染性能。其次，通用的图集打包规则也是一个问题，比如一张很大的图集，有的一些部分可能在实际运行过程中用不到，那么这本身也就造成了一定的内存占用和性能开销。\nUnity碰撞检测\nQ：如果子弹速度很快，发生了穿透的现象，那么要如何去处理。\nA：Unity可以直接对刚体进行设置Continuous，原理是做连续、更精细的碰撞检测，比较损耗性能。第二种处理方式是使用射线检测取代碰撞体，如果子弹速度非常快的情况下，不过一般情况下比如大战场fps游戏里面的子弹速度很快，但是游戏内要考虑弹速和下坠，这个时候就会使用分段的射线检测，也就是在子弹飞行的过程中不停地向前发射有距离限制的射线，这样射线的方向就会和子弹一致，而且也会和飞行速度相匹配。\n网络同步的验证逻辑\nQ：比如说fps，如何去验证子弹是否真的打中了呢，现在有一些外挂可能会出现魔法子弹的情况。\nA：对于性能需求、体量较小的游戏推荐采用校验服，就是额外在服务端跑一个逻辑，不断向客户端发送心跳包，对客户端验证信息进行验证；如果性能需求较大，比如大型的fps，使用校验服会造成一定的网络延迟，这个时候采用哈希加密验证的方式进行数据验证，就是在两个以上的客户端的游戏里面，对要进行同步的关键数据进行哈希加密，然后客户端通过对数据进行解密来进行自验证；应用层上也有很多防止外挂的策略，这样的策略反而是最有效的，比如异常状态，服务器对多个客户端发来的数据进行比对，如果某一个客户端的数据与其他客户端不一致，那么说明这个客户端的数据异常，也有天花板策略，比如某玩家的数据比全服第一还高好几个百分比，那么说明数据异常。\nUI框架设计\nQ：一般游戏的UI底层架构是怎样的\nA：UI是分模块的，原则是不会同时出现在一块屏幕上的UI一般不会属于一个模块，这个原则也和图集规则相互适配，因为图片渲染的原则也是尽量将同一块屏幕里的图片打成一个图集。分成模块的UI在代码的表现上为一颗树，树的根部是一个消息事件中心，负责控制模块的命令调度。模块可以将自己注册在事件中心里面，也可以向事件中心发送带信息的消息，然后再由事件中心广播事件。在事件中心中对消息的定义是一个object，在Unity中可以将不同的struct直接装入object中，然后接收消息的模块需要拆开object，这个操作涉及C#的一个装箱拆箱过程，如果是其他语言，那也会有类型的数据结构。\n模块内就是一个传统的MVC架构，ctr拥有model和view的引用，负责在Unity层直接唤醒/销毁UI，view层负责持有unity控件的引用，也负责控件的表现逻辑，model则负责数据保存，数据会通过ctr中的方法进行更新，ctr中的数据更新方法又会调用模块中的信息传输方法，这些方法除了上面说的模块间消息传输，也会有与后台通信的RPC方法。\n模块的好处就是热拔插，网络游戏系统UI变动频率非常大，开发过程中需要频繁对UI进行更改，所以解耦后的模块化UI架构很适合网络游戏。\n引擎工具相关\nQ：图集工具有哪些，怎么去实现。\nA：无论是unity还是ue，制作图集本身是一件繁琐的事，他需要新建图集，然后在图集里面一个个添加图片。新建图集、添加图片这件事可以通过原本就有的插件实现，比如TexturePacker，适用多平台多引擎。\n说一下可以做的补充TP缺陷的方面。比如重打图集，TP重新打图集，需要将原来的图片删除，然后重新打一个图集出来。重打图集非常常见，比如又新进了一批UI图标，那么这一批UI图标肯定要和之前的资源打到一块去。这里涉及到一个九宫数据，就是图片边界设置，设置边界后的图片在编辑器里面进行修改（拉长缩放等）的时候会按照边界的比例来进行缩放，比如某UI框，大小经常变化，边界宽度不会变。这个边界数据需要在图集里面设置的，也会随着图集删除而丢失，所以在TP重新打包的时候，需要将这个图集的每个图片和他的九宫数据都用内存保存好，然后第二次打包的时候重新将他们自动一一设置上去。\n引用检测和查询。UI是模块化的，那么每个模块都有一个私有的图集，那么打图集的过程中就要防止模块之间的图集混用，如果AUI里面引用了BUI的资源，那么在AUI进行渲染的时候内存里就会同时出现AUI和BUI的图集资源，这样很不好。非法图集查找工具实现起来比较简单，他的原理依托于图集和UI模块规则。比如一个模块叫“背包系统”，那么图集文件夹里面也要有一个相应的“背包系统”的同名文件夹。当然具体规则也可以改变，比如加个前缀之类。Unity和UE内部都拥有查对象引用的api，这个api在很多地方都有引用，比如反射系统、垃圾回收等。引用层上可以将所有对象的引用遍历一遍，划出png格式文件，然后直接检查这个文件的路径，如果路径上对应的文件夹名字和模块名字是一致的，那么说明这个图片是合法的。\n引用查询，无论是untiy，还是UE，都只能做到查询引用，而不能查询被哪些对象引用。开发过程中经常遇到修改UI的影响面，那么这个功能就很重要。“引用查找”也有相应的插件，可以找某个小模块被哪些资源引用，原理也是通过查找对象引用的api，但是会私下用一系列字典序将引用记录下来，然后永久保存到内存当中，在需要的时候进行数据更新，这样进行查询的时候就可以直接秒查。\nUnity里面有预制体保存时的回调事件，可以在这里面进行数据内存更新，其他引擎应该也会有这个回调。永久保存可以通过Unity给的api进行，也可以直接查meta文件里的guid来进行JSON格式化保存。\n我依靠这个原理也做了依赖关系工具，针对图集专有的，更省性能，还使用了协程来进一步优化体验。有了这两个工具，那么其他一系列的和图集相关的引擎外围工具也都能开展了，比如在编辑器展示prefab的时候，可以直接对这个prefab标红，提示这个prefab是非法的；然后在这个prefab的子节点面板上，在对应出现非法图集引用的节点也标红，这些都是面向其他用户的功能需求了。\nSlate与UMG\nQ：虚幻UMG与Slate是什么关系，虚幻引擎如何进行引擎开发\nA：Unity做引擎界面开发通常会用到一些插件，比如OdinInspactor之类，这些插件的源头就是因为Unity本身做引擎修改就比较方便（在购买的前提下），而UE就麻烦了。可以说UE的所有UI界面本质上就是Slate，而Slate内部引用的是webapi的展示界面，这里不做扩展了。Slate本身是流式编程，他对[] . +这些符号都做了符号重写，比如[]的意思就是返回一个widget，而符号本身的结构直观上看起来也很像树结构，+的内部调用了addSlot()，意思是增加一个插槽。\nUE一整个编辑器就是用Slate开发出来的，但是Slate一整个架构是和UObject系统切割开来的，他太老旧了，所以研究Slate的人不多，就不会有类似OdinInspactor这样方便的插件了。虚幻里面编辑UI蓝图的编辑器，就是UMG，UMG同样底层也是Slate，但是UMG实现了Slate做不到的控件实时拖拽预览这些功能，以及控件树的实时展示，这个和[]的逻辑是一致的。当然最重要的是，UMG利用UObject将Slate系统进行包裹了，比如UMG的控件UButton拥有SBotton的引用，而UButton本身就是属于UObject系列的，这样就相当于SBotton也拥有了UObject的反射功能和蓝图交互功能，其他控件也是一样的。\n但是编辑器本身就没有这么方便了，Slate的性质就意味着修改任何控件都需要代码级别的重新编译，如果只是编辑器工具栏或者编辑器大界面这样的单例界面还好说，但是所有的细节面板都是用同一个父类实现的，也就是说没有办法去修改某个特定数据结构的细节面板，想要个性化细节面板，只能新建一个类去将他进行自定义。\nQ：Slate的结构是怎样的\nA：会有一个主面板，然后向这个面板中注册各种控件，或者界面，或者插槽。可以直接调用AddSlot来直接添加插槽，也可以使用+来添加，[]可以对控件添加子控件/插槽，这样Slate的结构就看起来很像一棵控件树，和UMG里面的控件树结构上是一致的。\nUE经典试题\nQ：说一下UE的GamePlay架构\nA：首先是UObject，提供了反射、GC、序列化等必备功能，继承UObject的一个很重要的GamePlayer相关类是UActor，Actor就是游戏对象，他本身带有网络复制和tick功能，其他的功能由Component提供，Actor可以挂载一系列的Component去实现一些特定功能，比如SceneComponent提供transform。Actor相关的类有Controller、Pawn和AInfo，Controller就是角色的控制器，Pawn就是Actor的物理表示，实现物理碰撞、Mesh渲染等功能，也会有input操作接口。AInfo代表无实体的Actor，用于记录一些对象数据，比如APlayerState，就是用于记录Actor状态的。\nGameInstance顾名思义就是游戏单例，负责进行游戏引擎的初始化，游戏地图的加载，角色的创建等，关卡的切换等。Level类就是关卡，多个关卡组成一个UWorld，关卡在UE里面可以代表完整切换场景的一个个关卡，也可以代表大世界里的某一块区域，Level拥有这个关卡里所有Actor的引用。\nGameMode继承与AInfo，也就是游戏模式，记录一个关卡的基本规则，比如游戏人数胜利条件这种数据化规则。ALevelScript也就是关卡蓝图，继承与Actor，也是和Level一一对应，但更强调事件，比如某个关卡触发一些事件会生成一些敌人。世界设置也会有相应的AInfo，类名叫WorldSetting。\n网络GamePlay层面上有一个UNetDriver类，里面会存有一些Connection，也就是网络连接。Connection继承于UPlayer，也就是UE对玩家的定义，另一个继承于UPlayer的叫LocalPlayer，也就是本地玩家。\nQ：说一下UE的网络架构\nA：UNetDriver，也就是网络管理器，负责对象的同步事件。UNetDriver里带有Connection的引用，对于服务端，每有一个客户端连接进来，就会加一个ClientConnection，而对于客户端，只会有一个ServerConnnection存在。Controller会和Connection作一一对应，Connection和LocolPlayer同级。客户端连接上服务端，也可以理解成Controller的同步过程，对于客户端来说，连接进服务端的过程就是申请连接，成功后加载服务器地图，然后服务端会创建并返回一个Controller给客户端，接着这个Controller就会根据脚本来找到对应要控制的Pawn。\n无论是Ctr，还是Pawn，这些都是Actor，而Actor是网络同步的基础对象。同步Actor有三种表现，一种是属性同步，一种是RPC调用，一种是生命周期同步。属性同步就是Actor类中有一些属性，打上一个复制标记，那么在Actor每次生命周期的同步tick时就会遍历所有带标记的属性，然后将其数据发送到服务端上。RPC调用就是对函数的标记，可以实现客户端调用到服务端的函数，也可以实现服务端调用客户端的函数。\n无论什么同步，归根结底都是一些数据包的传输，UE里面数据包的单位叫Bunch，对应UDP里面的Packet。但是UE本身就是用的可靠UDP，所以传输Bunch的实质也是传输Packet，但是Packet里面含有大量的Bunch。\nUE里面还有Channel的概念，Channel就是用来分类接收并拆分不同的Bunch的。比如有的Bunch是控制信息，那么他会最终传入ControlChannel里面处理。Channel隶属于Connection，所以Channel接收并分割的数据包最终都会回到Connection中。\nQ：UE的反射是怎么一回事\nA：我的理解是反射就是对象自省，也就是这个类本身持有类自己的一些信息，包括属性信息函数信息等，然后在运行阶段这个类的对象甚至其他对象都可以通过这些信息来对这个对象的数据进行改变，或者进行函数调用。UE通过各种标记来将代码中的一些结构划入反射系统，比如Class就用UClass来标记，Function就用UFunction，标记会在UHT的编译阶段进行展开并生成大量反射函数，这些函数就是用于记录这些被标记的属性信息的。每一个UObject都会有一个UClass的引用，UClass就是记录这些类信息的一个容器。不单单有UClass，基于不同数据结构也会有不同的描述类别，比如UEnum，UFunction等。反射可以用于多种场所，比如编辑器显示对象属性，动态调试，蓝图调用C++等，在代码里面使用反射功能最经典的方式就是调用GetClass和StaticClass方法，一个是根据对象获取对应类型信息，一个是根据类名获取一个类的类信息。\nQ：你知道蓝图和C++的关系吗\nA：在UE的源码当中，C++类又被称作Native类，特地和蓝图类做区分，因为蓝图就是用来描述某些类的，尽管蓝图类本来也是C++类。换句话说蓝图就是某些类的编辑器，但是一般情况下我们都会叫这些蓝图类直接称呼某某蓝图。\n蓝图类持有一个GeneratedClass类引用，这个引用就是这个蓝图描述出来的类，蓝图自身拥有描述这个类的逻辑，比如将这个类的一些属性通过反射功能表现出来，也可以通过蓝图标记来调用这个类的函数，而这个GeneratedClass，就是这个类的对象本质。当游戏运行起来的时候，会读取一次GeneratedClass的数据然后描述到蓝图上面，我们可以在游戏运行的时候调整这个蓝图，比如更改一些属性等，但是停止游戏的时候这些属性的更改就丢失了，编辑阶段始终以GeneratedClass为准。\n蓝图的逻辑层是通过蓝图虚拟机来运行的，蓝图的每一个节点，里面可能有好几条逻辑，每一条逻辑都叫他为statement，也就是语句，而这些语句最终会被转换成蓝图字节码，然后被蓝图虚拟机翻译成一条条C++逻辑。这些语句和汇编代码很像，比如条件跳转等等，还有一些比较重要的字节码，比如“调用某C++代码”，蓝图就是通过这样的方式调用到C++的代码的。\nC++本质上不允许调用蓝图的节点，因为C++层面根本获取不到蓝图的定义和实现。C++调用蓝图的方式只有蓝图方法在C++声明，然后在蓝图实现，这样的方法才会被C++调用到。\n我的理解是蓝图有点像插件，或者说是一个代码黑盒，当有一些属性需要实时调控或者对外开放的时候，我就会创建这个类的一个蓝图类，比如某个角色的外貌设置，替换mesh可能会涉及到路径的替换，这些最好不能写死在C++中，而且蓝图能更好地运用事件系统，逻辑更加清晰。蓝图都最好有对应的C++类，因为蓝图涉及字节码转换，本身是很消耗性能的，大部分底层相关的逻辑更适合写在C++里面。其次在多人协作方面C++是文本，蓝图是字节流，所以C++在多人协作方面有得天独厚的优势。蓝图类本身具有局限性，他可能更多和GamePlay系统相关联，而编辑器本身的一些事件就只能通过C++来利用了，比如写一些编辑器工具，和其他平台交互等等。\n\n","categories":["面试查漏补缺"]},{"title":"面向对象设计原则","url":"/2023/10/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"\n\n\n\n\n面向对象设计原则\n\n面向对象设计原则\n设计目标：\n\n开闭原则\n里氏替换原则\n迪米特原则\n\n\n\n设计方法：\n\n单一职责原则\n接口分隔原则\n依赖倒置原则\n组合/聚合复用原则\n\n\n&nbsp;\n开闭原则（OCP）\n对扩展开放、对修改关闭\n\n即在设计一个软件时，在原有的模块不修改的基础上扩展其功能。\n\n对扩展开放——代码的功能是可扩展的。\n对修改关闭——软件系统功能上的稳定性，持续性要求模块是修改关闭的\n\n\n&nbsp;\n常用方法：\n\n对软件系统中不变的部分加以抽象\n\n\n例如使用接口来抽象，新加的部分或者功能可以通过定义新接口来实现，或者来继承这个接口\n\n这里不写示例，示例详见虚函数多态部分，那个其实完全符合这个原则。\n\n&nbsp;\n里氏替换原则（LSP）\n所有引用基类的地方必须能透明地使用其派生类的对象\n子类可以扩展父类的功能，但不能改变父类原有的功能。\n\n其实也很简单，可以说成功实现违反这个原则的也算高手了。\n\n比如派生类类型使用if树来判断\n如果使用基类的地方换成派生类导致程序失效，说明不符合原则\n\n\n&nbsp;\n从这几点可以看出来什么呢，比如说多态或者说面向对象的作用就是提供单个接口来实现多个事项，这一点用ifelse树当然也能实现（但是你要是真用了我会生气的），所以优先先排除ifelse。\n&nbsp;\n至于后面一点可能理解起来比较难，我们先看Barbara Liskov 和 Jeannette Wing自己怎么说的：\nIf S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T\n\n如果S是T的子类型，对于S类型的任意对象，如果将他们看作是T类型的对象，则对象的行为也理应与期望的行为一致。\n翻译过来就是上面说的那一项的意识。\n&nbsp;\n什么叫替换？为什么必须行为一致？\n&nbsp;\n不知道你心里有没有这种感觉，自从举了if树的例子之后会感觉面向对象似乎用处并不大，因为所有东西都可以被if树替换。\n我们不妨先从现实例子来理解：\n设立电脑类，为电脑类赋予“编程（编译并运行程序）”功能\n设立程序员类，程序员类继承于电脑类，因为程序员当然也会“编程”，为程序员类添加电脑类没有的功能，比如“设计”、“聊天”、“点外卖”等等\n设立“招聘”函数，需要招聘编程人才，于是将基类电脑类对象输入，招聘函数成功招聘了“电脑”为员工一号！将程序员类对象输入，招聘函数成功招聘了“程序员”为员工二号！\n？？？\n目前看来至少程序运行还算一切正常\n那么设立一个新的函数，叫“联网”函数，目的是将输入的参数联网。\n函数成功将电脑类对象连上网了，同样也成功将程序员对象连上网了。\n越来越不对劲了。。。\n因为公司不可能招聘电脑，人也不可能联网\n一切的祸害根源，在于在现实世界中，其实“程序员类”将“电脑类”的功能重写了。\n比如联网，程序员类将联网功能函数重写成“使用电子产品联网”而不是”把自己联网“\n\n这样的例子还有很多，比如”鲸鱼“不是”鱼类“、”指针“不是”针类“。\n而设计原则始终是由人来遵循的原则，是属于“设计技巧”，对于程序来说不需要遵循，也就是说不遵循里氏替换原则的程序运行起来即有可能出现错误，也有可能不出现错误——就好比上述的例子，公司成功招聘了电脑作为员工，但如果有女同事想让新员工电脑成为她的男友，那程序就可能崩溃了。\n这一切都取决于原程序是怎样想的，至少里氏替换原则成功实现了这三点：\n\n里氏替换原则是实现开闭原则的重要方式之一。\n它克服了继承中重写父类造成的可复用性变差的缺点。\n它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。\n\n\n&nbsp;\n实现方法就是规范继承关系：\n所以说上述的例子应该改为“电脑继承于工具类”、“程序员继承于人类”看起来才会更好一些。\n这样一来，招聘公司才会从“人类”中寻找“程序员”来招聘。\n&nbsp;\n迪米特原则（LoD）\n只和朋友聊天，别和陌生人聊天\n\n朋友就是对象本身、对象引用的对象、对象创造的对象。也就是说出现在方法体内部的类，不属于朋友类。\n目的是降低类之间的耦合。\n“消息——订阅模式”是最能体现这个原则的。//这是以我目前肤浅的知识存储量得出的\n这样一种方式就是违背LoD原则的一种方式：\n    class ObjectCentre&#123;\n    public:\n        void traverse()&#123;\n            list&lt;Object&gt; AllObject=new list&lt;Object&gt;;\n            for(int i=0;i&lt;10;i++)&#123;\n                AllObject.add(new Object());\n            &#125;\n        &#125;\n    &#125;\n\n对象中心类中大量依赖了Object类，这样当然不会出现编译错误，但是造成的后果便是使得代码结构复杂，耦合性高——不用理会我写的示例代码有什么意义\n\nclass ObjectCentre&#123;\nprivate:\n    list&lt;Object&gt; AllObject;\npublic:\n    void traverse(list&lt;Object&gt; _AllObject)&#123;\n        this.AllObject=_AllObject;\n    &#125;\n&#125;\n\n这样一来，Object就于ObjectCentre成为了“朋友”\n\n用一个更直观的例子来解释，就是说迪米特法则不提倡方法类之间的直接交流，更提倡方法类之间能存在一个中介类，例如银行卡和银行，最好能有一个”交易中介“来专门负责处理银行卡和银行之间的业务交互。\n形如：\nobjectA.getObjectB().doSomething();\nobjectA.getObjectB().getObjectC().doSomething\n假设这个类叫”ME“会发现这行代码代表的类中其实仅仅只有A的朋友关系。B只和A有朋友关系，所以”ME“直接通过朋友A中的方法与B进行交流了，就好比”ME“拿起朋友A的手机找B聊天，这样当然是不允许的。\n解决方法就是把”doSomething“放到朋友A去做，也就是委托A去帮忙办事，这样朋友A就会正常找到B去办事了。\n&nbsp;\n单一职责原则\n永远不要让一个类存在多个改变的理由\n指一个类/接口/方法有且只有一个职责\n\n\n如果一个类的方法用了外部类库，但是用户没用上这个方法，则使用本库的用户这下也不得不包含这个未使用的外部类库\n如果其中一个方法被更改，则另一个方法的用户也会被影响，违反开闭原则\n\n\n降低了类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险\n&nbsp;\n接口分隔原则（ISP）\n不能强迫用户去依赖那些他们不使用的接口\n如果接口方法过多，那最好分成好几个接口\n\n&nbsp;\n单一职责原则和接口分隔原则区别——前者强调的是单一职责，针对的是程序细节，后者强调约束接口，针对抽象、整体框架。\n依赖倒置原则（DIP）\n上层模块不应该依赖于底层模块，它们都应该依赖于抽象。\n抽象不应该依赖于细节，细节应该依赖于抽象\n\n上层模块一般指实现复杂逻辑的类，底层模块一般指实现一些基本的或者初级的操作。\n在一般的程序设计中，高层模块总是依赖于底层模块。\n这里的“逻辑复杂、基本操作”其实并不是硬性指代码复杂度，而是用于称呼我们经常需要变更的代码区域就可以叫做“初级操作”——毕竟大类建立的初衷就是搭建复杂工程。\n比如我们要建立一个图书馆系统，就避免不了建立数据库，而“将图书数据存入数据库”这个操作则属于“基础操作”，因为我们有可能时不时需要变更需求，比如说图书数据今天只要存书名和编号，可能明天就要多存一个存入人姓名。但是不幸的是这个操作与图书馆整个系统是高度耦合的：\npublic class BookService\n&#123;\n    private Database database;\n\npublic BookService()\n&#123;\n    database = new Database();\n&#125;\n\npublic void AddBook(Book book)\n&#123;\n    // 调用底层模块的方法来将图书存储到数据库中\n    database.Save(book);\n&#125;\n\n}\npublic class Database{    public void Save(Book book)    {        &#x2F;&#x2F; 将图书保存到数据库的具体实现    }}\n如果更改Save为(Book book,string name)那么整个图书馆系统里面的代码也需要做相应更改，这样一来是不是觉得还不如不用面向对象，反正改了代码两边都得变，相当于“儿子犯法全家坐牢”，这样子对于面向对象来说违背了开闭原则。\n于是用依赖倒置原则来更改代码：\npublic interface IDatabase\n&#123;\n    void Save(Book book);\n&#125;\n\npublic class BookService&#123;    private IDatabase database;\npublic BookService(IDatabase database)\n&#123;\n    this.database = database;\n&#125;\n\npublic void AddBook(Book book)\n&#123;\n    // 调用抽象接口的方法来将图书存储\n    database.Save(book);\n&#125;\n\n}\npublic class Database : IDatabase{    public void Save(Book book)    {        &#x2F;&#x2F; 将图书保存到数据库的具体实现    }}\n也可以说在原来的基础上增加了多态（原谅我前几天复习完虚函数），这样更改小模块就只需要增加模块或者继承原有的这个模块就行。\n&nbsp;\n聚合复用原则\n尽量使用组合/聚合，不要使用类继承。\n\n聚合表示“拥有”，组合表示更强烈的“拥有”，就像一台电脑拥有CPU、内存、硬盘，没了这些电脑都不能运行，这就是组合；电脑可以连接外设键盘、鼠标，这就叫做聚合。\n聚合复用就是指复用代码的时候尽量挑选聚合/组合方式，而不是直接通过类继承。\n类继承之间的关系是“Is-A”，聚合之间的关系是“Has-A”\n继承的缺点：\n\n继承复用破坏封装，父类的一切实现都暴露给子类，叫做“白箱”复用\n父类发生改变子类也不得不发生改变\n继承是静态的，编译时进行，不灵活\n\n\n一个很经典的例子：“一个人不能同时成为学生、雇员、经理”\n这是不满足聚合复用原则的典型例子，因为人是后三者的父类，导致人只能成为三者之一。\n应该设立一个抽象类来当雇员、经理、学生的父类，可以在”人“类中多次实例化这个抽象类来让人来胜任多种身份。\n在其他人的博客上看过一个更能体现原理的例子，那就是汽车的颜色不同与车型号不同，这个时候不应该拿车颜色种类乘以车型号量来设置类数量，而是利用聚合复用原则来让汽车具有多种属性。在这个例子中，如果要新增汽车功能，那么类的增加将是一个很大的量级，而且所有类都要更改，如果使用聚合复用原则优化之后，只需要新建几个新的功能类即可。\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n&nbsp;\n","categories":["设计模式"]},{"title":"题外话：HPB与欧拉角与万向锁","url":"/2023/11/08/%E9%A2%98%E5%A4%96%E8%AF%9D%EF%BC%9AHPB%E4%B8%8E%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%8E%E4%B8%87%E5%90%91%E9%94%81/","content":"\n\n\n\n\n题外话：HPB与欧拉角与万向锁\n\n题外话：HPB与欧拉角与万向锁\n如果让你去定义一个物体在世界中的朝向信息，你会如何去定义？\n\n&nbsp;\n邮点问题\n万向锁本质并不难，难的是如何解释他，特别是现在众多博客，描述重点并不清晰，亦或者是过于书面化、抽象化，导致读者理解起来十分困难。\n很多人在听到这个名词的时候可能还没有遇到和万向锁相关的旋转问题，那么我们先从以下场景开始入手：\n\n打开unity添加长条物体，并保证初始的xyz轴角度都为0，现在的视角特地调整到比较好理解的角度：红色为x轴，绿色为y轴，蓝色为z轴——于此同时这个“物体坐标轴”是和世界坐标轴是相对应的。\n我们先初始定义两个概念\n\n静态坐标系——可以对应上世界坐标系，也就是物体的改变影响坐标系本身，物体的变换严格遵守这个坐标系的参照。\n动态坐标系——坐标系与物体牢牢“焊死”，方向随着物体同步改变。\n\n\n欧拉角描述的就是动态坐标系的旋转。\n欧拉角：用于计算空间中刚体的旋转位置，目的是改变刚体的朝向。欧拉角的大小描述的是结果而不是过程——这句话非常重要，在之后的理解中帮助很大\n\n\n这个神奇的“旋转”属性乍一看似乎很容易理解——”不就是绕xyz轴旋转“\n但只要读者看过我前文的两个概念，就难免会产生一个新的疑问——“这个属性到底是描述的静态坐标系，还是动态坐标系？”\n我们试着先将x改为90度，发现物体正常绕x轴旋转了90度，从这里看似乎还分辨不出坐标系：\n\n然后再将y改为90度，红色的坐标轴（x轴）对准了屏幕：\n\n对于物体身上的静态坐标轴，物体是绕着“z轴”转的，也就是说这个旋转似乎是以世界坐标轴为依据。\n然后我们又将z改为90，匪夷所思的事情发生了，物体按照原来改变y的值的路径重新转了回去。\n\n虽然图是复制过来的但事实就是如此，不信读者可以自行上号unity验证\n\n看来事情远远不止这么简单，，，，，，\n&nbsp;\n\nhalf-time\nQ：既然属性的机制如此复杂麻烦，那为何不直接使用静态坐标系来当旋转基准呢？\nA：可以从最肤浅的角度来理解，直接使用世界坐标系确实是一个简单的方法，在unity的实际操作中确实有很多直接运用世界坐标系对物体直接进行旋转的手法，但设想一下，假如我们要使用角度来描述飞机运动，那么此时此刻的角度描述是否直接通过自身坐标系会更好呢？——其实不是，我口嗨的\n\n&nbsp;\n邮点思考\n首先我们可以确定的是，这个xyz轴属性本身只是一个物体在空间中的信息，它并不代表物体的实际旋转，或者说没有直接关联。\n比如在场景中直接启用旋转工具，手动控制物体旋转，会发现偶尔会出现调整一条坐标轴却三个属性都变换的情况。\n\n&nbsp;\n读者应该对这样一个东西很熟悉：\n\n万向地球仪\n\nunity的Transform中的旋转的具体值，其实就是欧拉角的值，如果你还是对欧拉角感到陌生，那么可以直接将它理解成这样一个地球仪。\n这样的地球仪有一个很大的特点，就是旋转轴是一层套一层的，可以看见在旋转最外层的旋转轴时，里面所有的结构都会随之旋转。\n这个时候应该对欧拉角有一个初始的印象了，unity中的欧拉角轴，就是按照这种形式来旋转的，而且y轴在最外层，x轴其次，z轴在最里层。\n为什么要这样设置呢，其实笔者在各大网站上寻找观点的时候，并没有找到符合笔者心理预期的“答案”。\n于是笔者索性简单地猜测了一下：这样的设置缘由，应该只是为了响应计算机对于图形旋转的处理。\n这句话也比较抽象，如果读者对计算机图形学还没有了解，那可以先看：\n空间变换 | Coding中。。。 (jiuriri.com)\n光栅化与抗锯齿浅入 | Coding中。。。 (jiuriri.com)\n以unity为例，计算机在处理物体旋转的时候，都是通过将物体上的某点的位置信息做成矩阵，然后再通过这个矩阵与其他旋转矩阵相乘，最后得出的新矩阵作为旋转后信息。\n从GAMES101-现代计算机图形学入门-闫令琪哔哩哔哩bilibili得知，计算机在进行实际计算时，旋转矩阵是理解成三个轴分别进行旋转矩阵相乘，再组合成一个旋转矩阵来进行最终相乘。\n写在原文章中的：\nRxyz(a,b,c) = Rx(a)Ry(b)Rz(c)\n但是不用在乎这个式子的顺序，其实只是相表达旋转矩阵是由三个轴的旋转矩阵一步一步相乘得来的\n\n我们还可以从中得知静态坐标系各个变换顺序的旋转矩阵是左乘的，动态坐标系各个变换顺序的旋转矩阵是右乘的。\n这里就不详细讲了\n\n&nbsp;\n然后我们再试想这样一种情况：早上八点早起下床，那么下床这个动作可以用两种方法来实现。\n\n一种是先坐起来，然后”向左转“下床——x轴-90度，z轴-90度\n一种是先”向左翻“，然后身体侧着坐起来下床——y轴-90度，z轴-90度\n\n\n试想以头向上为y轴，面朝向为负z轴的左手坐标系\n\n最终得出的结果都是一样的，但过程其实不一样。\n&nbsp;\n从上我们可以得出什么信息呢？\n\n计算机需要一步一步进行计算\n计算机每一步进行计算后，整个坐标系都会根据计算结果发生改变\n\n\n这是什么东西？没错，就是他：\n\n&nbsp;\n\nhalf-time\nQ：为什么三个轴不一起旋转呢？\nA：有两个原因：1、这个已经解释过了，计算机的计算是一步一步来的；2、这个也许更接近本质，我们都知道物体旋转的时候轴会发生变动，那么同时旋转轴最终旋转的结果就不是我们设想的那样了——如果有模拟飞行游戏，你可以试试命令飞机一直“向右下飞”，最终的结果是飞机在天上螺旋式旋转！\n\n&nbsp;\n邮点启发\n假设绕y轴旋转为heading，绕x轴旋转为pitch，绕z轴旋转为bank（有点类似空间变换 | Coding中。。。 (jiuriri.com)中飞机旋转模型），则先heading45°再pitch90°等价于先pitch90°再bank45°。\n再联想我们之前说过的重点\n欧拉角的大小描述的是结果而不是过程\n\n经过一次又一次的强调，你是不是已经初步开始忽视欧拉角的值了呢，没错，欧拉角只是用来描述图形旋转完成后的终极朝向，而不是在描述一个图形按照什么什么方式进行旋转。简单地说，一种旋转情况可能能解出两组甚至多组欧拉角解。\n而万向锁是什么，想象一下上面那个地球仪，其实图片所示的情况就是万向锁的情况，如果我们将地球仪沿最外层旋转，和将最内层的地球进行旋转，那么得出的结果都是”水平地旋转地球“。\n在unity中将一个默认的物体x轴欧拉角旋转90度，那么调整y轴欧拉角和调整z轴欧拉角得出的结果将是一样的，这就是万向锁——他将一个方向的维度给丢失了。\n为了保证任意方位都只有独一无二的表示，Unity引擎限制了角度范围，即沿x轴旋转限制在 -90 ~ 90 之间，沿 y 与 z 轴旋转限制在 0 ~ 360 之间。\n\n欧拉角带给我们什么？它可以只使用三个数，就能够表示物体在空间中的旋转情况。缺点是什么呢，我们在旋转的过程中，再次进行欧拉角的调整往往不会向着我们预想的情况进行，更何况还有万向锁的情况发生。\n&nbsp;\n欧拉角的工程应用：飞行器姿态控制、量子力学、刚体坐标系等......\n&nbsp;\n邮点结论\n看来我们要放弃通过直接变动这个属性来实现物体旋转的想法了😦！\n比如说，如果要在代码中描述物体旋转，我们也许使用以下的方式更好些：\n\n使用四元数——可见【精选】【Unity】Unity 欧拉角、四元数、万向节死锁、四元数转轴角-CSDN博客\n\n\n\n使用旋转矩阵——可见空间变换 | Coding中。。。 (jiuriri.com)\n\n\n如果要避免万向锁，我们也可以尝试这样：\n\n限制旋转角度——这个unity默认做到了\n改变旋转顺序\n\n\n\n","categories":["计算机图形学"]}]